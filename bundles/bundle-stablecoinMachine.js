export default {"source":"function getExportWithNestedEvaluate(filePrefix) {\n  'use strict';\n  // Serialised sources.\n  if (filePrefix === undefined) {\n    filePrefix = \"/bundled-source/...\";\n  }\n  const moduleFormat = \"nestedEvaluate\";\n  const entrypoint = \"packages/treasury/src/stablecoinMachine.js\";\n  const sourceBundle = {\n  \"node_modules/@agoric/nat/dist/nat.esm.js\": \"'use strict';\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nObject.defineProperty(exports, '__esModule', { value: true }); /* Copyright (C) 2011 Google Inc.*/ /* Copyright (C) 2018 Agoric*/ /**/ /* Licensed under the Apache License, Version 2.0 (the \\\"License\\\");*/ /* you may not use this file except in compliance with the License.*/ /* You may obtain a copy of the License at*/ /**/ /* http://www.apache.org/licenses/LICENSE-2.0*/ /**/ /* Unless required by applicable law or agreed to in writing, software*/ /* distributed under the License is distributed on an \\\"AS IS\\\" BASIS,*/ /* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.*/ /* See the License for the specific language governing permissions and*/ /* limitations under the License.*/ /* @ts-check*/ /**\\n * Is `allegedNum` a number in the [contiguous range of exactly and\\n * unambiguously\\n * representable](https://esdiscuss.org/topic/more-numeric-constants-please-especially-epsilon#content-14)\\n *  natural numbers (non-negative integers)?\\n *\\n * To qualify `allegedNum` must either be a\\n * non-negative `bigint`, or a non-negative `number` representing an integer\\n * within range of [integers safely representable in\\n * floating point](https://tc39.es/ecma262/#sec-number.issafeinteger).\\n *\\n * @param {any} allegedNum\\n * @returns {boolean}\\n */\\nfunction isNat(allegedNum) {\\n  if (typeof allegedNum === 'bigint') {\\n    return allegedNum >= 0;}\\n\\n\\n  return Number.isSafeInteger(allegedNum) && allegedNum >= 0;}\\n\\n\\n/**\\n * If `allegedNumber` passes the `isNat` test, then return it as a bigint.\\n * Otherwise throw an appropriate error.\\n *\\n * If `allegedNum` is neither a bigint nor a number, `Nat` throws a `TypeError`.\\n * Otherwise, if it is not a [safely\\n * representable](https://esdiscuss.org/topic/more-numeric-constants-please-especially-epsilon#content-14)\\n * non-negative integer, `Nat` throws a `RangeError`.\\n * Otherwise, it is converted to a bigint if necessary and returned.\\n *\\n * @param {bigint | number} allegedNum\\n * @returns {bigint}\\n */\\nfunction Nat(allegedNum) {\\n  if (typeof allegedNum === 'bigint') {\\n    if (allegedNum < 0) {\\n      throw new RangeError(`${allegedNum} is negative`);}\\n\\n    return allegedNum;}\\n\\n\\n  if (typeof allegedNum === 'number') {\\n    if (!Number.isSafeInteger(allegedNum)) {\\n      throw new RangeError(`${allegedNum} not a safe integer`);}\\n\\n    if (allegedNum < 0) {\\n      throw new RangeError(`${allegedNum} is negative`);}\\n\\n    return BigInt(allegedNum);}\\n\\n\\n  throw new TypeError(\\n  `${allegedNum} is a ${typeof allegedNum} but must be a bigint or a number`);}exports.Nat = Nat;exports.isNat = isNat;\",\n  \"packages/ERTP/exported.js\": \"'use strict';require('./src/types.js');\",\n  \"packages/ERTP/src/amountMath.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var assert = require('../../assert/src/assert.js');require('../../same-structure/index.js');require('./types.js');var natMathHelpers = require('./mathHelpers/natMathHelpers.js');var setMathHelpers = require('./mathHelpers/setMathHelpers.js');var typeGuards = require('./typeGuards.js');var\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nsameStructure = require('../../same-structure/src/sameStructure.js'); /* @ts-check*/ /* We want an enum, but narrowed to the AssetKind type.*/ /**\\n * Constants for the kinds of assets we support.\\n *\\n * @type {{ NAT: 'nat', SET: 'set' }}\\n */\\nconst AssetKind = {\\n  NAT: 'nat',\\n  SET: 'set' };\\n\\nharden(AssetKind);\\n\\n/**\\n * Amounts describe digital assets. From an amount, you can learn the\\n * brand of digital asset as well as \\\"how much\\\" or \\\"how many\\\". Amounts\\n * have two parts: a brand (loosely speaking, the type of digital\\n * asset) and the value (the answer to \\\"how much\\\"). For example, in\\n * the phrase \\\"5 bucks\\\", \\\"bucks\\\" takes the role of the brand and the\\n * value is 5. Amounts can describe fungible and non-fungible digital\\n * assets. Amounts are pass-by-copy and can be made by and sent to\\n * anyone.\\n *\\n * The issuer has an internal table that maps purses and payments to\\n * amounts. The issuer must be able to do things such as add digital\\n * assets to a purse and withdraw digital assets from a purse. To do\\n * so, it must know how to add and subtract digital assets. Rather\\n * than hard-coding a particular solution, we chose to parameterize\\n * the issuer with a collection of polymorphic functions, which we\\n * call `AmountMath`. These math functions include concepts like\\n * addition, subtraction, and greater than or equal to.\\n *\\n * We also want to make sure there is no confusion as to what kind of\\n * asset we are using. Thus, AmountMath includes checks of the\\n * `brand`, the unique identifier for the type of digital asset. If\\n * the wrong brand is used in AmountMath, an error is thrown and the\\n * operation does not succeed.\\n *\\n * AmountMath uses mathHelpers to do most of the work, but then adds\\n * the brand to the result. The function `value` gets the value from\\n * the amount by removing the brand (amount -> value), and the\\n * function `make` adds the brand to produce an amount (value ->\\n * amount). The function `coerce` takes an amount and checks it,\\n * returning an amount (amount -> amount).\\n *\\n * Each issuer of digital assets has an associated brand in a\\n * one-to-one mapping. In untrusted contexts, such as in analyzing\\n * payments and amounts, we can get the brand and find the issuer\\n * which matches the brand. The issuer and the brand mutually validate\\n * each other.\\n */\\n\\n/** @type {{ nat: NatMathHelpers, set: SetMathHelpers }} */\\nconst helpers = {\\n  nat: natMathHelpers['default'],\\n  set: setMathHelpers['default'] };\\n\\n\\n/**\\n * @param {Value} value\\n * @returns {NatMathHelpers | SetMathHelpers}\\n */\\nconst getHelpersFromValue = (value) => {\\n  if (typeGuards.looksLikeSetValue(value)) {\\n    return setMathHelpers['default'];}\\n\\n  if (typeGuards.looksLikeNatValue(value)) {\\n    return natMathHelpers['default'];}\\n\\n  assert.assert.fail(assert.details`value ${value} must be a bigint or an array`);};\\n\\n\\n/** @type {(amount: Amount) => AssetKind} */\\nconst getAssetKind = (amount) => {\\n  if (typeGuards.looksLikeSetValue(amount.value)) {\\n    return 'set';}\\n\\n  if (typeGuards.looksLikeNatValue(amount.value)) {\\n    return 'nat';}\\n\\n  assert.assert.fail(assert.details`value ${amount.value} must be a bigint or an array`);};\\n\\n\\n/**\\n * @type {(amount: Amount ) => NatMathHelpers | SetMathHelpers }\\n */\\nconst getHelpersFromAmount = (amount) => {\\n  return getHelpersFromValue(amount.value);};\\n\\n\\n/** @type {(leftAmount: Amount, rightAmount: Amount ) =>\\n * NatMathHelpers | SetMathHelpers } */\\nconst getHelpers = (leftAmount, rightAmount) => {\\n  const leftHelpers = getHelpersFromAmount(leftAmount);\\n  const rightHelpers = getHelpersFromAmount(rightAmount);\\n  assert.assert.equal(leftHelpers, rightHelpers);\\n  return leftHelpers;};\\n\\n\\n/** @type {(amount: Amount, brand?: Brand) => void} */\\nconst optionalBrandCheck = (amount, brand) => {\\n  if (brand !== undefined) {\\n    sameStructure.mustBeComparable(brand);\\n    assert.assert.equal(\\n    amount.brand,\\n    brand,\\n    assert.details`amount's brand ${amount.brand} did not match expected brand ${brand}`);}};\\n\\n\\n\\n\\n/** @type {(value: Value, brand: Brand) => Amount} */\\nconst noCoerceMake = (value, brand) => {\\n  const amount = harden({ brand, value });\\n  return amount;};\\n\\n\\n/** @type {(value: Value) => void} */\\nconst assertLooksLikeValue = (value) => {\\n  assert.assert(typeGuards.looksLikeValue(value), assert.details`value ${value} must be a Nat or an array`);};\\n\\n\\n/** @type {(brand: Brand, msg?: Details) => void} */\\nconst assertLooksLikeBrand = (\\nbrand,\\nmsg = assert.details`The brand ${brand} doesn't look like a brand.`) =>\\n{\\n  assert.assert(typeGuards.looksLikeBrand(brand), msg);};\\n\\n\\n/**\\n * Give a better error message by logging the entire amount\\n * rather than just the brand\\n *\\n * @type {(amount: Amount) => void}\\n */\\nconst assertLooksLikeAmount = (amount) => {\\n  const msg = assert.details`The amount ${amount} doesn't look like an amount. Did you pass a value instead?`;\\n  assertLooksLikeBrand(amount.brand, msg);\\n  assertLooksLikeValue(amount.value);};\\n\\n\\n/**\\n * @param {Amount} leftAmount\\n * @param {Amount} rightAmount\\n * @param {Brand | undefined} brand\\n * @returns {NatMathHelpers | SetMathHelpers }\\n */\\nconst checkLRAndGetHelpers = (leftAmount, rightAmount, brand = undefined) => {\\n  assertLooksLikeAmount(leftAmount);\\n  assertLooksLikeAmount(rightAmount);\\n  optionalBrandCheck(leftAmount, brand);\\n  optionalBrandCheck(rightAmount, brand);\\n  assert.assert.equal(\\n  leftAmount.brand,\\n  rightAmount.brand,\\n  assert.details`Brands in left ${leftAmount.brand} and right ${rightAmount.brand} should match but do not`);\\n\\n  return getHelpers(leftAmount, rightAmount);};\\n\\n\\n/**\\n * @param {MathHelpers<Value>} h\\n * @param {Amount} leftAmount\\n * @param {Amount} rightAmount\\n * @returns {[Value, Value]}\\n */\\nconst coerceLR = (h, leftAmount, rightAmount) => {\\n  return [h.doCoerce(leftAmount.value), h.doCoerce(rightAmount.value)];};\\n\\n\\n/** @type {AmountMath} */\\nconst AmountMath = {\\n  /* TODO: remove when the deprecated order is no longer allowed.*/\\n  /* https://github.com/Agoric/agoric-sdk/issues/3202*/\\n  /* @ts-ignore The brand can be the second argument, but this is deprecated*/\\n  make: (brand, allegedValue) => {\\n    if (typeGuards.looksLikeBrand(allegedValue)) {\\n      /* Swap to support deprecated reverse argument order*/\\n      [brand, allegedValue] = [allegedValue, brand];} else\\n    {\\n      assertLooksLikeBrand(brand);}\\n\\n    assertLooksLikeValue(allegedValue);\\n    /* @ts-ignore Needs better typing to express Value to Helpers relationship*/\\n    const value = getHelpersFromValue(allegedValue).doCoerce(allegedValue);\\n    return harden({ brand, value });},\\n\\n  /* TODO: remove when the deprecated order is no longer allowed.*/\\n  /* https://github.com/Agoric/agoric-sdk/issues/3202*/\\n  /* @ts-ignore The brand can be the second argument, but this is deprecated*/\\n  coerce: (brand, allegedAmount) => {\\n    if (typeGuards.looksLikeBrand(allegedAmount)) {\\n      /* Swap to support deprecated reverse argument order*/\\n      [brand, allegedAmount] = [allegedAmount, brand];} else\\n    {\\n      assertLooksLikeBrand(brand);}\\n\\n    assertLooksLikeAmount(allegedAmount);\\n    assert.assert(\\n    brand === allegedAmount.brand,\\n    assert.details`The brand in the allegedAmount ${allegedAmount} in 'coerce' didn't match the specified brand ${brand}.`);\\n\\n    /* Will throw on inappropriate value*/\\n    return AmountMath.make(brand, allegedAmount.value);},\\n\\n  /* TODO: remove when the deprecated order is no longer allowed.*/\\n  /* https://github.com/Agoric/agoric-sdk/issues/3202*/\\n  /* @ts-ignore The brand can be the second argument, but this is deprecated*/\\n  getValue: (brand, amount) => AmountMath.coerce(brand, amount).value,\\n  makeEmpty: (brand, assetKind = AssetKind.NAT) => {\\n    assert.assert(\\n    helpers[assetKind],\\n    assert.details`${assetKind} must be AssetKind.NAT or AssetKind.SET`);\\n\\n    assertLooksLikeBrand(brand);\\n    return noCoerceMake(helpers[assetKind].doMakeEmpty(), brand);},\\n\\n  makeEmptyFromAmount: (amount) =>\\n  AmountMath.makeEmpty(amount.brand, getAssetKind(amount)),\\n  isEmpty: (amount, brand = undefined) => {\\n    assertLooksLikeAmount(amount);\\n    optionalBrandCheck(amount, brand);\\n    const h = getHelpersFromAmount(amount);\\n    /* @ts-ignore Needs better typing to express Value to Helpers relationship*/\\n    return h.doIsEmpty(h.doCoerce(amount.value));},\\n\\n  isGTE: (leftAmount, rightAmount, brand = undefined) => {\\n    const h = checkLRAndGetHelpers(leftAmount, rightAmount, brand);\\n    /* @ts-ignore Needs better typing to express Value to Helpers relationship*/\\n    return h.doIsGTE(...coerceLR(h, leftAmount, rightAmount));},\\n\\n  isEqual: (leftAmount, rightAmount, brand = undefined) => {\\n    const h = checkLRAndGetHelpers(leftAmount, rightAmount, brand);\\n    /* @ts-ignore Needs better typing to express Value to Helpers relationship*/\\n    return h.doIsEqual(...coerceLR(h, leftAmount, rightAmount));},\\n\\n  add: (leftAmount, rightAmount, brand = undefined) => {\\n    const h = checkLRAndGetHelpers(leftAmount, rightAmount, brand);\\n    return noCoerceMake(\\n    /* @ts-ignore Needs better typing to express Value to Helpers relationship*/\\n    h.doAdd(...coerceLR(h, leftAmount, rightAmount)),\\n    leftAmount.brand);},\\n\\n\\n  subtract: (leftAmount, rightAmount, brand = undefined) => {\\n    const h = checkLRAndGetHelpers(leftAmount, rightAmount, brand);\\n    return noCoerceMake(\\n    /* @ts-ignore Needs better typing to express Value to Helpers relationship*/\\n    h.doSubtract(...coerceLR(h, leftAmount, rightAmount)),\\n    leftAmount.brand);} };\\n\\n\\n\\nharden(AmountMath);\\n\\n/**\\n * Usage of lowercase `amountMath` is deprecated. Please import\\n * `AmountMath` instead.\\n *\\n * @deprecated\\n */\\nconst amountMath = AmountMath;exports.AmountMath = AmountMath;exports.AssetKind = AssetKind;exports.amountMath = amountMath;exports.getAssetKind = getAssetKind;\",\n  \"packages/ERTP/src/brand.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var noShim = require('../../eventual-send/src/no-shim.js');require('../../marshal/index.js');var\\n\\n\\n\\nmarshal = require('../../marshal/src/marshal.js'); /* @ts-check*/ /**\\n * @param {string} allegedName\\n * @param {(allegedIssuer: Issuer) => boolean} isMyIssuerNow\\n * @param {DisplayInfo} displayInfo\\n * @returns {Brand}\\n */\\nconst makeBrand = (allegedName, isMyIssuerNow, displayInfo) => {\\n  /** @type {Brand} */\\n  const brand = marshal.Far(`${allegedName} brand`, {\\n    isMyIssuer: (allegedIssuerP) => noShim.E.when(allegedIssuerP, isMyIssuerNow),\\n\\n    getAllegedName: () => allegedName,\\n\\n    /* Give information to UI on how to display the amount.*/\\n    getDisplayInfo: () => displayInfo });\\n\\n  return brand;};exports.makeBrand = makeBrand;\",\n  \"packages/ERTP/src/displayInfo.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var assert = require('../../assert/src/assert.js');require('../../marshal/index.js');var passStyleOf = require('../../marshal/src/passStyleOf.js');var\\n\\n\\n\\n\\n\\n\\n\\n\\nmarshal = require('../../marshal/src/marshal.js'); /* @ts-check*/ /* TODO: assertSubset and assertKeysAllowed are copied from Zoe. Move*/ /* this code to a location where it can be used by ERTP and Zoe*/ /* easily. Perhaps another package.*/ /**\\n * Assert all values from `part` appear in `whole`.\\n *\\n * @param {string[]} whole\\n * @param {string[]} part\\n */\\nconst assertSubset = (whole, part) => {\\n  part.forEach((key) => {\\n    assert.assert.typeof(key, 'string');\\n    assert.assert(\\n    whole.includes(key),\\n    assert.details`key ${assert.quote(key)} was not one of the expected keys ${assert.quote(whole)}`);});};\\n\\n\\n\\n\\n/**\\n * Assert that the keys of `record` are all in `allowedKeys`. If a key\\n * of `record` is not in `allowedKeys`, throw an error. If a key in\\n * `allowedKeys` is not a key of record, we do not throw an error.\\n *\\n * @param {string[]} allowedKeys\\n * @param {Object} record\\n */\\nconst assertKeysAllowed = (allowedKeys, record) => {\\n  const keys = Object.getOwnPropertyNames(record);\\n  assertSubset(allowedKeys, keys);\\n  /* assert that there are no symbol properties.*/\\n  assert.assert(\\n  Object.getOwnPropertySymbols(record).length === 0,\\n  assert.details`no symbol properties allowed`);};\\n\\n\\n\\n/* eslint-disable-next-line jsdoc/require-returns-check*/\\n/**\\n * @param {DisplayInfo} allegedDisplayInfo\\n * @returns {asserts allegedDisplayInfo is DisplayInfo}\\n */\\nfunction assertDisplayInfo(allegedDisplayInfo) {\\n  assert.assert(\\n  passStyleOf.passStyleOf(allegedDisplayInfo) === 'copyRecord',\\n  assert.details`A displayInfo can only be a pass-by-copy record: ${allegedDisplayInfo}`);\\n\\n  const displayInfoKeys = harden(['decimalPlaces', 'assetKind']);\\n  assertKeysAllowed(displayInfoKeys, allegedDisplayInfo);}\\n\\n\\n\\n/**\\n * @param {AdditionalDisplayInfo} allegedDisplayInfo\\n * @param {AssetKind} assetKind\\n * @returns {DisplayInfo}\\n */\\nconst coerceDisplayInfo = (allegedDisplayInfo, assetKind) => {\\n  const copyDisplayInfo = marshal.pureCopy(\\n  harden({ ...allegedDisplayInfo, assetKind }));\\n\\n  assertDisplayInfo(copyDisplayInfo);\\n  return copyDisplayInfo;};exports.assertDisplayInfo = assertDisplayInfo;exports.assertKeysAllowed = assertKeysAllowed;exports.assertSubset = assertSubset;exports.coerceDisplayInfo = coerceDisplayInfo;\",\n  \"packages/ERTP/src/index.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var amountMath = require('./amountMath.js');var issuerKit = require('./issuerKit.js');var typeGuards = require('./typeGuards.js'); /* @ts-check*/exports.AmountMath = amountMath.AmountMath;exports.AssetKind = amountMath.AssetKind;exports.amountMath = amountMath.amountMath;exports.getAssetKind = amountMath.getAssetKind;exports.makeIssuerKit = issuerKit.makeIssuerKit;exports.isNatValue = typeGuards.isNatValue;exports.looksLikeBrand = typeGuards.looksLikeBrand;exports.looksLikeNatValue = typeGuards.looksLikeNatValue;exports.looksLikeSetValue = typeGuards.looksLikeSetValue;exports.looksLikeValue = typeGuards.looksLikeValue;\",\n  \"packages/ERTP/src/issuerKit.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var assert = require('../../assert/src/assert.js');var amountMath = require('./amountMath.js');var displayInfo = require('./displayInfo.js');var brand = require('./brand.js');var paymentLedger = require('./paymentLedger.js');\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nrequire('./types.js'); /* @ts-check*/ /**\\n * @type {MakeIssuerKit}\\n */\\nconst makeIssuerKit = (\\nallegedName,\\nassetKind = amountMath.AssetKind.NAT,\\ndisplayInfo$1 = harden({}),\\noptShutdownWithFailure = undefined) =>\\n{\\n  assert.assert.typeof(allegedName, 'string');\\n  assert.assert(\\n  Object.values(amountMath.AssetKind).includes(assetKind),\\n  assert.details`The assetKind ${assetKind} must be either AssetKind.NAT or AssetKind.SET`);\\n\\n\\n  /* Add assetKind to displayInfo, or override if present*/\\n  const cleanDisplayInfo = displayInfo.coerceDisplayInfo(displayInfo$1, assetKind);\\n\\n  /**\\n   * We can define this function to use the in-scope `issuer` variable\\n   * before that variable is initialized, as long as the variable is\\n   * initialized before the function is called.\\n   *\\n   * @param {Issuer} allegedIssuer\\n   * @returns {boolean}\\n   */\\n  /* eslint-disable-next-line no-use-before-define*/\\n  const isMyIssuerNow = (allegedIssuer) => allegedIssuer === issuer;\\n\\n  const brand$1 = brand.makeBrand(allegedName, isMyIssuerNow, cleanDisplayInfo);\\n\\n  /* Attenuate the powerful authority to mint and change balances*/\\n  const { issuer, mint } = paymentLedger.makePaymentLedger(\\n  allegedName,\\n  brand$1,\\n  assetKind,\\n  cleanDisplayInfo,\\n  optShutdownWithFailure);\\n\\n\\n  return harden({\\n    brand: brand$1,\\n    issuer,\\n    mint,\\n    displayInfo: cleanDisplayInfo });};\\n\\n\\n\\nharden(makeIssuerKit);exports.makeIssuerKit = makeIssuerKit;\",\n  \"packages/ERTP/src/mathHelpers/natMathHelpers.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var nat_esm = require('../../../../node_modules/@agoric/nat/dist/nat.esm.js');require('../types.js'); /* @ts-check*/\\n\\n\\n\\n\\n\\nconst identity = 0n;\\n\\n/**\\n * Fungible digital assets use the natMathHelpers to manage balances -\\n * the operations are merely arithmetic on natural, non-negative\\n * numbers.\\n *\\n * Natural numbers are used for fungible erights such as money because\\n * rounding issues make floats problematic. All operations should be\\n * done with the smallest whole unit such that the NatMathHelpers never\\n * deals with fractional parts.\\n *\\n * @type {NatMathHelpers}\\n */\\nconst natMathHelpers = {\\n  doCoerce: nat_esm.Nat,\\n  doMakeEmpty: () => identity,\\n  doIsEmpty: (nat) => nat === identity,\\n  doIsGTE: (left, right) => left >= right,\\n  doIsEqual: (left, right) => left === right,\\n  /* BigInts don't observably overflow*/\\n  doAdd: (left, right) => left + right,\\n  doSubtract: (left, right) => nat_esm.Nat(left - right) };\\n\\n\\nharden(natMathHelpers);exports.default = natMathHelpers;\",\n  \"packages/ERTP/src/mathHelpers/setMathHelpers.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });require('../../../marshal/index.js');var assert = require('../../../assert/src/assert.js');require('../../../same-structure/index.js');require('../types.js');var passStyleOf = require('../../../marshal/src/passStyleOf.js');var\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nsameStructure = require('../../../same-structure/src/sameStructure.js'); /* @ts-check*/ /* Operations for arrays with unique objects identifying and providing*/ /* information about digital assets. Used for Zoe invites.*/ /** @type {SetValue} */\\nconst identity = harden([]);\\n\\n/**\\n * @param {Object} record\\n * @returns {string}\\n */\\nconst getKeyForRecord = (record) => {\\n  const keys = Object.getOwnPropertyNames(record);\\n  keys.sort();\\n  const values = Object.values(record).filter(\\n  (value) => typeof value === 'string');\\n\\n  values.sort();\\n  return [...keys, ...values].join();};\\n\\n\\n/**\\n * Cut down the number of sameStructure comparisons to only the ones\\n * that don't fail basic equality tests\\n * TODO: better name?\\n *\\n * @param {SetValueElem} thing\\n * @returns {SetValueElem}\\n */\\nconst hashBadly = (thing) => {\\n  const type = typeof thing;\\n  const allowableNonObjectValues = ['string', 'number', 'bigint', 'boolean'];\\n  if (allowableNonObjectValues.includes(type)) {\\n    return thing;}\\n\\n  if (passStyleOf.passStyleOf(thing) === 'remotable') {\\n    return thing;}\\n\\n  if (passStyleOf.passStyleOf(thing) === 'copyRecord') {\\n    return getKeyForRecord(thing);}\\n\\n  assert.assert.fail(\\n  assert.details`typeof ${typeof thing} is not allowed in an amount of AssetKind.SET`);};\\n\\n\\n\\n/**\\n * @typedef {Map<SetValueElem, SetValueElem[]>} Buckets\\n */\\n\\n/**\\n * @param {SetValueElem[]} list\\n * @returns {Buckets}\\n */\\nconst makeBuckets = (list) => {\\n  const buckets = new Map();\\n  list.forEach((elem) => {\\n    const badHash = hashBadly(elem);\\n    if (!buckets.has(badHash)) {\\n      buckets.set(badHash, []);}\\n\\n    const soFar = buckets.get(badHash);\\n    soFar.push(elem);});\\n\\n  return buckets;};\\n\\n\\n/**\\n * Based on bucket sort\\n *\\n * @param {Buckets} buckets\\n */\\nconst checkForDupes = (buckets) => {\\n  for (const maybeMatches of buckets.values()) {\\n    for (let i = 0; i < maybeMatches.length; i += 1) {\\n      for (let j = i + 1; j < maybeMatches.length; j += 1) {\\n        assert.assert(\\n        !sameStructure.sameStructure(maybeMatches[i], maybeMatches[j]),\\n        assert.details`value has duplicates: ${maybeMatches[i]} and ${maybeMatches[j]}`);}}}};\\n\\n\\n\\n\\n\\n\\n/**\\n *\\n * @param {Buckets} buckets\\n * @param {SetValueElem} elem\\n * @returns {boolean}\\n */\\nconst hasElement = (buckets, elem) => {\\n  const badHash = hashBadly(elem);\\n  if (!buckets.has(badHash)) {\\n    return false;}\\n\\n  const maybeMatches = buckets.get(badHash);\\n  assert.assert(maybeMatches);\\n  return maybeMatches.some((maybeMatch) => sameStructure.sameStructure(maybeMatch, elem));};\\n\\n\\n/* get a string of string keys and string values as a fuzzy hash for*/\\n/* bucketing.*/\\n/* only use sameStructure within that bucket.*/\\n\\n/**\\n * @type {SetMathHelpers}\\n */\\nconst setMathHelpers = harden({\\n  doCoerce: (list) => {\\n    harden(list);\\n    sameStructure.mustBeComparable(list);\\n    assert.assert(passStyleOf.passStyleOf(list) === 'copyArray', 'list must be an array');\\n    checkForDupes(makeBuckets(list));\\n    return list;},\\n\\n  doMakeEmpty: () => identity,\\n  doIsEmpty: (list) => passStyleOf.passStyleOf(list) === 'copyArray' && list.length === 0,\\n  doIsGTE: (left, right) => {\\n    const leftBuckets = makeBuckets(left);\\n    return right.every((rightElem) => hasElement(leftBuckets, rightElem));},\\n\\n  doIsEqual: (left, right) => {\\n    return left.length === right.length && setMathHelpers.doIsGTE(left, right);},\\n\\n  doAdd: (left, right) => {\\n    const combined = harden([...left, ...right]);\\n    checkForDupes(makeBuckets(combined));\\n    return combined;},\\n\\n  doSubtract: (left, right) => {\\n    const leftBuckets = makeBuckets(left);\\n    const rightBuckets = makeBuckets(right);\\n    right.forEach((rightElem) => {\\n      assert.assert(\\n      hasElement(leftBuckets, rightElem),\\n      assert.details`right element ${rightElem} was not in left`);});\\n\\n\\n    /**\\n     * @param {SetValueElem} leftElem\\n     * @returns {boolean}\\n     */\\n    const leftElemNotInRight = (leftElem) => !hasElement(rightBuckets, leftElem);\\n    return harden(left.filter(leftElemNotInRight));} });\\n\\n\\n\\nharden(setMathHelpers);exports.default = setMathHelpers;\",\n  \"packages/ERTP/src/payment.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });require('../../marshal/index.js');var\\n\\n\\n\\nmarshal = require('../../marshal/src/marshal.js'); /* @ts-check*/ /**\\n * @param {string} allegedName\\n * @param {Brand} brand\\n * @returns {Payment}\\n */\\nconst makePayment = (allegedName, brand) => {\\n  return marshal.Far(`${allegedName} payment`, {\\n    getAllegedBrand: () => brand });};exports.makePayment = makePayment;\",\n  \"packages/ERTP/src/paymentLedger.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var assert = require('../../assert/src/assert.js');var noShim = require('../../eventual-send/src/no-shim.js');var promiseKit = require('../../promise-kit/src/promiseKit.js');require('../../marshal/index.js');require('../../store/src/index.js');var amountMath = require('./amountMath.js');var payment = require('./payment.js');var purse = require('./purse.js');require('../../store/exported.js');var weakStore = require('../../store/src/weak-store.js');var\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nmarshal = require('../../marshal/src/marshal.js'); /* @ts-check*/ /**\\n * Make the paymentLedger, the source of truth for the balances of\\n * payments. All minting and transfer authority originates here.\\n *\\n * @param {string} allegedName\\n * @param {Brand} brand\\n * @param {AssetKind} assetKind\\n * @param {DisplayInfo} displayInfo\\n * @param {ShutdownWithFailure=} optShutdownWithFailure\\n * @returns {{ issuer: Issuer, mint: Mint }}\\n */\\nconst makePaymentLedger = (\\nallegedName,\\nbrand,\\nassetKind,\\ndisplayInfo,\\noptShutdownWithFailure = undefined) =>\\n{\\n  /** @type {ShutdownWithFailure} */\\n  const shutdownLedgerWithFailure = (reason) => {\\n    /* TODO This should also destroy ledger state.*/\\n    /* See https://github.com/Agoric/agoric-sdk/issues/3434*/\\n    if (optShutdownWithFailure !== undefined) {\\n      optShutdownWithFailure(reason);}\\n\\n    throw reason;};\\n\\n\\n  /** @type {WeakStore<Payment, Amount>} */\\n  const paymentLedger = weakStore.makeWeakStore('payment');\\n\\n  /** @type {(left: Amount, right: Amount) => Amount } */\\n  const add = (left, right) => amountMath.AmountMath.add(left, right, brand);\\n  /** @type {(left: Amount, right: Amount) => Amount } */\\n  const subtract = (left, right) => amountMath.AmountMath.subtract(left, right, brand);\\n  /** @type {(allegedAmount: Amount) => Amount} */\\n  const coerce = (allegedAmount) => amountMath.AmountMath.coerce(brand, allegedAmount);\\n  /** @type {(left: Amount, right: Amount) => boolean } */\\n  const isEqual = (left, right) => amountMath.AmountMath.isEqual(left, right, brand);\\n\\n  /** @type {Amount} */\\n  const emptyAmount = amountMath.AmountMath.makeEmpty(brand, assetKind);\\n\\n  /**\\n   * Methods like deposit() have an optional second parameter `amount`\\n   * which, if present, is supposed to be equal to the balance of the\\n   * payment. This helper function does that check.\\n   *\\n   * @param {Amount} paymentBalance\\n   * @param {Amount | undefined} amount\\n   * @returns {void}\\n   */\\n  const assertAmountConsistent = (paymentBalance, amount) => {\\n    if (amount !== undefined) {\\n      assert.assert(\\n      isEqual(amount, paymentBalance),\\n      assert.details`payment balance ${paymentBalance} must equal amount ${amount}`);}};\\n\\n\\n\\n\\n  /**\\n   * @param {Payment} payment\\n   * @returns {void}\\n   */\\n  const assertLivePayment = (payment) => {\\n    assert.assert(paymentLedger.has(payment), assert.details`payment not found for ${allegedName}`);};\\n\\n\\n  /**\\n   * Reallocate assets from the `payments` passed in to new payments\\n   * created and returned, with balances from `newPaymentBalances`.\\n   * Enforces that total assets are conserved.\\n   *\\n   * Note that this is not the only operation that reallocates assets.\\n   * `purse.deposit` and `purse.withdraw` move assets between a purse and\\n   * a payment, and so must also enforce conservation there.\\n   *\\n   * @param {Payment[]} payments\\n   * @param {Amount[]} newPaymentBalances\\n   * @returns {Payment[]}\\n   */\\n  const reallocate = (payments, newPaymentBalances) => {\\n    /* There may be zero, one, or many payments as input to*/\\n    /* reallocate. We want to protect against someone passing in*/\\n    /* what appears to be multiple payments that turn out to actually*/\\n    /* be the same payment (an aliasing issue). The `combine` method*/\\n    /* legitimately needs to take in multiple payments, but we don't*/\\n    /* need to pay the costs of protecting against aliasing for the*/\\n    /* other uses.*/\\n\\n    if (payments.length > 1) {\\n      const antiAliasingStore = new Set();\\n      payments.forEach((payment) => {\\n        if (antiAliasingStore.has(payment)) {\\n          throw Error('same payment seen twice');}\\n\\n        antiAliasingStore.add(payment);});}\\n\\n\\n\\n    const total = payments.map(paymentLedger.get).reduce(add, emptyAmount);\\n\\n    const newTotal = newPaymentBalances.reduce(add, emptyAmount);\\n\\n    /* Invariant check*/\\n    assert.assert(\\n    isEqual(total, newTotal),\\n    assert.details`rights were not conserved: ${total} vs ${newTotal}`);\\n\\n\\n    let newPayments;\\n    try {\\n      /* COMMIT POINT*/\\n      payments.forEach((payment) => paymentLedger.delete(payment));\\n\\n      newPayments = newPaymentBalances.map((balance) => {\\n        const newPayment = payment.makePayment(allegedName, brand);\\n        paymentLedger.init(newPayment, balance);\\n        return newPayment;});}\\n\\n    catch (err) {\\n      shutdownLedgerWithFailure(err);\\n      throw err;}\\n\\n    return harden(newPayments);};\\n\\n\\n  /** @type {IssuerIsLive} */\\n  const isLive = (paymentP) => {\\n    return noShim.E.when(paymentP, (payment) => {\\n      return paymentLedger.has(payment);});};\\n\\n\\n\\n  /** @type {IssuerGetAmountOf} */\\n  const getAmountOf = (paymentP) => {\\n    return noShim.E.when(paymentP, (payment) => {\\n      assertLivePayment(payment);\\n      return paymentLedger.get(payment);});};\\n\\n\\n\\n  /** @type {IssuerBurn} */\\n  const burn = (paymentP, optAmount = undefined) => {\\n    return noShim.E.when(paymentP, (payment) => {\\n      assertLivePayment(payment);\\n      const paymentBalance = paymentLedger.get(payment);\\n      assertAmountConsistent(paymentBalance, optAmount);\\n      try {\\n        /* COMMIT POINT.*/\\n        paymentLedger.delete(payment);}\\n      catch (err) {\\n        shutdownLedgerWithFailure(err);\\n        throw err;}\\n\\n      return paymentBalance;});};\\n\\n\\n\\n  /** @type {IssuerClaim} */\\n  const claim = (paymentP, optAmount = undefined) => {\\n    return noShim.E.when(paymentP, (srcPayment) => {\\n      assertLivePayment(srcPayment);\\n      const srcPaymentBalance = paymentLedger.get(srcPayment);\\n      assertAmountConsistent(srcPaymentBalance, optAmount);\\n      /* Note COMMIT POINT within reallocate.*/\\n      const [payment] = reallocate([srcPayment], [srcPaymentBalance]);\\n      return payment;});};\\n\\n\\n\\n  /** @type {IssuerCombine} */\\n  const combine = (fromPaymentsPArray, optTotalAmount = undefined) => {\\n    /* Payments in `fromPaymentsPArray` must be distinct. Alias*/\\n    /* checking is delegated to the `reallocate` function.*/\\n    return Promise.all(fromPaymentsPArray).then((fromPaymentsArray) => {\\n      fromPaymentsArray.every(assertLivePayment);\\n      const totalPaymentsBalance = fromPaymentsArray.\\n      map(paymentLedger.get).\\n      reduce(add, emptyAmount);\\n      assertAmountConsistent(totalPaymentsBalance, optTotalAmount);\\n      /* Note COMMIT POINT within reallocate.*/\\n      const [payment] = reallocate(fromPaymentsArray, [totalPaymentsBalance]);\\n      return payment;});};\\n\\n\\n\\n  /** @type {IssuerSplit} */\\n  /* payment to two payments, A and B*/\\n  const split = (paymentP, paymentAmountA) => {\\n    return noShim.E.when(paymentP, (srcPayment) => {\\n      paymentAmountA = coerce(paymentAmountA);\\n      assertLivePayment(srcPayment);\\n      const srcPaymentBalance = paymentLedger.get(srcPayment);\\n      const paymentAmountB = subtract(srcPaymentBalance, paymentAmountA);\\n      /* Note COMMIT POINT within reallocate.*/\\n      const newPayments = reallocate(\\n      [srcPayment],\\n      [paymentAmountA, paymentAmountB]);\\n\\n      return newPayments;});};\\n\\n\\n\\n  /** @type {IssuerSplitMany} */\\n  const splitMany = (paymentP, amounts) => {\\n    return noShim.E.when(paymentP, (srcPayment) => {\\n      assertLivePayment(srcPayment);\\n      amounts = amounts.map(coerce);\\n      /* Note COMMIT POINT within reallocate.*/\\n      const newPayments = reallocate([srcPayment], amounts);\\n      return newPayments;});};\\n\\n\\n\\n  /** @type {MintPayment} */\\n  const mintPayment = (newAmount) => {\\n    newAmount = coerce(newAmount);\\n    const payment$1 = payment.makePayment(allegedName, brand);\\n    paymentLedger.init(payment$1, newAmount);\\n    return payment$1;};\\n\\n\\n  /**\\n   * Used by the purse code to implement purse.deposit\\n   *\\n   * @param {Amount} currentBalance - the current balance of the purse\\n   * before a deposit\\n   * @param {(newPurseBalance: Amount) => void} updatePurseBalance -\\n   * commit the purse balance\\n   * @param {Payment} srcPayment\\n   * @param {Amount=} optAmount\\n   * @returns {Amount}\\n   */\\n  const deposit = (\\n  currentBalance,\\n  updatePurseBalance,\\n  srcPayment,\\n  optAmount = undefined) =>\\n  {\\n    if (promiseKit.isPromise(srcPayment)) {\\n      throw TypeError(\\n      `deposit does not accept promises as first argument. Instead of passing the promise (deposit(paymentPromise)), consider unwrapping the promise first: E.when(paymentPromise, (actualPayment => deposit(actualPayment))`);}\\n\\n\\n    assertLivePayment(srcPayment);\\n    const srcPaymentBalance = paymentLedger.get(srcPayment);\\n    /* Note: this does not guarantee that optAmount itself is a valid stable amount*/\\n    assertAmountConsistent(srcPaymentBalance, optAmount);\\n    const newPurseBalance = add(srcPaymentBalance, currentBalance);\\n    try {\\n      /* COMMIT POINT*/\\n      /* Move the assets in `srcPayment` into this purse, using up the*/\\n      /* source payment, such that total assets are conserved.*/\\n      paymentLedger.delete(srcPayment);\\n      updatePurseBalance(newPurseBalance);}\\n    catch (err) {\\n      shutdownLedgerWithFailure(err);\\n      throw err;}\\n\\n    return srcPaymentBalance;};\\n\\n\\n  /**\\n   * Used by the purse code to implement purse.withdraw\\n   *\\n   * @param {Amount} currentBalance - the current balance of the purse\\n   * before a withdrawal\\n   * @param {(newPurseBalance: Amount) => void} updatePurseBalance -\\n   * commit the purse balance\\n   * @param {Amount} amount - the amount to be withdrawn\\n   * @returns {Payment}\\n   */\\n  const withdraw = (currentBalance, updatePurseBalance, amount) => {\\n    amount = coerce(amount);\\n    const newPurseBalance = subtract(currentBalance, amount);\\n    const payment$1 = payment.makePayment(allegedName, brand);\\n    try {\\n      /* COMMIT POINT*/\\n      /* Move the withdrawn assets from this purse into a new payment*/\\n      /* which is returned. Total assets must remain conserved.*/\\n      updatePurseBalance(newPurseBalance);\\n      paymentLedger.init(payment$1, amount);}\\n    catch (err) {\\n      shutdownLedgerWithFailure(err);\\n      throw err;}\\n\\n    return payment$1;};\\n\\n\\n  const purseMethods = {\\n    deposit,\\n    withdraw };\\n\\n\\n  /** @type {Issuer} */\\n  const issuer = marshal.Far(`${allegedName} issuer`, {\\n    isLive,\\n    getAmountOf,\\n    burn,\\n    claim,\\n    combine,\\n    split,\\n    splitMany,\\n    getBrand: () => brand,\\n    getAllegedName: () => allegedName,\\n    getAssetKind: () => assetKind,\\n    getDisplayInfo: () => displayInfo,\\n    makeEmptyPurse: () =>\\n    purse.makePurse(allegedName, assetKind, brand, purseMethods) });\\n\\n\\n  /** @type {Mint} */\\n  const mint = marshal.Far(`${allegedName} mint`, {\\n    getIssuer: () => issuer,\\n    mintPayment });\\n\\n\\n  return harden({\\n    issuer,\\n    mint });};exports.makePaymentLedger = makePaymentLedger;\",\n  \"packages/ERTP/src/purse.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });require('../../notifier/src/index.js');require('../../marshal/index.js');var amountMath = require('./amountMath.js');var notifier = require('../../notifier/src/notifier.js');var marshal = require('../../marshal/src/marshal.js');\\n\\n\\n\\nconst makePurse = (allegedName, assetKind, brand, purseMethods) => {\\n  let currentBalance = amountMath.AmountMath.makeEmpty(brand, assetKind);\\n\\n  /** @type {NotifierRecord<Amount>} */\\n  const {\\n    notifier: balanceNotifier,\\n    updater: balanceUpdater } =\\n  notifier.makeNotifierKit(currentBalance);\\n\\n  const updatePurseBalance = (newPurseBalance) => {\\n    currentBalance = newPurseBalance;\\n    balanceUpdater.updateState(currentBalance);};\\n\\n\\n  /** @type {Purse} */\\n  const purse = marshal.Far(`${allegedName} purse`, {\\n    deposit: (srcPayment, optAmount = undefined) => {\\n      /* Note COMMIT POINT within deposit.*/\\n      return purseMethods.deposit(\\n      currentBalance,\\n      updatePurseBalance,\\n      srcPayment,\\n      optAmount);},\\n\\n\\n    withdraw: (amount) =>\\n    /* Note COMMIT POINT within withdraw.*/\\n    purseMethods.withdraw(currentBalance, updatePurseBalance, amount),\\n    getCurrentAmount: () => currentBalance,\\n    getCurrentAmountNotifier: () => balanceNotifier,\\n    getAllegedBrand: () => brand,\\n    /* eslint-disable-next-line no-use-before-define*/\\n    getDepositFacet: () => depositFacet });\\n\\n\\n  const depositFacet = marshal.Far(`${allegedName} depositFacet`, {\\n    receive: purse.deposit });\\n\\n\\n  return purse;};exports.makePurse = makePurse;\",\n  \"packages/ERTP/src/typeGuards.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var nat_esm = require('../../../node_modules/@agoric/nat/dist/nat.esm.js');require('../../marshal/index.js');var passStyleOf = require('../../marshal/src/passStyleOf.js');\\n\\n\\nconst { isFrozen } = Object;\\n\\n/* A type guard predicate named `looksLikeFoo` tests that something seems to be*/\\n/* a Foo, produces static type info on the truthy path alleging that it is a*/\\n/* Foo, but does not validate that it is a well formed Foo. Names like `isFoo`*/\\n/* should be reserved for predicates that actually validate objects coming from*/\\n/* untrusted callers.*/\\n/**/\\n/* The corresponding assertions would be `assertLooksLikeFoo` and `assertFoo`.*/\\n/* These produce the same static type info, but on the success path rather than*/\\n/* the truthy path.*/\\n\\n/**\\n * Non-validating type guard for SetValue\\n *\\n * Used as a pre-validation check to select which validator\\n * (mathHelpers) to use, and also used with assert to satisfy\\n * Typescript checking\\n *\\n * @param {Value} value\\n * @returns {value is SetValue}\\n */\\nconst looksLikeSetValue = (value) => Array.isArray(value);\\n\\n/**\\n * Non-validating type guard for NatValue.\\n *\\n * Used as a pre-validation check to select which validator\\n * (mathHelpers) to use, and also used with assert to satisfy\\n * Typescript checking\\n *\\n * @param {Value} value\\n * @returns {value is NatValue}\\n */\\nconst looksLikeNatValue = (value) => nat_esm.isNat(value);\\n\\n/**\\n * Call this for a validated answer (that in this case happens to be the same).\\n *\\n * @param {Value} value\\n * @returns {value is NatValue}\\n */\\nconst isNatValue = looksLikeNatValue;\\n\\n/**\\n * Non-validating type guard for Value.\\n *\\n * @param {Value} value\\n * @returns {value is Value}\\n */\\nconst looksLikeValue = (value) =>\\nlooksLikeSetValue(value) || looksLikeNatValue(value);\\n\\n/**\\n * Non-validating type guard for Brand.\\n *\\n * @param {Brand} brand\\n * @returns {brand is Brand}\\n */\\nconst looksLikeBrand = (brand) =>\\nisFrozen(brand) && passStyleOf.passStyleOf(brand) === 'remotable';exports.isNatValue = isNatValue;exports.looksLikeBrand = looksLikeBrand;exports.looksLikeNatValue = looksLikeNatValue;exports.looksLikeSetValue = looksLikeSetValue;exports.looksLikeValue = looksLikeValue;\",\n  \"packages/ERTP/src/types.js\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n'use strict'; /* eslint-disable-next-line spaced-comment*/ /*/ <reference types=\\\"ses\\\"/>*/ /**\\n * @template T\\n * @typedef {Ximport('@agoric/promise-kit').ERef<T>} ERef\\n */ /**\\n * @typedef {Ximport('@agoric/marshal').InterfaceSpec} InterfaceSpec\\n * @typedef {Ximport('@agoric/marshal').GetInterfaceOf} GetInterfaceOf\\n */ /**\\n * @typedef {Object} Amount\\n * Amounts are descriptions of digital assets, answering the questions\\n * \\\"how much\\\" and \\\"of what kind\\\". Amounts are values labeled with a brand.\\n * AmountMath executes the logic of how amounts are changed when digital\\n * assets are merged, separated, or otherwise manipulated. For\\n * example, a deposit of 2 bucks into a purse that already has 3 bucks\\n * gives a new purse balance of 5 bucks. An empty purse has 0 bucks. AmountMath\\n * relies heavily on polymorphic MathHelpers, which manipulate the unbranded\\n * portion.\\n *\\n * @property {Brand} brand\\n * @property {Value} value\\n */ /**\\n * @typedef {NatValue | SetValue} Value\\n * Values describe the value of something that can be owned or shared.\\n * Fungible values are normally represented by natural numbers. Other\\n * values may be represented as strings naming a particular right, or\\n * an arbitrary object that sensibly represents the rights at issue.\\n *\\n * Value must be Comparable. (Would be nice to type this correctly.)\\n */ /**\\n * @typedef {'nat' | 'set' } AssetKind\\n */ /**\\n * @callback MakeEmpty\\n * @param {Brand} brand\\n * @param {AssetKind=} assetKind\\n * @returns {Amount}\\n */ /**\\n * This section blindly imitates what Endo's ses/src/error/types.js\\n * does to express type overloaded methods.\\n *\\n * @callback AmountMakeBrandValue\\n * @param {Brand} brand\\n * @param {Value} allegedValue\\n * @returns {Amount}\\n *\\n * TODO find out how to get this \\\"deprecated\\\" marking recognized,\\n * or remove it.\\n * @deprecated Use brand-first overload instead\\n * @callback AmountMakeValueBrand\\n * Please use the brand-first overload. The value-first overload\\n * is deprecated and will go way.\\n * @param {Value} brand\\n * @param {Brand} allegedValue\\n * @returns {Amount}\\n *\\n * @typedef {AmountMakeBrandValue & AmountMakeValueBrand} AmountMake\\n *\\n * @callback AmountCoerceBrandAmount\\n * @param {Brand} brand\\n * @param {Amount} allegedAmount\\n * @returns {Amount}\\n *\\n * TODO find out how to get this \\\"deprecated\\\" marking recognized,\\n * or remove it.\\n * @deprecated Use brand-first overload instead\\n * @callback AmountCoerceAmountBrand\\n * Please use the brand-first overload. The amount-first overload\\n * is deprecated and will go way.\\n * @param {Amount} brand\\n * @param {Brand} allegedAmount\\n * @returns {Amount}\\n *\\n * @typedef {AmountCoerceBrandAmount & AmountCoerceAmountBrand} AmountCoerce\\n *\\n * @callback AmountGetValueBrandAmount\\n * @param {Brand} brand\\n * @param {Amount} allegedAmount\\n * @returns {Value}\\n *\\n * TODO find out how to get this \\\"deprecated\\\" marking recognized,\\n * or remove it.\\n * @deprecated Use brand-first overload instead\\n * @callback AmountGetValueAmountBrand\\n * Please use the brand-first overload. The amount-first overload\\n * is deprecated and will go way.\\n * @param {Amount} brand\\n * @param {Brand} allegedAmount\\n * @returns {Value}\\n *\\n * @typedef {AmountGetValueBrandAmount & AmountGetValueAmountBrand} AmountGetValue\\n */ /**\\n * @typedef {Object} AmountMath\\n * Logic for manipulating amounts.\\n *\\n * Amounts are the canonical description of tradable goods. They are manipulated\\n * by issuers and mints, and represent the goods and currency carried by purses\\n * and\\n * payments. They can be used to represent things like currency, stock, and the\\n * abstract right to participate in a particular exchange.\\n *\\n * @property {AmountMake} make\\n * Make an amount from a value by adding the brand.\\n * Please use the brand-first overload. The value-first overload\\n * is deprecated and will go way.\\n *\\n * @property {AmountCoerce} coerce\\n * Make sure this amount is valid enough, and return a corresponding\\n * valid amount if so.\\n * Please use the brand-first overload. The amount-first overload\\n * is deprecated and will go way.\\n *\\n * @property {AmountGetValue} getValue\\n * Extract and return the value.\\n * Please use the brand-first overload. The amount-first overload\\n * is deprecated and will go way.\\n *\\n * @property {MakeEmpty} makeEmpty\\n * Return the amount representing an empty amount. This is the\\n * identity element for MathHelpers.add and MatHelpers.subtract.\\n *\\n * @property {(amount: Amount) => Amount} makeEmptyFromAmount\\n * Return the amount representing an empty amount, using another\\n * amount as the template for the brand and assetKind.\\n *\\n * @property {(amount: Amount, brand?: Brand) => boolean} isEmpty\\n * Return true if the Amount is empty. Otherwise false.\\n *\\n * @property {(leftAmount: Amount, rightAmount: Amount, brand?: Brand) => boolean} isGTE\\n * Returns true if the leftAmount is greater than or equal to the\\n * rightAmount. For non-scalars, \\\"greater than or equal to\\\" depends\\n * on the kind of amount, as defined by the MathHelpers. For example,\\n * whether rectangle A is greater than rectangle B depends on whether rectangle\\n * A includes rectangle B as defined by the logic in MathHelpers.\\n *\\n * @property {(leftAmount: Amount, rightAmount: Amount, brand?: Brand) => boolean} isEqual\\n * Returns true if the leftAmount equals the rightAmount. We assume\\n * that if isGTE is true in both directions, isEqual is also true\\n *\\n * @property {(leftAmount: Amount, rightAmount: Amount, brand?: Brand) => Amount} add\\n * Returns a new amount that is the union of both leftAmount and rightAmount.\\n *\\n * For fungible amount this means adding the values. For other kinds of\\n * amount, it usually means including all of the elements from both\\n * left and right.\\n *\\n * @property {(leftAmount: Amount, rightAmount: Amount, brand?: Brand) => Amount} subtract\\n * Returns a new amount that is the leftAmount minus the rightAmount\\n * (i.e. everything in the leftAmount that is not in the\\n * rightAmount). If leftAmount doesn't include rightAmount\\n * (subtraction results in a negative), throw  an error. Because the\\n * left amount must include the right amount, this is NOT equivalent\\n * to set subtraction.\\n */ /**\\n * @typedef {Object} DisplayInfo\\n * @property {number=} decimalPlaces Tells the display software how\\n *   many decimal places to move the decimal over to the left, or in\\n *   other words, which position corresponds to whole numbers. We\\n *   require fungible digital assets to be represented in integers, in\\n *   the smallest unit (i.e. USD might be represented in mill, a\\n *   thousandth of a dollar. In that case, `decimalPlaces` would be\\n *   3.) This property is optional, and for non-fungible digital\\n *   assets, should not be specified. The decimalPlaces property\\n *   should be used for *display purposes only*. Any other use is an\\n *   anti-pattern.\\n * @property {AssetKind} assetKind - the kind of asset, either\\n *   AssetKind.NAT (fungible) or AssetKind.SET (non-fungible)\\n */ /**\\n * @typedef {Object} Brand\\n * The brand identifies the kind of issuer, and has a function to get the\\n * alleged name for the kind of asset described. The alleged name (such\\n * as 'BTC' or 'moola') is provided by the maker of the issuer and should\\n * not be trusted as accurate.\\n *\\n * Every amount created by a particular AmountMath will share the same brand,\\n * but recipients cannot rely on the brand to verify that a purported amount\\n * represents the issuer they intended, since the same brand can be reused by\\n * a misbehaving issuer.\\n *\\n * @property {(allegedIssuer: ERef<Issuer>) => Promise<boolean>} isMyIssuer Should be used with\\n * `issuer.getBrand` to ensure an issuer and brand match.\\n * @property {() => string} getAllegedName\\n * @property {() => DisplayInfo} getDisplayInfo\\n *  Give information to UI on how to display the amount.\\n */ /**\\n * @callback IssuerBurn\\n *\\n * Burn all of the digital assets in the\\n * payment. `optAmount` is optional. If `optAmount` is present, the\\n * code will insist that the amount of the digital assets in the\\n * payment is equal to `optAmount`, to prevent sending the wrong\\n * payment and other confusion.\\n *\\n * If the payment is a promise, the operation will proceed upon\\n * resolution.\\n *\\n * @param {ERef<Payment>} payment\\n * @param {Amount=} optAmount\\n * @returns {Promise<Amount>}\\n */ /**\\n * @callback IssuerClaim\\n *\\n * Transfer all digital assets from the payment to a new payment and\\n * delete the original. `optAmount` is optional. If `optAmount` is\\n * present, the code will insist that the amount of digital assets in\\n * the payment is equal to `optAmount`, to prevent sending the wrong\\n * payment and other confusion.\\n *\\n * If the payment is a promise, the operation will proceed upon\\n * resolution.\\n *\\n * @param {ERef<Payment>} payment\\n * @param {Amount=} optAmount\\n * @returns {Promise<Payment>}\\n */ /**\\n * @callback IssuerIsLive\\n *\\n * Return true if the payment continues to exist.\\n *\\n * If the payment is a promise, the operation will proceed upon\\n * resolution.\\n *\\n * @param {ERef<Payment>} payment\\n * @returns {Promise<boolean>}\\n */ /**\\n * @callback IssuerGetAmountOf\\n *\\n * Get the amount of digital assets in the payment. Because the\\n * payment is not trusted, we cannot call a method on it directly, and\\n * must use the issuer instead.\\n *\\n * If the payment is a promise, the operation will proceed upon\\n * resolution.\\n *\\n * @param {ERef<Payment>}\\n * @returns {Promise<Amount>}\\n *\\n */ /**\\n * @callback IssuerCombine\\n *\\n * Combine multiple payments into one payment.\\n *\\n * If any of the payments is a promise, the operation will proceed\\n * upon resolution.\\n *\\n * @param {ERef<Payment>[]} paymentsArray\\n * @param {Amount=} optTotalAmount\\n * @returns {Promise<Payment>}\\n */ /**\\n * @callback IssuerSplit\\n *\\n * Split a single payment into two payments,\\n * A and B, according to the paymentAmountA passed in.\\n *\\n * If the payment is a promise, the operation will proceed upon\\n * resolution.\\n *\\n * @param {ERef<Payment>} payment\\n * @param {Amount} paymentAmountA\\n * @returns {Promise<Payment[]>}\\n */ /**\\n * @callback IssuerSplitMany\\n *\\n * Split a single payment into many payments, according to the amounts\\n * passed in.\\n *\\n * If the payment is a promise, the operation will proceed upon\\n * resolution.\\n *\\n * @param {ERef<Payment>} payment\\n * @param {Amount[]} amounts\\n * @returns {Promise<Payment[]>}\\n *\\n */ /**\\n * @typedef {Object} Issuer\\n *\\n * The issuer cannot mint a new amount, but it can create empty purses\\n * and payments. The issuer can also transform payments (splitting\\n * payments, combining payments, burning payments, and claiming\\n * payments exclusively). The issuer should be gotten from a trusted\\n * source and then relied upon as the decider of whether an untrusted\\n * payment is valid.\\n *\\n * @property {() => Brand} getBrand Get the Brand for this Issuer. The\\n * Brand indicates the type of digital asset and is shared by the\\n * mint, the issuer, and any purses and payments of this particular\\n * kind. The brand is not closely held, so this function should not be\\n * trusted to identify an issuer alone. Fake digital assets and amount\\n * can use another issuer's brand.\\n *\\n * @property {() => string} getAllegedName Get the allegedName for\\n * this mint/issuer\\n * @property {() => AssetKind} getAssetKind Get the kind of\\n * MathHelpers used by this Issuer.\\n * @property {() => DisplayInfo} getDisplayInfo Give information to UI\\n *  on how to display amounts for this issuer.\\n * @property {() => Purse} makeEmptyPurse Make an empty purse of this\\n * brand.\\n * @property {IssuerIsLive} isLive\\n * @property {IssuerGetAmountOf} getAmountOf\\n * @property {IssuerBurn} burn\\n * @property {IssuerClaim} claim\\n * @property {IssuerCombine} combine\\n * @property {IssuerSplit} split\\n * @property {IssuerSplitMany} splitMany\\n */ /**\\n * @typedef {Object} AdditionalDisplayInfo\\n *\\n * Does not include `assetKind`, which is automatically added in MakeIssuerKit\\n * @property {number=} decimalPlaces Tells the display software how\\n *   many decimal places to move the decimal over to the left, or in\\n *   other words, which position corresponds to whole numbers. We\\n *   require fungible digital assets to be represented in integers, in\\n *   the smallest unit (i.e. USD might be represented in mill, a\\n *   thousandth of a dollar. In that case, `decimalPlaces` would be\\n *   3.) This property is optional, and for non-fungible digital\\n *   assets, should not be specified. The decimalPlaces property\\n *   should be used for *display purposes only*. Any other use is an\\n *   anti-pattern.\\n */ /**\\n * @callback ShutdownWithFailure\\n * Called to shut something down because something went wrong, where the reason\\n * is supposed to be an Error that describes what went wrong. Some valid\\n * implementations of `ShutdownWithFailure` will never return, either\\n * because they throw or because they immediately shutdown the enclosing unit\\n * of computation. However, they also might return, so the caller should\\n * follow this call by their own defensive `throw reason;` if appropriate.\\n *\\n * @param {Error} reason\\n * @returns {void}\\n */ /**\\n * @callback MakeIssuerKit\\n * @param {string} allegedName\\n * @param {AssetKind} [assetKind=AssetKind.NAT]\\n * @param {AdditionalDisplayInfo} [displayInfo={}]\\n * @param {ShutdownWithFailure=} optShutdownWithFailure If this issuer fails\\n * in the middle of an atomic action (which btw should never happen), it\\n * potentially leaves its ledger in a corrupted state. If this function was\\n * provided, then it the failed atomic action will call it, so that some\\n * larger unit of computation, like the enclosing vat, can be shutdown\\n * before anything else is corrupted by that corrupted state.\\n * See https://github.com/Agoric/agoric-sdk/issues/3434\\n * @returns {IssuerKit}\\n *\\n * The allegedName becomes part of the brand in asset descriptions. The\\n * allegedName doesn't have to be a string, but it will only be used for\\n * its value. The allegedName is useful for debugging and double-checking\\n * assumptions, but should not be trusted.\\n *\\n * The assetKind will be used to import a specific mathHelpers\\n * from the mathHelpers library. For example, natMathHelpers, the\\n * default, is used for basic fungible tokens.\\n *\\n *  `displayInfo` gives information to UI on how to display the amount.\\n *\\n * @typedef {Object} IssuerKit\\n * The return value of makeIssuerKit\\n *\\n * @property {Mint} mint\\n * @property {Issuer} issuer\\n * @property {Brand} brand\\n * @property {DisplayInfo} displayInfo\\n */ /**\\n * @callback MintPayment\\n *\\n * Creates a new Payment containing newly minted amount.\\n *\\n * @param {Amount} newAmount\\n * @returns {Payment}\\n */ /**\\n * @typedef {Object} Mint\\n * Holding a Mint carries the right to issue new digital assets. These\\n * assets all have the same kind, which is called a Brand.\\n *\\n * @property {() => Issuer} getIssuer Gets the Issuer for this mint.\\n * @property {MintPayment} mintPayment\\n */ /**\\n * @callback DepositFacetReceive\\n * @param {Payment} payment\\n * @param {Amount=} optAmount\\n * @returns {Amount}\\n */ /**\\n * @typedef {Object} DepositFacet\\n * @property {DepositFacetReceive} receive\\n * Deposit all the contents of payment into the purse that made this facet,\\n * returning the amount. If the optional argument `optAmount` does not equal the\\n * amount of digital assets in the payment, throw an error.\\n *\\n * If payment is a promise, throw an error.\\n */ /**\\n * @callback PurseDeposit\\n * @param {Payment} payment\\n * @param {Amount=} optAmount\\n * @returns {Amount}\\n */ /**\\n * @typedef {Object} Purse\\n * Purses hold amount of digital assets of the same brand, but unlike Payments, they are\\n * not meant to be sent to others. To transfer digital assets, a\\n * Payment should be withdrawn from a Purse. The amount of digital\\n * assets in a purse can change through the action of deposit() and withdraw().\\n *\\n * The primary use for Purses and Payments is for currency-like and goods-like\\n * digital assets, but they can also be used to represent other kinds of rights, such\\n * as the right to participate in a particular contract.\\n *\\n * @property {() => Brand} getAllegedBrand Get the alleged Brand for this Purse\\n *\\n * @property {() => Amount} getCurrentAmount\\n * Get the amount contained in this purse.\\n *\\n * @property {() => Notifier<Amount>} getCurrentAmountNotifier\\n * Get a lossy notifier for changes to this purse's balance.\\n *\\n * @property {PurseDeposit} deposit\\n * Deposit all the contents of payment into this purse, returning the\\n * amount. If the optional argument `optAmount` does not equal the\\n * amount of digital assets in the payment, throw an error.\\n *\\n * If payment is a promise, throw an error.\\n *\\n * @property {() => DepositFacet} getDepositFacet\\n * Return an object whose `receive` method deposits to the current Purse.\\n *\\n * @property {(amount: Amount) => Payment} withdraw\\n * Withdraw amount from this purse into a new Payment.\\n */ /**\\n * @typedef {Object} Payment\\n * Payments hold amount of digital assets of the same brand in transit. Payments can\\n * be deposited in purses, split into multiple payments, combined, and\\n * claimed (getting an exclusive payment). Payments are linear, meaning\\n * that either a payment has the same amount of digital assets it\\n * started with, or it is used up entirely. It is impossible to partially use a payment.\\n *\\n * Payments are often received from other actors and therefore should\\n * not be trusted themselves. To get the amount of digital assets in a payment, use the\\n * trusted issuer: issuer.getAmountOf(payment),\\n *\\n * Payments can be converted to Purses by getting a trusted issuer and\\n * calling `issuer.makeEmptyPurse()` to create a purse, then `purse.deposit(payment)`.\\n *\\n * @property {() => Brand} getAllegedBrand\\n * Get the allegedBrand, indicating the type of digital asset this\\n * payment purports to be, and which issuer to use. Because payments\\n * are not trusted, any method calls on payments should be treated\\n * with suspicion and verified elsewhere.\\n */ /**\\n * @template V\\n * @typedef {Object} MathHelpers<V>\\n * All of the difference in how digital asset amount are manipulated can be reduced to\\n * the behavior of the math on values. We extract this\\n * custom logic into mathHelpers. MathHelpers are about value\\n * arithmetic, whereas AmountMath is about amounts, which are the\\n * values labeled with a brand. AmountMath use mathHelpers to do their value arithmetic,\\n * and then brand the results, making a new amount.\\n *\\n * The MathHelpers are designed to be called only from AmountMath, and so\\n * all methods but coerce can assume their inputs are valid. They only\\n * need to do output validation, and only when there is a possibility of\\n * invalid output.\\n *\\n * @property {(allegedValue: V) => V} doCoerce\\n * Check the kind of this value and throw if it is not the\\n * expected kind.\\n *\\n * @property {() => V} doMakeEmpty\\n * Get the representation for the identity element (often 0 or an\\n * empty array)\\n *\\n * @property {(value: V) => boolean} doIsEmpty\\n * Is the value the identity element?\\n *\\n * @property {(left: V, right: V) => boolean} doIsGTE\\n * Is the left greater than or equal to the right?\\n *\\n * @property {(left: V, right: V) => boolean} doIsEqual\\n * Does left equal right?\\n *\\n * @property {(left: V, right: V) => V} doAdd\\n * Return the left combined with the right.\\n *\\n * @property {(left: V, right: V) => V} doSubtract\\n * Return what remains after removing the right from the left. If\\n * something in the right was not in the left, we throw an error.\\n */ /**\\n * @typedef {bigint} NatValue\\n */ /**\\n * @typedef {Comparable} SetValueElem\\n */ /**\\n * @typedef {Array<SetValueElem>} SetValue\\n */ /**\\n * @typedef {MathHelpers<NatValue>} NatMathHelpers\\n */ /**\\n * @typedef {MathHelpers<SetValue>} SetMathHelpers\\n */\",\n  \"packages/SwingSet/exported.js\": \"'use strict';require('./src/vats/types.js');\",\n  \"packages/SwingSet/src/vats/types.js\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n'use strict'; /**\\n * @typedef {Object} TimerService Gives the ability to get the current time,\\n * schedule a single wake() call, create a repeater that will allow scheduling\\n * of events at regular intervals, or remove scheduled calls.\\n * @property {() => Timestamp} getCurrentTimestamp Retrieve the latest timestamp\\n * @property {(baseTime: Timestamp, waker: ERef<TimerWaker>) => Timestamp} setWakeup Return\\n * value is the time at which the call is scheduled to take place\\n * @property {(waker: ERef<TimerWaker>) => Array<Timestamp>} removeWakeup Remove the waker\\n * from all its scheduled wakeups, whether produced by `timer.setWakeup(h)` or\\n * `repeater.schedule(h)`.\\n * @property {(delay: RelativeTime, interval: RelativeTime) => TimerRepeater} createRepeater\\n * DEPRECATED: use makeRepeater instead.\\n * @property {(delaySecs: RelativeTime, interval: RelativeTime) => TimerRepeater} makeRepeater\\n * Create and return a repeater that will schedule `wake()` calls\\n * repeatedly at times that are a multiple of interval following delay.\\n * Interval is the difference between successive times at which wake will be\\n * called.  When `schedule(w)` is called, `w.wake()` will be scheduled to be\\n * called after the next multiple of interval from the base. Since times can be\\n * coarse-grained, the actual call may occur later, but this won't change when\\n * the next event will be called.\\n * @property {(delaySecs: RelativeTime, interval: RelativeTime) => Notifier<Timestamp>} makeNotifier\\n * Create and return a Notifier that will deliver updates repeatedly at times\\n * that are a multiple of interval following delay.\\n */ /**\\n * @typedef {bigint} Timestamp An absolute individual stamp returned by a\\n * TimerService.  Note that different timer services may have different\\n * interpretations of actual Timestamp values.\\n * @typedef {bigint} RelativeTime Difference between two Timestamps.  Note that\\n * different timer services may have different interpretations of actual\\n * RelativeTime values.\\n */ /**\\n * @typedef {Object} TimerWaker\\n * @property {(timestamp: Timestamp) => void} wake The timestamp passed to\\n * `wake()` is the time that the call was scheduled to occur.\\n */ /**\\n * @typedef {Object} TimerRepeater\\n * @property {(waker: ERef<TimerWaker>) => Timestamp} schedule Returns the time scheduled for\\n * the first call to `E(waker).wake()`.  The waker will continue to be scheduled\\n * every interval until the repeater is disabled.\\n * @property {() => void} disable Disable this repeater, so `schedule(w)` can't\\n * be called, and wakers already scheduled with this repeater won't be\\n * rescheduled again after `E(waker).wake()` is next called on them.\\n */\",\n  \"packages/assert/exported.js\": \"'use strict';require('./src/types.js');\",\n  \"packages/assert/src/assert.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });require('./types.js'); /* global globalThis */\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nconst { freeze } = Object;\\n\\n/** @type {Assert} */\\nconst globalAssert = globalThis.assert;\\n\\nif (globalAssert === undefined) {\\n  throw new Error(\\n  `Cannot initialize @agoric/assert, missing globalThis.assert`);}\\n\\n\\n\\nconst missing = [\\n'fail',\\n'equal',\\n'typeof',\\n'string',\\n'note',\\n'details',\\n'quote',\\n'makeAssert'].\\nfilter((name) => globalAssert[name] === undefined);\\nif (missing.length > 0) {\\n  throw new Error(\\n  `Cannot initialize @agoric/assert, missing globalThis.assert methods ${missing.join(\\n  ', ')\\n  }`);}\\n\\n\\n\\nconst { details, quote, makeAssert } = globalAssert;\\n\\n\\n\\n\\n\\n\\n\\n/**\\n * Prepend the correct indefinite article onto a noun, typically a typeof result\\n * e.g., \\\"an Object\\\" vs. \\\"a Number\\\"\\n *\\n * @deprecated\\n * @param {string} str The noun to prepend\\n * @returns {string} The noun prepended with a/an\\n */\\nfunction an(str) {\\n  str = `${str}`;\\n  if (str.length >= 1 && 'aeiouAEIOU'.includes(str[0])) {\\n    return `an ${str}`;}\\n\\n  return `a ${str}`;}\\n\\nfreeze(an);exports.an = an;exports.assert = globalAssert;exports.details = details;exports.makeAssert = makeAssert;exports.q = quote;exports.quote = quote;\",\n  \"packages/assert/src/types.js\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n'use strict'; /* @ts-check*/ /* eslint-disable-next-line spaced-comment*/ /*/ <reference types=\\\"ses\\\"/>*/ /* Based on*/ /* https://github.com/Agoric/SES-shim/blob/master/packages/ses/src/error/types.js*/ /* Coordinate edits until we refactor to avoid this duplication*/ /* At https://github.com/Agoric/agoric-sdk/issues/2774*/ /* is a record of a failed attempt to remove this duplication.*/ /**\\n * @callback BaseAssert\\n * The `assert` function itself.\\n *\\n * @param {*} flag The truthy/falsy value\\n * @param {Details=} optDetails The details to throw\\n * @param {ErrorConstructor=} ErrorConstructor An optional alternate error\\n * constructor to use.\\n * @returns {asserts flag}\\n */ /**\\n * @typedef {Object} AssertMakeErrorOptions\\n * @property {string=} errorName\\n */ /**\\n * @callback AssertMakeError\\n *\\n * The `assert.error` method, recording details for the console.\\n *\\n * The optional `optDetails` can be a string.\\n * @param {Details=} optDetails The details of what was asserted\\n * @param {ErrorConstructor=} ErrorConstructor An optional alternate error\\n * constructor to use.\\n * @param {AssertMakeErrorOptions=} options\\n * @returns {Error}\\n */ /**\\n * @callback AssertFail\\n *\\n * The `assert.fail` method.\\n *\\n * Fail an assertion, recording details to the console and\\n * raising an exception with just type information.\\n *\\n * The optional `optDetails` can be a string for backwards compatibility\\n * with the nodejs assertion library.\\n * @param {Details=} optDetails The details of what was asserted\\n * @param {ErrorConstructor=} ErrorConstructor An optional alternate error\\n * constructor to use.\\n * @returns {never}\\n */ /**\\n * @callback AssertEqual\\n * The `assert.equal` method\\n *\\n * Assert that two values must be `Object.is`.\\n * @param {*} actual The value we received\\n * @param {*} expected What we wanted\\n * @param {Details=} optDetails The details to throw\\n * @param {ErrorConstructor=} ErrorConstructor An optional alternate error\\n * constructor to use.\\n * @returns {void}\\n */ /* Type all the overloads of the assertTypeof function.*/ /* There may eventually be a better way to do this, but*/ /* thems the breaks with Typescript 4.0.*/ /**\\n * @callback AssertTypeofBigint\\n * @param {any} specimen\\n * @param {'bigint'} typename\\n * @param {Details=} optDetails\\n * @returns {asserts specimen is bigint}\\n *\\n * @callback AssertTypeofBoolean\\n * @param {any} specimen\\n * @param {'boolean'} typename\\n * @param {Details=} optDetails\\n * @returns {asserts specimen is boolean}\\n *\\n * @callback AssertTypeofFunction\\n * @param {any} specimen\\n * @param {'function'} typename\\n * @param {Details=} optDetails\\n * @returns {asserts specimen is Function}\\n *\\n * @callback AssertTypeofNumber\\n * @param {any} specimen\\n * @param {'number'} typename\\n * @param {Details=} optDetails\\n * @returns {asserts specimen is number}\\n *\\n * @callback AssertTypeofObject\\n * @param {any} specimen\\n * @param {'object'} typename\\n * @param {Details=} optDetails\\n * @returns {asserts specimen is Record<any, any> | null}\\n *\\n * @callback AssertTypeofString\\n * @param {any} specimen\\n * @param {'string'} typename\\n * @param {Details=} optDetails\\n * @returns {asserts specimen is string}\\n *\\n * @callback AssertTypeofSymbol\\n * @param {any} specimen\\n * @param {'symbol'} typename\\n * @param {Details=} optDetails\\n * @returns {asserts specimen is symbol}\\n *\\n * @callback AssertTypeofUndefined\\n * @param {any} specimen\\n * @param {'undefined'} typename\\n * @param {Details=} optDetails\\n * @returns {asserts specimen is undefined}\\n */ /**\\n * The `assert.typeof` method\\n *\\n * @typedef {AssertTypeofBigint & AssertTypeofBoolean & AssertTypeofFunction & AssertTypeofNumber & AssertTypeofObject & AssertTypeofString & AssertTypeofSymbol & AssertTypeofUndefined} AssertTypeof\\n */ /**\\n * @callback AssertString\\n * The `assert.string` method.\\n *\\n * `assert.string(v)` is equivalent to `assert.typeof(v, 'string')`. We\\n * special case this one because it is the most frequently used.\\n *\\n * Assert an expected typeof result.\\n * @param {any} specimen The value to get the typeof\\n * @param {Details=} optDetails The details to throw\\n */ /**\\n * @callback AssertNote\\n * The `assert.note` method.\\n *\\n * Annotate this error with these details, potentially to be used by an\\n * augmented console, like the causal console of `console.js`, to\\n * provide extra information associated with logged errors.\\n *\\n * @param {Error} error\\n * @param {Details} detailsNote\\n * @returns {void}\\n */ /* /////////////////////////////////////////////////////////////////////////////*/ /**\\n * @typedef {{}} DetailsToken\\n * A call to the `details` template literal makes and returns a fresh details\\n * token, which is a frozen empty object associated with the arguments of that\\n * `details` template literal expression.\\n */ /**\\n * @typedef {string | DetailsToken} Details\\n * Either a plain string, or made by the `details` template literal tag.\\n */ /**\\n * @typedef {Object} StringablePayload\\n * Holds the payload passed to quote so that its printed form is visible.\\n * @property {() => string} toString How to print the payload\\n */ /**\\n * To \\\"declassify\\\" and quote a substitution value used in a\\n * details`...` template literal, enclose that substitution expression\\n * in a call to `quote`. This states that the argument should appear quoted\\n * (as if with `JSON.stringify`), in the error message of the thrown error. The\\n * payload itself is still passed unquoted to the console as it would be\\n * without `quote`.\\n *\\n * Starting from the example in the `details` comment, say instead that the\\n * color the sky is supposed to be is also computed. Say that we still don't\\n * want to reveal the sky's actual color, but we do want the thrown error's\\n * message to reveal what color the sky was supposed to be:\\n * ```js\\n * assert.equal(\\n *   sky.color,\\n *   color,\\n *   details`${sky.color} should be ${quote(color)}`,\\n * );\\n * ```\\n *\\n * The normal convention is to locally rename `quote` to `q` and\\n * `details` to `X`\\n * ```js\\n * const { details: X, quote: q } = assert;\\n * ```\\n * so the above example would then be\\n * ```js\\n * assert.equal(\\n *   sky.color,\\n *   color,\\n *   X`${sky.color} should be ${q(color)}`,\\n * );\\n * ```\\n *\\n * @callback AssertQuote\\n * @param {*} payload What to declassify\\n * @param {(string|number)=} spaces\\n * @returns {StringablePayload} The declassified payload\\n */ /**\\n * @callback Raise\\n *\\n * To make an `assert` which terminates some larger unit of computation\\n * like a transaction, vat, or process, call `makeAssert` with a `Raise`\\n * callback, where that callback actually performs that larger termination.\\n * If possible, the callback should also report its `reason` parameter as\\n * the alleged reason for the termination.\\n *\\n * @param {Error} reason\\n */ /**\\n * @callback MakeAssert\\n *\\n * Makes and returns an `assert` function object that shares the bookkeeping\\n * state defined by this module with other `assert` function objects made by\\n * `makeAssert`. This state is per-module-instance and is exposed by the\\n * `loggedErrorHandler` above. We refer to `assert` as a \\\"function object\\\"\\n * because it can be called directly as a function, but also has methods that\\n * can be called.\\n *\\n * If `optRaise` is provided, the returned `assert` function object will call\\n * `optRaise(reason)` before throwing the error. This enables `optRaise` to\\n * engage in even more violent termination behavior, like terminating the vat,\\n * that prevents execution from reaching the following throw. However, if\\n * `optRaise` returns normally, which would be unusual, the throw following\\n * `optRaise(reason)` would still happen.\\n *\\n * @param {Raise=} optRaise\\n * @param {boolean=} unredacted\\n * @returns {Assert}\\n */ /**\\n * @typedef {(template: TemplateStringsArray | string[], ...args: any) => DetailsToken} DetailsTag\\n *\\n * Use the `details` function as a template literal tag to create\\n * informative error messages. The assertion functions take such messages\\n * as optional arguments:\\n * ```js\\n * assert(sky.isBlue(), details`${sky.color} should be \\\"blue\\\"`);\\n * ```\\n * The details template tag returns a `DetailsToken` object that can print\\n * itself with the formatted message in two ways.\\n * It will report the real details to\\n * the console but include only the typeof information in the thrown error\\n * to prevent revealing secrets up the exceptional path. In the example\\n * above, the thrown error may reveal only that `sky.color` is a string,\\n * whereas the same diagnostic printed to the console reveals that the\\n * sky was green.\\n *\\n * The `raw` member of a `template` is ignored, so a simple\\n * `string[]` can also be used as a template.\\n */ /**\\n * assert that expr is truthy, with an optional details to describe\\n * the assertion. It is a tagged template literal like\\n * ```js\\n * assert(expr, details`....`);`\\n * ```\\n *\\n * The literal portions of the template are assumed non-sensitive, as\\n * are the `typeof` types of the substitution values. These are\\n * assembled into the thrown error message. The actual contents of the\\n * substitution values are assumed sensitive, to be revealed to\\n * the console only. We assume only the virtual platform's owner can read\\n * what is written to the console, where the owner is in a privileged\\n * position over computation running on that platform.\\n *\\n * The optional `optDetails` can be a string for backwards compatibility\\n * with the nodejs assertion library.\\n *\\n * @typedef { BaseAssert & {\\n *   typeof: AssertTypeof,\\n *   error: AssertMakeError,\\n *   fail: AssertFail,\\n *   equal: AssertEqual,\\n *   string: AssertString,\\n *   note: AssertNote,\\n *   details: DetailsTag,\\n *   quote: AssertQuote,\\n *   makeAssert: MakeAssert,\\n * } } Assert\\n */\",\n  \"packages/eventual-send/src/E.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var\\n\\n\\ntrackTurns = require('./track-turns.js'); /* eslint-disable-next-line spaced-comment*/ /*/ <reference path=\\\"index.d.ts\\\" />*/\\n\\nconst readOnlyProxyHandler = {\\n  set(_target, _prop, _value) {\\n    return false;},\\n\\n  isExtensible(_target) {\\n    return false;},\\n\\n  setPrototypeOf(_target, _value) {\\n    return false;},\\n\\n  deleteProperty(_target, _prop) {\\n    return false;} };\\n\\n\\n\\n/**\\n * A Proxy handler for E(x).\\n *\\n * @param {*} x Any value passed to E(x)\\n * @param {*} HandledPromise\\n * @returns {ProxyHandler} the Proxy handler\\n */\\nfunction EProxyHandler(x, HandledPromise) {\\n  return harden({\\n    ...readOnlyProxyHandler,\\n    get(_target, p, _receiver) {\\n      /* Harden this Promise because it's our only opportunity to ensure*/\\n      /* p1=E(x).foo() is hardened. The Handled Promise API does not (yet)*/\\n      /* allow the handler to synchronously influence the promise returned*/\\n      /* by the handled methods, so we must freeze it from the outside. See*/\\n      /* #95 for details.*/\\n      return (...args) => harden(HandledPromise.applyMethod(x, p, args));},\\n\\n    apply(_target, _thisArg, argArray = []) {\\n      return harden(HandledPromise.applyFunction(x, argArray));},\\n\\n    has(_target, _p) {\\n      /* We just pretend everything exists.*/\\n      return true;} });}\\n\\n\\n\\n\\n/**\\n * A Proxy handler for E.sendOnly(x)\\n * For now it is just a variant on the E(x) Proxy handler.\\n *\\n * @param {*} x Any value passed to E.sendOnly(x)\\n * @param {*} HandledPromise\\n * @returns {ProxyHandler} the Proxy handler\\n */\\nfunction EsendOnlyProxyHandler(x, HandledPromise) {\\n  return harden({\\n    ...readOnlyProxyHandler,\\n    get(_target, p, _receiver) {\\n      return (...args) => {\\n        HandledPromise.applyMethod(x, p, args);\\n        return undefined;};},\\n\\n\\n    apply(_target, _thisArg, argsArray = []) {\\n      HandledPromise.applyFunction(x, argsArray);\\n      return undefined;},\\n\\n    has(_target, _p) {\\n      /* We just pretend that every thing exists.*/\\n      return true;} });}\\n\\n\\n\\n\\nfunction makeE(HandledPromise) {\\n  function E(x) {\\n    const handler = EProxyHandler(x, HandledPromise);\\n    return harden(new Proxy(() => {}, handler));}\\n\\n\\n  const makeEGetterProxy = (x) =>\\n  new Proxy(Object.create(null), {\\n    ...readOnlyProxyHandler,\\n    has(_target, _prop) {\\n      return true;},\\n\\n    get(_target, prop) {\\n      return harden(HandledPromise.get(x, prop));} });\\n\\n\\n\\n  E.G = makeEGetterProxy;\\n  E.get = makeEGetterProxy;\\n  E.resolve = HandledPromise.resolve;\\n  E.sendOnly = (x) => {\\n    const handler = EsendOnlyProxyHandler(x, HandledPromise);\\n    return harden(new Proxy(() => {}, handler));};\\n\\n\\n  E.when = (x, onfulfilled = undefined, onrejected = undefined) => {\\n    const [onsuccess, onfailure] = trackTurns.trackTurns([onfulfilled, onrejected]);\\n    return HandledPromise.resolve(x).then(onsuccess, onfailure);};\\n\\n\\n  return harden(E);}exports.default = makeE;\",\n  \"packages/eventual-send/src/no-shim.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var E$1 = require('./E.js'); /* global HandledPromise */\\n\\n\\nconst hp = HandledPromise;\\nconst E = E$1['default'](HandledPromise);exports.E = E;exports.HandledPromise = hp;\",\n  \"packages/eventual-send/src/track-turns.js\": \"'use strict';\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nObject.defineProperty(exports, '__esModule', { value: true }); /* global globalThis */ /* @ts-nocheck*/ /* NOTE: We can't import these because they're not in scope before lockdown.*/ /* import { assert, details as X } from '@agoric/assert';*/ /* WARNING: Global Mutable State!*/ /* This state is communicated to `assert` that makes it available to the*/ /* causal console, which affects the console log output. Normally we*/ /* regard the ability to see console log output as a meta-level privilege*/ /* analogous to the ability to debug. Aside from that, this module should*/ /* not have any observably mutable state.*/\\n\\nlet hiddenPriorError;\\nlet hiddenCurrentTurn = 0;\\nlet hiddenCurrentEvent = 0;\\n\\n/* Turn on if you seem to be losing error logging at the top of the event loop*/\\nconst VERBOSE = false;\\n\\n/**\\n * @typedef {((...args: any[]) => any) | void} TurnStarterFn\\n * An optional function that is not this-sensitive, expected to be called at\\n * bottom of stack to start a new turn.\\n */\\n\\n/**\\n * Given a list of `TurnStarterFn`s, returns a list of `TurnStarterFn`s whose\\n * `this`-free call behaviors are not observably different to those that\\n * cannot see console output. The only purpose is to cause additional\\n * information to appear on the console.\\n *\\n * The call to `trackTurns` is itself a sending event, that occurs in some call\\n * stack in some turn number at some event number within that turn. Each call\\n * to any of the returned `TurnStartFn`s is a receiving event that begins a new\\n * turn. This sending event caused each of those receiving events.\\n *\\n * @param {TurnStarterFn[]} funcs\\n * @returns {TurnStarterFn[]}\\n */\\nconst trackTurns = (funcs) => {\\n  if (typeof globalThis === 'undefined' || !globalThis.assert) {\\n    return funcs;}\\n\\n  const { details: X } = assert;\\n\\n  hiddenCurrentEvent += 1;\\n  const sendingError = new Error(\\n  `Event: ${hiddenCurrentTurn}.${hiddenCurrentEvent}`);\\n\\n  if (hiddenPriorError !== undefined) {\\n    assert.note(sendingError, X`Caused by: ${hiddenPriorError}`);}\\n\\n\\n  return funcs.map(\\n  (func) =>\\n  func && (\\n  (...args) => {\\n    hiddenPriorError = sendingError;\\n    hiddenCurrentTurn += 1;\\n    hiddenCurrentEvent = 0;\\n    try {\\n      let result;\\n      try {\\n        result = func(...args);}\\n      catch (err) {\\n        if (err instanceof Error) {\\n          assert.note(\\n          err,\\n          X`Thrown from: ${hiddenPriorError}:${hiddenCurrentTurn}.${hiddenCurrentEvent}`);}\\n\\n\\n        if (VERBOSE) {\\n          console.log('THROWN to top of event loop', err);}\\n\\n        throw err;}\\n\\n      /* Must capture this now, not when the catch triggers.*/\\n      const detailsNote = X`Rejection from: ${hiddenPriorError}:${hiddenCurrentTurn}.${hiddenCurrentEvent}`;\\n      Promise.resolve(result).catch((reason) => {\\n        if (reason instanceof Error) {\\n          assert.note(reason, detailsNote);}\\n\\n        if (VERBOSE) {\\n          console.log('REJECTED at top of event loop', reason);}});\\n\\n\\n      return result;} finally\\n    {\\n      hiddenPriorError = undefined;}}));};exports.trackTurns = trackTurns;\",\n  \"packages/marshal/index.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var passStyleOf = require('./src/passStyleOf.js');var marshal = require('./src/marshal.js');var marshalStringify = require('./src/marshal-stringify.js');exports.getErrorConstructor = passStyleOf.getErrorConstructor;exports.getInterfaceOf = passStyleOf.getInterfaceOf;exports.passStyleOf = passStyleOf.passStyleOf;exports.Far = marshal.Far;exports.QCLASS = marshal.QCLASS;exports.Remotable = marshal.Remotable;exports.makeMarshal = marshal.makeMarshal;exports.pureCopy = marshal.pureCopy;exports.parse = marshalStringify.parse;exports.stringify = marshalStringify.stringify;\",\n  \"packages/marshal/src/marshal-stringify.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var assert = require('../../assert/src/assert.js');var marshal = require('./marshal.js');\\n\\n\\n\\n\\n\\n\\nrequire('./types.js'); /* @ts-check*/ /** @type {ConvertValToSlot<any>} */\\nconst doNotConvertValToSlot = (val) =>\\nassert.assert.fail(assert.details`Marshal's stringify rejects presences and promises ${val}`);\\n\\n/** @type {ConvertSlotToVal<any>} */\\nconst doNotConvertSlotToVal = (slot, _iface) =>\\nassert.assert.fail(assert.details`Marshal's parse must not encode any slots ${slot}`);\\n\\nconst badArrayHandler = harden({\\n  get: (_target, name, _receiver) => {\\n    if (name === 'length') {\\n      return 0;}\\n\\n    assert.assert.fail(assert.details`Marshal's parse must not encode any slot positions ${name}`);} });\\n\\n\\n\\nconst badArray = harden(new Proxy(harden([]), badArrayHandler));\\n\\nconst { serialize, unserialize } = marshal.makeMarshal(\\ndoNotConvertValToSlot,\\ndoNotConvertSlotToVal,\\n{ errorTagging: 'off' });\\n\\n\\n/**\\n * @param {OnlyData} val\\n * @returns {string}\\n */\\nconst stringify = (val) => serialize(val).body;\\nharden(stringify);\\n\\n/**\\n * @param {string} str\\n * @returns {OnlyData}\\n */\\nconst parse = (str) =>\\nunserialize(\\nharden({\\n  body: str,\\n  slots: badArray }));\\n\\n\\nharden(parse);exports.parse = parse;exports.stringify = stringify;\",\n  \"packages/marshal/src/marshal.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var nat_esm = require('../../../node_modules/@agoric/nat/dist/nat.esm.js');var assert = require('../../assert/src/assert.js');var passStyleOf = require('./passStyleOf.js');require('./types.js'); /* @ts-check*/\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nconst {\\n  getPrototypeOf,\\n  setPrototypeOf,\\n  create,\\n  getOwnPropertyDescriptors,\\n  defineProperties,\\n  is,\\n  isFrozen,\\n  fromEntries,\\n  prototype: objectPrototype } =\\nObject;\\n\\nconst { ownKeys } = Reflect;\\n\\n/**\\n * Do a deep copy of the object, handling Proxies and recursion.\\n * The resulting copy is guaranteed to be pure data, as well as hardened.\\n * Such a hardened, pure copy cannot be used as a communications path.\\n *\\n * @template {OnlyData} T\\n * @param {T} val input value.  NOTE: Must be hardened!\\n * @param {WeakMap<any,any>} [already=new WeakMap()]\\n * @returns {T} pure, hardened copy\\n */\\nfunction pureCopy(val, already = new WeakMap()) {\\n  /* eslint-disable-next-line no-use-before-define*/\\n  const passStyle = passStyleOf.passStyleOf(val);\\n  switch (passStyle) {\\n    case 'bigint':\\n    case 'boolean':\\n    case 'null':\\n    case 'number':\\n    case 'string':\\n    case 'undefined':\\n    case 'symbol':\\n      return val;\\n\\n    case 'copyArray':\\n    case 'copyRecord':{\\n        const obj = /** @type {Object} */val;\\n        if (already.has(obj)) {\\n          return already.get(obj);}\\n\\n\\n        /* Create a new identity.*/\\n        const copy = /** @type {T} */passStyle === 'copyArray' ? [] : {};\\n\\n        /* Prevent recursion.*/\\n        already.set(obj, copy);\\n\\n        /* Make a deep copy on the new identity.*/\\n        /* Object.entries(obj) takes a snapshot (even if a Proxy).*/\\n        /* Since we already know it is a copyRecord or copyArray, we*/\\n        /* know that Object.entries is safe enough. On a copyRecord it*/\\n        /* will represent all the own properties. On a copyArray it*/\\n        /* will represent all the own properties except for the length.*/\\n        Object.entries(obj).forEach(([prop, value]) => {\\n          copy[prop] = pureCopy(value, already);});\\n\\n        return harden(copy);}\\n\\n\\n    case 'copyError':{\\n        const unk = /** @type {unknown} */val;\\n        const err = /** @type {Error} */unk;\\n\\n        if (already.has(err)) {\\n          return already.get(err);}\\n\\n\\n        const { name, message } = err;\\n\\n        /* eslint-disable-next-line no-use-before-define*/\\n        const EC = passStyleOf.getErrorConstructor(`${name}`) || Error;\\n        const copy = harden(new EC(`${message}`));\\n        already.set(err, copy);\\n\\n        const unk2 = /** @type {unknown} */harden(copy);\\n        return (/** @type {T} */unk2);}\\n\\n\\n    case 'remotable':{\\n        assert.assert.fail(\\n        assert.details`Input value ${assert.quote(\\n        passStyle)\\n        } cannot be copied as it must be passed by reference`,\\n        TypeError);}\\n\\n\\n\\n    case 'promise':{\\n        assert.assert.fail(assert.details`Promises cannot be copied`, TypeError);}\\n\\n\\n    default:\\n      assert.assert.fail(\\n      assert.details`Input value ${assert.quote(passStyle)} is not recognized as data`,\\n      TypeError);}}\\n\\n\\n\\nharden(pureCopy);\\n\\n\\n/**\\n * @param {Object|null} oldProto\\n * @param {InterfaceSpec} iface\\n * @returns {Object}\\n */\\nconst makeRemotableProto = (oldProto, iface) => {\\n  assert.assert(\\n  oldProto === objectPrototype || oldProto === null,\\n  assert.details`For now, remotables cannot inherit from anything unusual`);\\n\\n  /* Assign the arrow function to a variable to set its .name.*/\\n  const toString = () => `[${iface}]`;\\n  return harden(\\n  create(oldProto, {\\n    [passStyleOf.PASS_STYLE]: { value: 'remotable' },\\n    toString: { value: toString },\\n    [Symbol.toStringTag]: { value: iface } }));};\\n\\n\\n\\n\\n/**\\n * Special property name that indicates an encoding that needs special\\n * decoding.\\n */\\nconst QCLASS = '@qclass';\\n\\n\\n/**\\n * @template Slot\\n * @type {ConvertValToSlot<Slot>}\\n */\\nconst defaultValToSlotFn = (x) => x;\\n/**\\n * @template Slot\\n * @type {ConvertSlotToVal<Slot>}\\n */\\nconst defaultSlotToValFn = (x, _) => x;\\n\\n/**\\n * @template Slot\\n * @type {MakeMarshal<Slot>}\\n */\\nfunction makeMarshal(\\nconvertValToSlot = defaultValToSlotFn,\\nconvertSlotToVal = defaultSlotToValFn,\\n{\\n  errorTagging = 'on',\\n  marshalName = 'anon-marshal',\\n  /* TODO Temporary hack.*/\\n  /* See https://github.com/Agoric/agoric-sdk/issues/2780*/\\n  errorIdNum = 10000,\\n  /* We prefer that the caller instead log to somewhere hidden*/\\n  /* to be revealed when correlating with the received error.*/\\n  marshalSaveError = (err) =>\\n  console.log('Temporary logging of sent error', err) } =\\n{})\\n{\\n  assert.assert.typeof(marshalName, 'string');\\n  assert.assert(\\n  errorTagging === 'on' || errorTagging === 'off',\\n  assert.details`The errorTagging option can only be \\\"on\\\" or \\\"off\\\" ${errorTagging}`);\\n\\n  const nextErrorId = () => {\\n    errorIdNum += 1;\\n    return `error:${marshalName}#${errorIdNum}`;};\\n\\n\\n  /**\\n   * @template Slot\\n   * @type {Serialize<Slot>}\\n   */\\n  const serialize = (root) => {\\n    const slots = [];\\n    /* maps val (promise or remotable) to index of slots[]*/\\n    const slotMap = new Map();\\n    /* for cycle detection*/\\n    const unfinished = new WeakSet();\\n\\n    /**\\n     * @param {Passable} val\\n     * @param {InterfaceSpec=} iface\\n     * @returns {Encoding}\\n     */\\n    function serializeSlot(val, iface = undefined) {\\n      let slotIndex;\\n      if (slotMap.has(val)) {\\n        slotIndex = slotMap.get(val);\\n        assert.assert.typeof(slotIndex, 'number');\\n        iface = undefined;} else\\n      {\\n        const slot = convertValToSlot(val);\\n\\n        slotIndex = slots.length;\\n        slots.push(slot);\\n        slotMap.set(val, slotIndex);\\n\\n        /* if (iface === undefined && passStyleOf(val) === 'remotable') {\\n         // iface = `Alleged: remotable at slot ${slotIndex}`;\\n         if (\\n         getPrototypeOf(val) === objectPrototype &&\\n         ownKeys(val).length === 0\\n         ) {\\n         // For now, skip the diagnostic if we have a pure empty object\\n         } else {\\n         try {\\n         assert.fail(X`Serialize ${val} generates needs iface`);\\n         } catch (err) {\\n         console.info(err);\\n         }\\n         }\\n         }\\n         */}\\n\\n\\n\\n      if (iface === undefined) {\\n        return harden({\\n          [QCLASS]: 'slot',\\n          index: slotIndex });}\\n\\n\\n      return harden({\\n        [QCLASS]: 'slot',\\n        iface,\\n        index: slotIndex });}\\n\\n\\n\\n    /**\\n     * Must encode `val` into plain JSON data *canonically*, such that\\n     * `sameStructure(v1, v2)` implies\\n     * `JSON.stringify(encode(v1)) === JSON.stringify(encode(v2))`\\n     * For each record, we only accept sortable property names\\n     * (no anonymous symbols). On the encoded form the sort\\n     * order of these names must be the same as their enumeration\\n     * order, so a `JSON.stringify` of the encoded form agrees with\\n     * a canonical-json stringify of the encoded form.\\n     *\\n     * @param {Passable} val\\n     * @returns {Encoding}\\n     */\\n    const encode = (val) => {\\n      /* First we handle all primitives. Some can be represented directly as*/\\n      /* JSON, and some must be encoded as [QCLASS] composites.*/\\n      const passStyle = passStyleOf.passStyleOf(val);\\n      switch (passStyle) {\\n        case 'null':{\\n            return null;}\\n\\n        case 'undefined':{\\n            return harden({ [QCLASS]: 'undefined' });}\\n\\n        case 'string':\\n        case 'boolean':{\\n            return val;}\\n\\n        case 'number':{\\n            if (Number.isNaN(val)) {\\n              return harden({ [QCLASS]: 'NaN' });}\\n\\n            if (is(val, -0)) {\\n              return 0;}\\n\\n            if (val === Infinity) {\\n              return harden({ [QCLASS]: 'Infinity' });}\\n\\n            if (val === -Infinity) {\\n              return harden({ [QCLASS]: '-Infinity' });}\\n\\n            return val;}\\n\\n        case 'bigint':{\\n            return harden({\\n              [QCLASS]: 'bigint',\\n              digits: String(val) });}\\n\\n\\n        case 'symbol':{\\n            switch (val) {\\n              case Symbol.asyncIterator:{\\n                  return harden({\\n                    [QCLASS]: '@@asyncIterator' });}\\n\\n\\n              default:{\\n                  assert.assert.fail(assert.details`Unsupported symbol ${assert.quote(String(val))}`);}}}\\n\\n\\n\\n        default:{\\n            assert.assert(\\n            !unfinished.has(val),\\n            assert.details`Pass-by-copy data must be acyclic ${val}`);\\n\\n\\n            switch (passStyle) {\\n              case 'copyRecord':{\\n                  if (QCLASS in val) {\\n                    /* Hilbert hotel*/\\n                    const { [QCLASS]: qclassValue, ...rest } = val;\\n                    if (ownKeys(rest).length === 0) {\\n                      unfinished.add(val);\\n                      /** @type {Encoding} */\\n                      const result = harden({\\n                        [QCLASS]: 'hilbert',\\n                        original: encode(qclassValue) });\\n\\n                      unfinished.delete(val);\\n                      return result;} else\\n                    {\\n                      unfinished.add(val);\\n                      /** @type {Encoding} */\\n                      const result = harden({\\n                        [QCLASS]: 'hilbert',\\n                        original: encode(qclassValue),\\n                        rest: encode(harden(rest)) });\\n\\n                      unfinished.delete(val);\\n                      return result;}}\\n\\n\\n                  /* Currently copyRecord allows only string keys so this will*/\\n                  /* work. If we allow sortable symbol keys, this will need to*/\\n                  /* become more interesting.*/\\n                  const names = ownKeys(val).sort();\\n                  unfinished.add(val);\\n                  const result = fromEntries(\\n                  names.map((name) => [name, encode(val[name])]));\\n\\n                  unfinished.delete(val);\\n                  return result;}\\n\\n              case 'copyArray':{\\n                  unfinished.add(val);\\n                  const result = val.map(encode);\\n                  unfinished.delete(val);\\n                  return result;}\\n\\n              case 'copyError':{\\n                  if (errorTagging === 'on') {\\n                    /* We deliberately do not share the stack, but it would*/\\n                    /* be useful to log the stack locally so someone who has*/\\n                    /* privileged access to the throwing Vat can correlate*/\\n                    /* the problem with the remote Vat that gets this*/\\n                    /* summary. If we do that, we could allocate some random*/\\n                    /* identifier and include it in the message, to help*/\\n                    /* with the correlation.*/\\n                    const errorId = nextErrorId();\\n                    assert.assert.note(val, assert.details`Sent as ${errorId}`);\\n                    marshalSaveError(val);\\n                    return harden({\\n                      [QCLASS]: 'error',\\n                      errorId,\\n                      message: `${val.message}`,\\n                      name: `${val.name}` });} else\\n\\n                  {\\n                    return harden({\\n                      [QCLASS]: 'error',\\n                      message: `${val.message}`,\\n                      name: `${val.name}` });}}\\n\\n\\n\\n              case 'remotable':{\\n                  const iface = passStyleOf.getInterfaceOf(val);\\n                  /* console.log(`serializeSlot: ${val}`);*/\\n                  return serializeSlot(val, iface);}\\n\\n              case 'promise':{\\n                  /* console.log(`serializeSlot: ${val}`);*/\\n                  return serializeSlot(val);}\\n\\n              default:{\\n                  assert.assert.fail(assert.details`unrecognized passStyle ${assert.quote(passStyle)}`, TypeError);}}}}};\\n\\n\\n\\n\\n\\n\\n    const encoded = encode(root);\\n\\n    return harden({\\n      body: JSON.stringify(encoded),\\n      slots });};\\n\\n\\n\\n  const makeFullRevive = (slots) => {\\n    /** @type {Map<number, Passable>} */\\n    const valMap = new Map();\\n\\n    function unserializeSlot(index, iface) {\\n      if (valMap.has(index)) {\\n        return valMap.get(index);}\\n\\n      const slot = slots[Number(nat_esm.Nat(index))];\\n      const val = convertSlotToVal(slot, iface);\\n      valMap.set(index, val);\\n      return val;}\\n\\n\\n    /**\\n     * We stay close to the algorithm at\\n     * https://tc39.github.io/ecma262/#sec-json.parse , where\\n     * fullRevive(harden(JSON.parse(str))) is like JSON.parse(str, revive))\\n     * for a similar reviver. But with the following differences:\\n     *\\n     * Rather than pass a reviver to JSON.parse, we first call a plain\\n     * (one argument) JSON.parse to get rawTree, and then post-process\\n     * the rawTree with fullRevive. The kind of revive function\\n     * handled by JSON.parse only does one step in post-order, with\\n     * JSON.parse doing the recursion. By contrast, fullParse does its\\n     * own recursion in the same pre-order in which the replacer visited them.\\n     *\\n     * In order to break cycles, the potentially cyclic objects are\\n     * not frozen during the recursion. Rather, the whole graph is\\n     * hardened before being returned. Error objects are not\\n     * potentially recursive, and so may be harmlessly hardened when\\n     * they are produced.\\n     *\\n     * fullRevive can produce properties whose value is undefined,\\n     * which a JSON.parse on a reviver cannot do. If a reviver returns\\n     * undefined to JSON.parse, JSON.parse will delete the property\\n     * instead.\\n     *\\n     * fullRevive creates and returns a new graph, rather than\\n     * modifying the original tree in place.\\n     *\\n     * fullRevive may rely on rawTree being the result of a plain call\\n     * to JSON.parse. However, it *cannot* rely on it having been\\n     * produced by JSON.stringify on the replacer above, i.e., it\\n     * cannot rely on it being a valid marshalled\\n     * representation. Rather, fullRevive must validate that.\\n     *\\n     * @param {Encoding} rawTree must be hardened\\n     */\\n    function fullRevive(rawTree) {\\n      if (Object(rawTree) !== rawTree) {\\n        /* primitives pass through*/\\n        return rawTree;}\\n\\n      /* Assertions of the above to narrow the type.*/\\n      assert.assert.typeof(rawTree, 'object');\\n      assert.assert(rawTree !== null);\\n      if (QCLASS in rawTree) {\\n        const qclass = rawTree[QCLASS];\\n        assert.assert.typeof(\\n        qclass,\\n        'string',\\n        assert.details`invalid qclass typeof ${assert.quote(typeof qclass)}`);\\n\\n        assert.assert(!Array.isArray(rawTree));\\n        /* Switching on `encoded[QCLASS]` (or anything less direct, like*/\\n        /* `qclass`) does not discriminate rawTree in typescript@4.2.3 and*/\\n        /* earlier.*/\\n        switch (rawTree['@qclass']) {\\n          /* Encoding of primitives not handled by JSON*/\\n          case 'undefined':{\\n              return undefined;}\\n\\n          case 'NaN':{\\n              return NaN;}\\n\\n          case 'Infinity':{\\n              return Infinity;}\\n\\n          case '-Infinity':{\\n              return -Infinity;}\\n\\n          case 'bigint':{\\n              const { digits } = rawTree;\\n              assert.assert.typeof(\\n              digits,\\n              'string',\\n              assert.details`invalid digits typeof ${assert.quote(typeof digits)}`);\\n\\n              return BigInt(digits);}\\n\\n          case '@@asyncIterator':{\\n              return Symbol.asyncIterator;}\\n\\n\\n          case 'error':{\\n              const { name, message, errorId } = rawTree;\\n              assert.assert.typeof(\\n              name,\\n              'string',\\n              assert.details`invalid error name typeof ${assert.quote(typeof name)}`);\\n\\n              assert.assert.typeof(\\n              message,\\n              'string',\\n              assert.details`invalid error message typeof ${assert.quote(typeof message)}`);\\n\\n              const EC = passStyleOf.getErrorConstructor(`${name}`) || Error;\\n              /* errorId is a late addition so be tolerant of its absence.*/\\n              const errorName =\\n              errorId === undefined ?\\n              `Remote${EC.name}` :\\n              `Remote${EC.name}(${errorId})`;\\n              const error = assert.assert.error(`${message}`, EC, { errorName });\\n              return error;}\\n\\n\\n          case 'slot':{\\n              const { index, iface } = rawTree;\\n              const val = unserializeSlot(index, iface);\\n              return val;}\\n\\n\\n          case 'hilbert':{\\n              const { original, rest } = rawTree;\\n              assert.assert(\\n              'original' in rawTree,\\n              assert.details`Invalid Hilbert Hotel encoding ${rawTree}`);\\n\\n              /* Don't harden since we're not done mutating it*/\\n              const result = { [QCLASS]: fullRevive(original) };\\n              if ('rest' in rawTree) {\\n                assert.assert(\\n                rest !== undefined,\\n                assert.details`Rest encoding must not be undefined`);\\n\\n                const restObj = fullRevive(rest);\\n                /* TODO really should assert that `passStyleOf(rest)` is*/\\n                /* `'copyRecord'` but we'd have to harden it and it is too*/\\n                /* early to do that.*/\\n                assert.assert(\\n                !(QCLASS in restObj),\\n                assert.details`Rest must not contain its own definition of ${assert.quote(QCLASS)}`);\\n\\n                defineProperties(result, getOwnPropertyDescriptors(restObj));}\\n\\n              return result;}\\n\\n\\n          default:{\\n              assert.assert(\\n              qclass !== 'ibid',\\n              assert.details`The protocol no longer supports ibid encoding: ${rawTree}.`);\\n\\n              assert.assert.fail(assert.details`unrecognized ${assert.quote(QCLASS)} ${assert.quote(qclass)}`, TypeError);}}} else\\n\\n\\n      if (Array.isArray(rawTree)) {\\n        const result = [];\\n        const { length } = rawTree;\\n        for (let i = 0; i < length; i += 1) {\\n          result[i] = fullRevive(rawTree[i]);}\\n\\n        return result;} else\\n      {\\n        const result = {};\\n        for (const name of ownKeys(rawTree)) {\\n          assert.assert.typeof(\\n          name,\\n          'string',\\n          assert.details`Property ${name} of ${rawTree} must be a string`);\\n\\n          result[name] = fullRevive(rawTree[name]);}\\n\\n        return result;}}\\n\\n\\n    return fullRevive;};\\n\\n\\n  /**\\n   * @template Slot\\n   * @type {Unserialize<Slot>}\\n   */\\n  const unserialize = (data) => {\\n    assert.assert.typeof(\\n    data.body,\\n    'string',\\n    assert.details`unserialize() given non-capdata (.body is ${data.body}, not string)`);\\n\\n    assert.assert(\\n    Array.isArray(data.slots),\\n    assert.details`unserialize() given non-capdata (.slots are not Array)`);\\n\\n    const rawTree = harden(JSON.parse(data.body));\\n    const fullRevive = makeFullRevive(data.slots);\\n    return harden(fullRevive(rawTree));};\\n\\n\\n  return harden({\\n    serialize,\\n    unserialize });}\\n\\n\\n\\n/**\\n * Create and register a Remotable.  After this, getInterfaceOf(remotable)\\n * returns iface.\\n *\\n * // https://github.com/Agoric/agoric-sdk/issues/804\\n *\\n * @param {InterfaceSpec} [iface='Remotable'] The interface specification for\\n * the remotable. For now, a string iface must be \\\"Remotable\\\" or begin with\\n * \\\"Alleged: \\\", to serve as the alleged name. More general ifaces are not yet\\n * implemented. This is temporary. We include the\\n * \\\"Alleged\\\" as a reminder that we do not yet have SwingSet or Comms Vat\\n * support for ensuring this is according to the vat hosting the object.\\n * Currently, Alice can tell Bob about Carol, where VatA (on Alice's behalf)\\n * misrepresents Carol's `iface`. VatB and therefore Bob will then see\\n * Carol's `iface` as misrepresented by VatA.\\n * @param {undefined} [props=undefined] Currently may only be undefined.\\n * That plan is that own-properties are copied to the remotable\\n * @param {object} [remotable={}] The object used as the remotable\\n * @returns {object} remotable, modified for debuggability\\n */\\nfunction Remotable(iface = 'Remotable', props = undefined, remotable = {}) {\\n  passStyleOf.assertIface(iface);\\n  iface = pureCopy(harden(iface));\\n  assert.assert(iface);\\n  /* TODO: When iface is richer than just string, we need to get the allegedName*/\\n  /* in a different way.*/\\n  assert.assert(props === undefined, assert.details`Remotable props not yet implemented ${props}`);\\n\\n  /* Fail fast: check that the unmodified object is able to become a Remotable.*/\\n  passStyleOf.assertCanBeRemotable(remotable);\\n\\n  /* Ensure that the remotable isn't already marked.*/\\n  assert.assert(\\n  !(passStyleOf.PASS_STYLE in remotable),\\n  assert.details`Remotable ${remotable} is already marked as a ${assert.quote(\\n  remotable[passStyleOf.PASS_STYLE])\\n  }`);\\n\\n  /* Ensure that the remotable isn't already frozen.*/\\n  assert.assert(!isFrozen(remotable), assert.details`Remotable ${remotable} is already frozen`);\\n  const remotableProto = makeRemotableProto(getPrototypeOf(remotable), iface);\\n\\n  /* Take a static copy of the enumerable own properties as data properties.*/\\n  /* const propDescs = getOwnPropertyDescriptors({ ...props });*/\\n  const mutateHardenAndCheck = (target) => {\\n    /* defineProperties(target, propDescs);*/\\n    setPrototypeOf(target, remotableProto);\\n    harden(target);\\n    passStyleOf.assertCanBeRemotable(target);};\\n\\n\\n  /* Fail fast: check a fresh remotable to see if our rules fit.*/\\n  mutateHardenAndCheck({});\\n\\n  /* Actually finish the new remotable.*/\\n  mutateHardenAndCheck(remotable);\\n\\n  /* COMMITTED!*/\\n  /* We're committed, so keep the interface for future reference.*/\\n  assert.assert(iface !== undefined); /* To make TypeScript happy*/\\n  return remotable;}\\n\\n\\nharden(Remotable);\\n\\n\\n/**\\n * A concise convenience for the most common `Remotable` use.\\n *\\n * @template T\\n * @param {string} farName This name will be prepended with `Alleged: `\\n * for now to form the `Remotable` `iface` argument.\\n * @param {T|undefined} [remotable={}] The object used as the remotable\\n * @returns {T} remotable, modified for debuggability\\n */\\nconst Far = (farName, remotable = undefined) => {\\n  const r = remotable === undefined ? {} : remotable;\\n  return Remotable(`Alleged: ${farName}`, undefined, r);};\\n\\n\\nharden(Far);exports.Far = Far;exports.QCLASS = QCLASS;exports.Remotable = Remotable;exports.makeMarshal = makeMarshal;exports.pureCopy = pureCopy;\",\n  \"packages/marshal/src/passStyleOf.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var assert = require('../../assert/src/assert.js');var promiseKit = require('../../promise-kit/src/promiseKit.js');require('./types.js');\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nrequire('../../assert/exported.js'); /* @ts-check*/ /* Setting this flag to true is what allows objects with `null` or*/ /* `Object.prototype` prototypes to be treated as remotable.  Setting to `false`*/ /* means that only objects declared with `Remotable(...)`, including `Far(...)`*/ /* can be used as remotables.*/ /**/ /* TODO: once the policy changes to force remotables to be explicit, remove this*/ /* flag entirely and fix code that uses it (as if it were always `false`).*/\\nconst ALLOW_IMPLICIT_REMOTABLES = true;\\n\\nconst {\\n  getPrototypeOf,\\n  getOwnPropertyDescriptors,\\n  isFrozen,\\n  prototype: objectPrototype } =\\nObject;\\n\\nconst { ownKeys } = Reflect;\\n\\nconst PASS_STYLE = Symbol.for('passStyle');\\n\\nconst errorConstructors = new Map([\\n['Error', Error],\\n['EvalError', EvalError],\\n['RangeError', RangeError],\\n['ReferenceError', ReferenceError],\\n['SyntaxError', SyntaxError],\\n['TypeError', TypeError],\\n['URIError', URIError]]);\\n\\n\\nfunction getErrorConstructor(name) {\\n  return errorConstructors.get(name);}\\n\\n\\n/**\\n * For most of these classification tests, we do strict validity `assert`s,\\n * throwing if we detect something invalid. For errors, we need to remember\\n * the error itself exists to help us diagnose a bug that's likely more\\n * pressing than a validity bug in the error itself. Thus, whenever it is safe\\n * to do so, we prefer to let the error test succeed and to couch these\\n * complaints as notes on the error.\\n *\\n * @param {Passable} val\\n * @returns {boolean}\\n */\\nfunction isPassByCopyError(val) {\\n  /* TODO: Need a better test than instanceof*/\\n  if (!(val instanceof Error)) {\\n    return false;}\\n\\n  const proto = getPrototypeOf(val);\\n  const { name } = val;\\n  const EC = getErrorConstructor(name);\\n  if (!EC || EC.prototype !== proto) {\\n    assert.assert.note(\\n    val,\\n    assert.details`Errors must inherit from an error class .prototype ${val}`);}\\n\\n\\n\\n  const {\\n    message: mDesc,\\n    /* Allow but ignore only extraneous own `stack` property.*/\\n    stack: _optStackDesc,\\n    ...restDescs } =\\n  getOwnPropertyDescriptors(val);\\n  if (ownKeys(restDescs).length >= 1) {\\n    assert.assert.note(\\n    val,\\n    assert.details`Passed Error has extra unpassed properties ${restDescs}`);}\\n\\n\\n  if (mDesc) {\\n    if (typeof mDesc.value !== 'string') {\\n      assert.assert.note(\\n      val,\\n      assert.details`Passed Error \\\"message\\\" ${mDesc} must be a string-valued data property.`);}\\n\\n\\n    if (mDesc.enumerable) {\\n      assert.assert.note(\\n      val,\\n      assert.details`Passed Error \\\"message\\\" ${mDesc} must not be enumerable`);}}\\n\\n\\n\\n  return true;}\\n\\n\\n/**\\n * @param {Passable} val\\n * @returns {boolean}\\n */\\nfunction isPassByCopyArray(val) {\\n  if (!Array.isArray(val)) {\\n    return false;}\\n\\n  assert.assert(\\n  getPrototypeOf(val) === Array.prototype,\\n  assert.details`Malformed array: ${val}`,\\n  TypeError);\\n\\n  const len = val.length;\\n  const descs = getOwnPropertyDescriptors(val);\\n  for (let i = 0; i < len; i += 1) {\\n    const desc = descs[i];\\n    assert.assert(desc, assert.details`Arrays must not contain holes: ${assert.quote(i)}`, TypeError);\\n    assert.assert(\\n    'value' in desc,\\n    assert.details`Arrays must not contain accessors: ${assert.quote(i)}`,\\n    TypeError);\\n\\n    assert.assert(\\n    typeof desc.value !== 'function',\\n    assert.details`Arrays must not contain methods: ${assert.quote(i)}`,\\n    TypeError);\\n\\n    assert.assert(\\n    desc.enumerable,\\n    assert.details`Array elements must be enumerable: ${assert.quote(i)}`,\\n    TypeError);}\\n\\n\\n  assert.assert(\\n  ownKeys(descs).length === len + 1,\\n  assert.details`Arrays must not have non-indexes: ${val}`,\\n  TypeError);\\n\\n  return true;}\\n\\n\\n/**\\n * @param {Passable} val\\n * @returns {boolean}\\n */\\nfunction isPassByCopyRecord(val) {\\n  const proto = getPrototypeOf(val);\\n  if (proto !== objectPrototype) {\\n    return false;}\\n\\n  const descs = getOwnPropertyDescriptors(val);\\n  const descKeys = ownKeys(descs);\\n\\n  for (const descKey of descKeys) {\\n    if (typeof descKey === 'symbol') {\\n      return false;}\\n\\n    const desc = descs[descKey];\\n    if (typeof desc.value === 'function') {\\n      return false;}}\\n\\n\\n  for (const descKey of descKeys) {\\n    assert.assert.typeof(\\n    descKey,\\n    'string',\\n    assert.details`Pass by copy records can only have string-named own properties`);\\n\\n    const desc = descs[descKey];\\n    assert.assert(\\n    !('get' in desc),\\n    assert.details`Records must not contain accessors: ${assert.quote(descKey)}`,\\n    TypeError);\\n\\n    assert.assert(\\n    desc.enumerable,\\n    assert.details`Record fields must be enumerable: ${assert.quote(descKey)}`,\\n    TypeError);}\\n\\n\\n  return true;}\\n\\n\\n/* Below we have a series of predicate functions and their (curried) assertion*/\\n/* functions. The semantics of the assertion function is just to assert that*/\\n/* the corresponding predicate function would have returned true. But it*/\\n/* reproduces the internal tests so failures can give a better error message.*/\\n\\n/**\\n * @callback Checker\\n * @param {boolean} cond\\n * @param {Details=} details\\n * @returns {boolean}\\n */\\n\\n/** @type {Checker} */\\nconst assertChecker = (cond, details) => {\\n  assert.assert(cond, details);\\n  return true;};\\n\\n\\n/**\\n * @param {InterfaceSpec} iface\\n * @param {Checker} check\\n */\\nconst checkIface = (iface, check = (x) => x) => {\\n  return (\\n    /* TODO other possible ifaces, once we have third party veracity*/\\n    check(\\n    typeof iface === 'string',\\n    assert.details`Interface ${iface} must be a string; unimplemented`) &&\\n\\n    check(\\n    iface === 'Remotable' || iface.startsWith('Alleged: '),\\n    assert.details`For now, iface ${assert.quote(\\n    iface)\\n    } must be \\\"Remotable\\\" or begin with \\\"Alleged: \\\"; unimplemented`));};\\n\\n\\n\\n\\n/**\\n * @param {InterfaceSpec} iface\\n */\\nconst assertIface = (iface) => checkIface(iface, assertChecker);\\nharden(assertIface);\\n\\n\\n/**\\n * TODO: It would be nice to typedef this shape, but we can't declare a type\\n * with PASS_STYLE from JSDoc.\\n *\\n * @param {{\\n *   [PASS_STYLE]: string,\\n *   [Symbol.toStringTag]: string,\\n *   toString: () => void }} val the value to verify\\n * @param {Checker} [check]\\n * @returns {boolean}\\n */\\nconst checkRemotableProto = (val, check = (x) => x) => {\\n  if (\\n  !(\\n  check(\\n  typeof val === 'object',\\n  assert.details`cannot serialize non-objects like ${val}`) &&\\n\\n  check(!Array.isArray(val), assert.details`Arrays cannot be pass-by-remote`) &&\\n  check(val !== null, assert.details`null cannot be pass-by-remote`)))\\n\\n  {\\n    return false;}\\n\\n\\n  const protoProto = getPrototypeOf(val);\\n  if (\\n  !(\\n  check(\\n  protoProto === objectPrototype || protoProto === null,\\n  assert.details`The Remotable Proto marker cannot inherit from anything unusual`) &&\\n  check(isFrozen(val), assert.details`The Remotable proto must be frozen`)))\\n\\n  {\\n    return false;}\\n\\n\\n  const {\\n    [PASS_STYLE]: passStyleDesc,\\n    toString: toStringDesc,\\n    /* @ts-ignore https://github.com/microsoft/TypeScript/issues/1863*/\\n    [Symbol.toStringTag]: ifaceDesc,\\n    ...rest } =\\n  getOwnPropertyDescriptors(val);\\n\\n  return (\\n    check(\\n    ownKeys(rest).length === 0,\\n    assert.details`Unexpected properties on Remotable Proto ${ownKeys(rest)}`) &&\\n\\n    check(!!passStyleDesc, assert.details`Remotable must have a [PASS_STYLE]`) &&\\n    check(\\n    passStyleDesc.value === 'remotable',\\n    assert.details`Expected 'remotable', not ${assert.quote(passStyleDesc.value)}`) &&\\n\\n    check(\\n    typeof toStringDesc.value === 'function',\\n    assert.details`toString must be a function`) &&\\n\\n    checkIface(ifaceDesc && ifaceDesc.value, check));};\\n\\n\\n\\n/**\\n * Ensure that val could become a legitimate remotable.  This is used internally\\n * both in the construction of a new remotable and checkRemotable.\\n *\\n * @param {*} val The remotable candidate to check\\n * @param {Checker} [check]\\n * @returns {boolean}\\n */\\nfunction checkCanBeRemotable(val, check = (x) => x) {\\n  if (\\n  !(\\n  check(\\n  typeof val === 'object',\\n  assert.details`cannot serialize non-objects like ${val}`) &&\\n\\n  check(!Array.isArray(val), assert.details`Arrays cannot be pass-by-remote`) &&\\n  check(val !== null, assert.details`null cannot be pass-by-remote`)))\\n\\n  {\\n    return false;}\\n\\n\\n  const descs = getOwnPropertyDescriptors(val);\\n  const keys = ownKeys(descs); /* enumerable-and-not, string-or-Symbol*/\\n  return keys.every(\\n  (key) =>\\n  /* Typecast needed due to https://github.com/microsoft/TypeScript/issues/1863*/\\n  check(\\n  !('get' in descs[/** @type {string} */key]),\\n  assert.details`cannot serialize objects with getters like ${assert.quote(\\n  String(key))\\n  } in ${val}`) &&\\n\\n  check(\\n  typeof val[key] === 'function',\\n  assert.details`cannot serialize objects with non-methods like ${assert.quote(\\n  String(key))\\n  } in ${val}`) &&\\n\\n  check(\\n  key !== PASS_STYLE,\\n  assert.details`A pass-by-remote cannot shadow ${assert.quote(PASS_STYLE)}`));}\\n\\n\\n\\n\\nconst canBeRemotable = (val) => checkCanBeRemotable(val);\\nharden(canBeRemotable);\\n\\n\\nconst assertCanBeRemotable = (val) => {\\n  checkCanBeRemotable(val, assertChecker);};\\n\\nharden(assertCanBeRemotable);\\n\\n\\n/**\\n * @param {Remotable} val\\n * @param {Checker} [check]\\n * @returns {boolean}\\n */\\nfunction checkRemotable(val, check = (x) => x) {\\n  const not = (cond, details) => !check(cond, details);\\n  if (not(isFrozen(val), assert.details`cannot serialize non-frozen objects like ${val}`)) {\\n    return false;}\\n\\n  if (!checkCanBeRemotable(val, check)) {\\n    return false;}\\n\\n  const p = getPrototypeOf(val);\\n\\n  if (ALLOW_IMPLICIT_REMOTABLES && (p === null || p === objectPrototype)) {\\n    return true;}\\n\\n  return checkRemotableProto(p, check);}\\n\\n\\n/**\\n * @param {Remotable} val\\n */\\nconst assertRemotable = (val) => {\\n  checkRemotable(val, assertChecker);};\\n\\n\\n/** @type {MarshalGetInterfaceOf} */\\nconst getInterfaceOf = (val) => {\\n  if (\\n  typeof val !== 'object' ||\\n  val === null ||\\n  val[PASS_STYLE] !== 'remotable' ||\\n  !checkRemotable(val))\\n  {\\n    return undefined;}\\n\\n  return val[Symbol.toStringTag];};\\n\\nharden(getInterfaceOf);\\n\\n\\n/**\\n * objects can only be passed in one of two/three forms:\\n * 1: pass-by-remote: all properties (own and inherited) are methods,\\n *    the object itself is of type object, not function\\n * 2: pass-by-copy: all string-named own properties are data, not methods\\n *    the object must inherit from objectPrototype or null\\n * 3: the empty object is pass-by-remote, for identity comparison\\n *\\n * all objects must be frozen\\n *\\n * anything else will throw an error if you try to serialize it\\n * with these restrictions, our remote call/copy protocols expose all useful\\n * behavior of these objects: pass-by-remote objects have no other data (so\\n * there's nothing else to copy), and pass-by-copy objects have no other\\n * behavior (so there's nothing else to invoke)\\n *\\n * How would val be passed?  For primitive values, the answer is\\n *   * 'null' for null\\n *   * throwing an error for a symbol, whether registered or not.\\n *   * that value's typeof string for all other primitive values\\n * For frozen objects, the possible answers\\n *   * 'copyRecord' for non-empty records with only data properties\\n *   * 'copyArray' for arrays with only data properties\\n *   * 'copyError' for instances of Error with only data properties\\n *   * 'remotable' for non-array objects with only method properties\\n *   * 'promise' for genuine promises only\\n *   * throwing an error on anything else, including thenables.\\n * We export passStyleOf so other algorithms can use this module's\\n * classification.\\n *\\n * @param {Passable} val\\n * @returns {PassStyle}\\n */\\nfunction passStyleOf(val) {\\n  const typestr = typeof val;\\n  switch (typestr) {\\n    case 'object':{\\n        if (getInterfaceOf(val)) {\\n          return 'remotable';}\\n\\n        if (val === null) {\\n          return 'null';}\\n\\n        assert.assert(\\n        isFrozen(val),\\n        assert.details`Cannot pass non-frozen objects like ${val}. Use harden()`);\\n\\n        if (promiseKit.isPromise(val)) {\\n          return 'promise';}\\n\\n        assert.assert(\\n        typeof val.then !== 'function',\\n        assert.details`Cannot pass non-promise thenables`);\\n\\n        if (isPassByCopyError(val)) {\\n          return 'copyError';}\\n\\n        if (isPassByCopyArray(val)) {\\n          return 'copyArray';}\\n\\n        if (isPassByCopyRecord(val)) {\\n          return 'copyRecord';}\\n\\n        assertRemotable(val);\\n        /* console.log(`--- @@marshal: pass-by-ref object without Far/Remotable`);*/\\n        /* assert.fail(X`pass-by-ref object without Far/Remotable`);*/\\n        return 'remotable';}\\n\\n    case 'function':{\\n        assert.assert.fail(assert.details`Bare functions like ${val} are disabled for now`);}\\n\\n    case 'undefined':\\n    case 'string':\\n    case 'boolean':\\n    case 'number':\\n    case 'bigint':\\n    case 'symbol':{\\n        return typestr;}\\n\\n    default:{\\n        assert.assert.fail(assert.details`Unrecognized typeof ${assert.quote(typestr)}`, TypeError);}}}exports.PASS_STYLE = PASS_STYLE;exports.assertCanBeRemotable = assertCanBeRemotable;exports.assertIface = assertIface;exports.canBeRemotable = canBeRemotable;exports.getErrorConstructor = getErrorConstructor;exports.getInterfaceOf = getInterfaceOf;exports.passStyleOf = passStyleOf;\",\n  \"packages/marshal/src/types.js\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n'use strict'; /* eslint-disable-next-line spaced-comment*/ /*/ <reference path=\\\"extra-types.d.ts\\\" />*/ /**\\n * @typedef { \\\"bigint\\\" | \\\"boolean\\\" | \\\"null\\\" | \\\"number\\\" | \\\"string\\\" | \\\"symbol\\\" | \\\"undefined\\\" | \\\"copyArray\\\" | \\\"copyRecord\\\" | \\\"copyError\\\" | \\\"promise\\\" | \\\"remotable\\\" } PassStyle\\n */ /* TODO declare more precise types throughout this file, so the type system*/ /* and IDE can be more helpful.*/ /**\\n * @typedef {*} Passable\\n *\\n * A Passable value that may be marshalled. It is classified as one of\\n * PassStyle. A Passable must be hardened.\\n *\\n * A Passable has a pass-by-copy superstructure. This includes the atomic\\n * pass-by-copy primitives (\\\"bigint\\\" | \\\"boolean\\\" | \\\"null\\\" | \\\"number\\\" |\\n * \\\"string\\\" | \\\"undefined\\\") and the composite pass-by-copy objects (\\\"copyArray\\\" |\\n * \\\"copyRecord\\\" | \\\"copyError\\\"). The composite pass-by-copy objects that may\\n * contain other Passables.\\n *\\n * A Passable's pass-by-copy superstructure ends in PassableCap leaves. The\\n * Passable can be further classified by the nature of these leaves. Since a\\n * Passable is hardened, its structure and classification is stable --- its\\n * structure and classification cannot change even if some of the objects are\\n * proxies.\\n */ /**\\n * @typedef {Passable} Comparable\\n *\\n * A Comparable is a Passable in which none of the leaves of the pass-by-copy\\n * superstructure are promises. Two Comparables may be compared by\\n * for equivalence according to `sameStructure`, which is the strongest\\n * equivalence class supported by marshal's distributed object semantics.\\n */ /**\\n * @typedef {Comparable} OnlyData\\n *\\n * A Comparable is OnlyData when its pass-by-copy superstructure has no leaves,\\n * i.e., when all the leaves of the data structure tree are primitive data\\n * types or empty composites.\\n */ /**\\n * @typedef {OnlyData} PureData\\n *\\n * An OnlyData value is PureData when it contains no hidden mutable state,\\n * e.g., when none of its pass-by-copy composite data objects are proxies. This\\n * cannot be determined by inspection. It can only be achieved by trusted\\n * construction. A PureData value cannot be used as a communications channel,\\n * and can therefore be safely shared with subgraphs that should not be able\\n * to communicate with each other.\\n */ /**\\n * @typedef {*} Remotable\\n * Might be an object explicitly deemed to be `Remotable`, an object inferred\\n * to be Remotable, or a remote presence of a Remotable.\\n */ /**\\n * @typedef {Promise | Remotable} PassableCap\\n * The leaves of a Passable's pass-by-copy superstructure.\\n */ /* /////////////////////////////////////////////////////////////////////////////*/ /**\\n * @template Slot\\n * @callback ConvertValToSlot\\n * @param {PassableCap} val\\n * @returns {Slot}\\n */ /**\\n * @template Slot\\n * @callback ConvertSlotToVal\\n * @param {Slot} slot\\n * @param {InterfaceSpec=} iface\\n * @returns {PassableCap}\\n */ /**\\n * @template T\\n * @typedef {{ '@qclass': T }} EncodingClass\\n */ /**\\n * @typedef {EncodingClass<'NaN'> |\\n * EncodingClass<'undefined'> |\\n * EncodingClass<'Infinity'> |\\n * EncodingClass<'-Infinity'> |\\n * EncodingClass<'bigint'> & { digits: string } |\\n * EncodingClass<'@@asyncIterator'> |\\n * EncodingClass<'error'> & { name: string, message: string, errorId?: string } |\\n * EncodingClass<'slot'> & { index: number, iface?: InterfaceSpec } |\\n * EncodingClass<'hilbert'> & { original: Encoding, rest?: Encoding }} EncodingUnion\\n * @typedef {{ [index: string]: Encoding, '@qclass'?: undefined }} EncodingRecord\\n * We exclude '@qclass' as a property in encoding records.\\n * @typedef {EncodingUnion | null | string | boolean | number | EncodingRecord} EncodingElement\\n */ /**\\n * @typedef {EncodingElement | NestedArray<EncodingElement>} Encoding\\n * The JSON structure that the data portion of a Passable serializes to.\\n *\\n * The QCLASS 'hilbert' is a reference to the Hilbert Hotel\\n * of https://www.ias.edu/ideas/2016/pires-hilbert-hotel\\n * If QCLASS appears as a property name in the data, we encode it instead\\n * as a QCLASS record of type 'hilbert'. To do so, we must move the other\\n * parts of the record into fields of the hilbert record.\\n */ /**\\n * @template Slot\\n * @typedef CapData\\n * @property {string} body A JSON.stringify of an Encoding\\n * @property {Slot[]} slots\\n */ /**\\n * @template Slot\\n * @callback Serialize\\n * @param {Passable} val\\n * @returns {CapData<Slot>}\\n */ /**\\n * @template Slot\\n * @callback Unserialize\\n * @param {CapData<Slot>} data\\n * @returns {Passable}\\n */ /**\\n * @template Slot\\n * @typedef Marshal\\n * @property {Serialize<Slot>} serialize\\n * @property {Unserialize<Slot>} unserialize\\n */ /**\\n * @template Slot\\n * @callback MakeMarshal\\n * @param {ConvertValToSlot=} convertValToSlot\\n * @param {ConvertSlotToVal=} convertSlotToVal\\n * @param {MakeMarshalOptions=} options\\n * @returns {Marshal}\\n */ /**\\n * @typedef MakeMarshalOptions\\n * @property {'on'|'off'=} errorTagging controls whether serialized errors\\n * also carry tagging information, made from `marshalName` and numbers\\n * generated (currently by counting) starting at `errorIdNum`. The\\n * `errorTagging` option defaults to `'on'`. Serialized\\n * errors are also logged to `marshalSaveError` only if tagging is `'on'`.\\n * @property {string=} marshalName Used to identify sent errors.\\n * @property {number=} errorIdNum Ascending numbers staring from here\\n * identify the sending of errors relative to this marshal instance.\\n * @property {(err: Error) => void=} marshalSaveError If `errorTagging` is\\n * `'on'`, then errors serialized by this marshal instance are also\\n * logged by calling `marshalSaveError` *after* `assert.note` associated\\n * that error with its errorId. Thus, if `marshalSaveError` in turn logs\\n * to the normal console, which is the default, then the console will\\n * show that note showing the associated errorId.\\n */ /* /////////////////////////////////////////////////////////////////////////////*/ /**\\n * @typedef {string} InterfaceSpec\\n * This is an interface specification.\\n * For now, it is just a string, but will eventually be any OnlyData. Either\\n * way, it must remain pure, so that it can be safely shared by subgraphs that\\n * are not supposed to be able to communicate.\\n */ /**\\n * @callback MarshalGetInterfaceOf\\n * Simple semantics, just tell what interface (or undefined) a remotable has.\\n *\\n * @param {*} maybeRemotable the value to check\\n * @returns {InterfaceSpec|undefined} the interface specification, or undefined\\n * if not a deemed to be a Remotable\\n */\",\n  \"packages/notifier/exported.js\": \"'use strict';require('./src/types.js');\",\n  \"packages/notifier/src/asyncIterableAdaptor.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var noShim = require('../../eventual-send/src/no-shim.js');\\n\\n\\n\\n\\n\\n\\n\\nrequire('./types.js'); /* @ts-check*/ /**\\n * Adaptor from a notifierP to an async iterable.\\n * The notifierP can be any object that has an eventually invokable\\n * `getUpdateSince` method that behaves according to the notifier\\n * spec. This can be a notifier, a promise for a local or remote\\n * notfier, or a presence of a remote notifier.\\n *\\n * It is also used internally by notifier.js so that a notifier itself is an\\n * async iterable.\\n *\\n * An async iterable is an object with a `[Symbol.asyncIterator]()` method\\n * that returns an async iterator. The async iterator we return here has only\\n * a `next()` method, without the optional `return` and `throw` methods. The\\n * omitted methods, if present, would be used by the for/await/of loop to\\n * inform the iterator of early termination. But this adaptor would not do\\n * anything useful in reaction to this notification.\\n *\\n * An async iterator's `next()` method returns a promise for an iteration\\n * result. An iteration result is a record with `value` and `done` properties.\\n *\\n * The purpose of building on the notifier protocol is to have a lossy\\n * adaptor, where intermediate results can be missed in favor of more recent\\n * results which are therefore less stale. See\\n * https://github.com/Agoric/documentation/blob/master/main/distributed-programming.md#notifiers\\n *\\n * @template T\\n * @param {ERef<BaseNotifier<T>>} notifierP\\n * @returns {AsyncIterable<T>}\\n */\\nconst makeAsyncIterableFromNotifier = (notifierP) => {\\n  return harden({\\n    [Symbol.asyncIterator]: () => {\\n      /** @type {UpdateCount} */\\n      let localUpdateCount;\\n      /** @type {Promise<{value: T, done: boolean}> | undefined} */\\n      let myIterationResultP;\\n      return harden({\\n        next: () => {\\n          if (!myIterationResultP) {\\n            /* In this adaptor, once `next()` is called and returns an*/\\n            /* unresolved promise, `myIterationResultP`, and until*/\\n            /* `myIterationResultP` is fulfilled with an*/\\n            /* iteration result, further `next()` calls will return the same*/\\n            /* `myIterationResultP` promise again without asking the notifier*/\\n            /* for more updates. If there's already an unanswered ask in the*/\\n            /* air, all further asks should just reuse the result of that one.*/\\n            /**/\\n            /* This reuse behavior is only needed for code that uses the async*/\\n            /* iterator protocol explicitly. When this async iterator is*/\\n            /* consumed by a for/await/of loop, `next()` will only be called*/\\n            /* after the promise for the previous iteration result has*/\\n            /* fulfilled. If it fulfills with `done: true`, the for/await/of*/\\n            /* loop will never call `next()` again.*/\\n            /**/\\n            /* See*/\\n            /* https://2ality.com/2016/10/asynchronous-iteration.html#queuing-next()-invocations*/\\n            /* for an explicit use that sends `next()` without waiting.*/\\n            myIterationResultP = noShim.E(notifierP).\\n            getUpdateSince(localUpdateCount).\\n            then(({ value, updateCount }) => {\\n              localUpdateCount = updateCount;\\n              const done = localUpdateCount === undefined;\\n              if (!done) {\\n                /* Once the outstanding question has been answered, stop*/\\n                /* using that answer, so any further `next()` questions*/\\n                /* cause a new `getUpdateSince` request.*/\\n                /**/\\n                /* But only if more answers are expected. Once the notifier*/\\n                /* is `done`, that was the last answer so reuse it forever.*/\\n                myIterationResultP = undefined;}\\n\\n              return harden({ value, done });});}\\n\\n\\n          return myIterationResultP;} });} });};\\n\\n\\n\\n\\n\\n\\n/**\\n * This advances `asyncIteratorP` updating `iterationObserver` with each\\n * successive value. The `iterationObserver` may only be interested in certain\\n * occurrences (`updateState`, `finish`, `fail`), so for convenience,\\n * `observeIterator` feature tests for those methods before calling them.\\n *\\n * @template T\\n * @param {ERef<AsyncIterator<T>>} asyncIteratorP\\n * @param {Partial<IterationObserver<T>>} iterationObserver\\n * @returns {Promise<undefined>}\\n */\\nconst observeIterator = (asyncIteratorP, iterationObserver) => {\\n  return new Promise((ack) => {\\n    const recur = () => {\\n      noShim.E.when(\\n      noShim.E(asyncIteratorP).next(),\\n      ({ value, done }) => {\\n        if (done) {\\n          iterationObserver.finish && iterationObserver.finish(value);\\n          ack(undefined);} else\\n        {\\n          iterationObserver.updateState &&\\n          iterationObserver.updateState(value);\\n          recur();}},\\n\\n\\n      (reason) => {\\n        iterationObserver.fail && iterationObserver.fail(reason);\\n        ack(undefined);});};\\n\\n\\n\\n    recur();});};\\n\\n\\n\\n/**\\n * This reads from `asyncIterableP` updating `iterationObserver` with each\\n * successive value. The `iterationObserver` may only be interested in certain\\n * occurrences (`updateState`, `finish`, `fail`), so for convenience,\\n * `observeIteration` feature tests for those methods before calling them.\\n *\\n * @template T\\n * @param {ERef<AsyncIterable<T>>} asyncIterableP\\n * @param {Partial<IterationObserver<T>>} iterationObserver\\n * @returns {Promise<undefined>}\\n */\\nconst observeIteration = (asyncIterableP, iterationObserver) => {\\n  const iteratorP = noShim.E(asyncIterableP)[Symbol.asyncIterator]();\\n  return observeIterator(iteratorP, iterationObserver);};\\n\\n\\n/**\\n * @deprecated Use `observeIteration` instead\\n * @template T\\n * @param {Partial<IterationObserver<T>>} iterationObserver\\n * @param {ERef<AsyncIterable<T>>} asyncIterableP\\n * @returns {Promise<undefined>}\\n */\\nconst updateFromIterable = (iterationObserver, asyncIterableP) =>\\nobserveIteration(asyncIterableP, iterationObserver);\\n\\n/**\\n * As updates come in from the possibly remote `notifierP`, update\\n * the local `updater`. Since the updates come from a notifier, they\\n * are lossy, i.e., once a more recent state can be reported, less recent\\n * states are assumed irrelevant and dropped.\\n *\\n * @template T\\n * @param {ERef<Notifier<T>>} notifierP\\n * @param {Partial<IterationObserver<T>>} iterationObserver\\n * @returns {Promise<undefined>}\\n */\\nconst observeNotifier = (notifierP, iterationObserver) =>\\nobserveIteration(makeAsyncIterableFromNotifier(notifierP), iterationObserver);\\n\\n/**\\n * @deprecated Use 'observeNotifier` instead.\\n * @template T\\n * @param {Partial<IterationObserver<T>>} iterationObserver\\n * @param {ERef<Notifier<T>>} notifierP\\n * @returns {Promise<undefined>}\\n */\\nconst updateFromNotifier = (iterationObserver, notifierP) =>\\nobserveIteration(makeAsyncIterableFromNotifier(notifierP), iterationObserver);exports.makeAsyncIterableFromNotifier = makeAsyncIterableFromNotifier;exports.observeIteration = observeIteration;exports.observeIterator = observeIterator;exports.observeNotifier = observeNotifier;exports.updateFromIterable = updateFromIterable;exports.updateFromNotifier = updateFromNotifier;\",\n  \"packages/notifier/src/index.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var notifier = require('./notifier.js');var subscriber = require('./subscriber.js');var asyncIterableAdaptor = require('./asyncIterableAdaptor.js');exports.makeNotifier = notifier.makeNotifier;exports.makeNotifierFromAsyncIterable = notifier.makeNotifierFromAsyncIterable;exports.makeNotifierKit = notifier.makeNotifierKit;exports.makeSubscription = subscriber.makeSubscription;exports.makeSubscriptionKit = subscriber.makeSubscriptionKit;exports.makeAsyncIterableFromNotifier = asyncIterableAdaptor.makeAsyncIterableFromNotifier;exports.observeIteration = asyncIterableAdaptor.observeIteration;exports.observeIterator = asyncIterableAdaptor.observeIterator;exports.observeNotifier = asyncIterableAdaptor.observeNotifier;exports.updateFromIterable = asyncIterableAdaptor.updateFromIterable;exports.updateFromNotifier = asyncIterableAdaptor.updateFromNotifier;\",\n  \"packages/notifier/src/notifier.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var promiseKit = require('../../promise-kit/src/promiseKit.js');var assert = require('../../assert/src/assert.js');require('../../marshal/index.js');var asyncIterableAdaptor = require('./asyncIterableAdaptor.js');require('./types.js');var\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nmarshal = require('../../marshal/src/marshal.js'); /* @ts-check*/ /**\\n * @template T\\n * @param {BaseNotifier<T>} baseNotifierP\\n * @returns {AsyncIterable<T> & SharableNotifier}\\n */\\nconst makeNotifier = (baseNotifierP) => {\\n  const asyncIterable = asyncIterableAdaptor.makeAsyncIterableFromNotifier(baseNotifierP);\\n\\n  return harden({\\n    ...asyncIterable,\\n    getSharableNotifierInternals: () => baseNotifierP });};\\n\\n\\n\\n/**\\n * Produces a pair of objects, which allow a service to produce a stream of\\n * update promises.\\n *\\n * The initial state argument has to be truly optional even though it can\\n * be any first class value including `undefined`. We need to distinguish the\\n * presence vs the absence of it, which we cannot do with the optional argument\\n * syntax. Rather we use the arity of the arguments array.\\n *\\n * If no initial state is provided to `makeNotifierKit`, then it starts without\\n * an initial state. Its initial state will instead be the state of the first\\n * update.\\n *\\n * @template T\\n * @param {[] | [T]} args the first state to be returned\\n * @returns {NotifierRecord<T>} the notifier and updater\\n */\\nconst makeNotifierKit = (...args) => {\\n  /** @type {PromiseRecord<UpdateRecord<T>>|undefined} */\\n  let nextPromiseKit = promiseKit.makePromiseKit();\\n  /** @type {UpdateCount} */\\n  let currentUpdateCount = 1; /* avoid falsy numbers*/\\n  /** @type {UpdateRecord<T>|undefined} */\\n  let currentResponse;\\n\\n  const hasState = () => currentResponse !== undefined;\\n\\n  const final = () => currentUpdateCount === undefined;\\n\\n  const baseNotifier = harden({\\n    /* NaN matches nothing*/\\n    getUpdateSince(updateCount = NaN) {\\n      if (\\n      hasState() && (\\n      final() ||\\n      currentResponse && currentResponse.updateCount !== updateCount))\\n      {\\n        /* If hasState() and either it is final() or it is*/\\n        /* not the state of updateCount, return the current state.*/\\n        assert.assert(currentResponse !== undefined);\\n        return Promise.resolve(currentResponse);}\\n\\n      /* otherwise return a promise for the next state.*/\\n      assert.assert(nextPromiseKit);\\n      return nextPromiseKit.promise;} });\\n\\n\\n\\n  const notifier = marshal.Far('notifier', {\\n    ...makeNotifier(baseNotifier),\\n    /* TODO stop exposing baseNotifier methods directly*/\\n    ...baseNotifier });\\n\\n\\n  const updater = harden({\\n    updateState(state) {\\n      if (final()) {\\n        throw new Error('Cannot update state after termination.');}\\n\\n\\n      /* become hasState() && !final()*/\\n      assert.assert(nextPromiseKit && currentUpdateCount);\\n      currentUpdateCount += 1;\\n      currentResponse = harden({\\n        value: state,\\n        updateCount: currentUpdateCount });\\n\\n      assert.assert(currentResponse);\\n      nextPromiseKit.resolve(currentResponse);\\n      nextPromiseKit = promiseKit.makePromiseKit();},\\n\\n\\n    finish(finalState) {\\n      if (final()) {\\n        throw new Error('Cannot finish after termination.');}\\n\\n\\n      /* become hasState() && final()*/\\n      assert.assert(nextPromiseKit);\\n      currentUpdateCount = undefined;\\n      currentResponse = harden({\\n        value: finalState,\\n        updateCount: currentUpdateCount });\\n\\n      assert.assert(currentResponse);\\n      nextPromiseKit.resolve(currentResponse);\\n      nextPromiseKit = undefined;},\\n\\n\\n    fail(reason) {\\n      if (final()) {\\n        throw new Error('Cannot fail after termination.');}\\n\\n\\n      /* become !hasState() && final()*/\\n      assert.assert(nextPromiseKit);\\n      currentUpdateCount = undefined;\\n      currentResponse = undefined;\\n      /* Don't trigger Node.js's UnhandledPromiseRejectionWarning*/\\n      nextPromiseKit.promise.catch((_) => {});\\n      nextPromiseKit.reject(reason);} });\\n\\n\\n\\n  if (args.length >= 1) {\\n    updater.updateState(args[0]);}\\n\\n\\n  /* notifier facet is separate so it can be handed out while updater*/\\n  /* is tightly held*/\\n  return harden({ notifier, updater });};\\n\\n\\n/**\\n * Adaptor from async iterable to notifier.\\n *\\n * @template T\\n * @param {AsyncIterable<T>} asyncIterable\\n * @returns {Notifier<T>}\\n */\\nconst makeNotifierFromAsyncIterable = (asyncIterable) => {\\n  const { notifier, updater } = makeNotifierKit();\\n  asyncIterableAdaptor.observeIteration(asyncIterable, updater);\\n  return notifier;};exports.makeNotifier = makeNotifier;exports.makeNotifierFromAsyncIterable = makeNotifierFromAsyncIterable;exports.makeNotifierKit = makeNotifierKit;\",\n  \"packages/notifier/src/subscriber.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var noShim = require('../../eventual-send/src/no-shim.js');require('../../marshal/index.js');var promiseKit = require('../../promise-kit/src/promiseKit.js');require('./types.js');var\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nmarshal = require('../../marshal/src/marshal.js'); /* @ts-check*/ /**\\n * @template T\\n * @param {SubscriptionInternals} startP\\n * @returns {Subscription<T>}\\n */\\nconst makeSubscription = (startP) => {\\n  return marshal.Far('Subscription', {\\n    /* eslint-disable-next-line no-use-before-define*/\\n    [Symbol.asyncIterator]: () => makeSubscriptionIterator(startP),\\n\\n    /**\\n     * Use this to distribute a Subscription efficiently over the network,\\n     * by obtaining this from the Subscription to me replicated, and applying\\n     * `makeSubscription` to it at the new site to get an equivalent local\\n     * Subscription at that site.\\n     *\\n     * @returns {SubscriptionInternals}\\n     */\\n    getSharableSubscriptionInternals: () => startP });};\\n\\n\\nharden(makeSubscription);\\n\\n\\n/**\\n * @template T\\n * @param {SubscriptionInternals} tailP\\n * @returns {SubscriptionIterator<T>}\\n */\\nconst makeSubscriptionIterator = (tailP) => {\\n  /* To understand the implementation, start with*/\\n  /* https://web.archive.org/web/20160404122250/http://wiki.ecmascript.org/doku.php?id=strawman:concurrency#infinite_queue*/\\n  return marshal.Far('SubscriptionIterator', {\\n    subscribe: () => makeSubscription(tailP),\\n    [Symbol.asyncIterator]: () => makeSubscriptionIterator(tailP),\\n    next: () => {\\n      const resultP = noShim.E.get(tailP).head;\\n      tailP = noShim.E.get(tailP).tail;\\n      return resultP;} });};\\n\\n\\n\\n\\n/**\\n * Makes a `{ publicaction, subscription }` for doing lossless efficient\\n * distributed pub/sub.\\n *\\n * @template T\\n * @returns {SubscriptionRecord<T>}\\n */\\nconst makeSubscriptionKit = () => {\\n  let rear;\\n  const subscription = makeSubscription(new noShim.HandledPromise((r) => rear = r));\\n\\n  const publication = marshal.Far('publication', {\\n    updateState: (value) => {\\n      if (rear === undefined) {\\n        throw new Error('Cannot update state after termination.');}\\n\\n      const { promise: nextTailE, resolve: nextRear } = promiseKit.makePromiseKit();\\n      rear(harden({ head: { value, done: false }, tail: nextTailE }));\\n      rear = nextRear;},\\n\\n    finish: (finalValue) => {\\n      if (rear === undefined) {\\n        throw new Error('Cannot finish after termination.');}\\n\\n      const readComplaint = noShim.HandledPromise.reject(\\n      new Error('cannot read past end of iteration'));\\n\\n      readComplaint.catch((_) => {}); /* suppress unhandled rejection error*/\\n      rear({ head: { value: finalValue, done: true }, tail: readComplaint });\\n      rear = undefined;},\\n\\n    fail: (reason) => {\\n      if (rear === undefined) {\\n        throw new Error('Cannot fail after termination.');}\\n\\n      rear(noShim.HandledPromise.reject(reason));\\n      rear = undefined;} });\\n\\n\\n  return harden({ publication, subscription });};\\n\\nharden(makeSubscriptionKit);exports.makeSubscription = makeSubscription;exports.makeSubscriptionKit = makeSubscriptionKit;\",\n  \"packages/notifier/src/types.js\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n'use strict'; /**\\n * @template T\\n * @typedef {Ximport('@agoric/promise-kit').ERef<T>} ERef\\n */ /**\\n * @template T\\n * @typedef {Ximport('@agoric/promise-kit').PromiseRecord<T>} PromiseRecord\\n */ /**\\n * @template T\\n * @typedef {Object} IterationObserver<T>\\n * A valid sequence of calls to the methods of an `IterationObserver`\\n * represents an iteration. A valid sequence consists of any number of calls\\n * to `updateState` with the successive non-final values, followed by a\\n * final call to either `finish` with a successful `completion` value\\n * or `fail` with the alleged `reason` for failure. After at most one\\n * terminating calls, no further calls to these methods are valid and must be\\n * rejected.\\n * @property {(nonFinalValue: T) => void} updateState\\n * @property {(completion: T) => void} finish\\n * @property {(reason: any) => void} fail\\n */ /* /////////////////////////////////////////////////////////////////////////////*/ /**\\n * @typedef {number | undefined} UpdateCount a value used to mark the position\\n * in the update stream. For the last state, the updateCount is undefined.\\n */ /**\\n * @template T\\n * @typedef {Object} UpdateRecord<T>\\n * @property {T} value is whatever state the service wants to publish\\n * @property {UpdateCount} updateCount is a value that identifies the update\\n */ /**\\n * @template T\\n * @callback GetUpdateSince<T> Can be called repeatedly to get a sequence of\\n * update records\\n * @param {UpdateCount} [updateCount] return update record as of an update\\n * count. If the `updateCount` argument is omitted or differs from the current\\n * update count, return the current record.\\n * Otherwise, after the next state change, the promise will resolve to the\\n * then-current value of the record.\\n * @returns {Promise<UpdateRecord<T>>} resolves to the corresponding\\n * update\\n */ /**\\n * @template T\\n * @typedef {Object} BaseNotifier<T> an object that can be used to get the\\n * current state or updates\\n * @property {GetUpdateSince<T>} getUpdateSince return update record as of an\\n * update count.\\n */ /**\\n * @typedef {any} NotifierInternals Purposely opaque. Will be shared between\\n * machines, so it must be same to expose. But other software should avoid\\n * depending on its internal structure.\\n */ /**\\n * @template T\\n * @typedef {BaseNotifier<T> & AsyncIterable<T> & SharableNotifier} Notifier<T> an object that can\\n * be used to get the current state or updates\\n */ /**\\n * @typedef {Object} SharableNotifier\\n * @property {() => NotifierInternals} getSharableNotifierInternals\\n * Used to replicate the multicast values at other sites. To manually create a\\n * local representative of a Notification, do\\n * ```js\\n * localIterable =\\n *   makeNotifier(E(remoteIterable).getSharableNotifierInternals());\\n * ```\\n * The resulting `localIterable` also supports such remote use, and\\n * will return access to the same representation.\\n */ /**\\n * @template T\\n * @typedef {Object} NotifierRecord<T> the produced notifier/updater pair\\n * @property {IterationObserver<T>} updater the (closely-held) notifier producer\\n * @property {Notifier<T>} notifier the (widely-held) notifier consumer\\n */ /* /////////////////////////////////////////////////////////////////////////////*/ /* eslint-disable-next-line jsdoc/require-property*/ /**\\n * @template T\\n * @typedef {{}} BaseSubscription<T>\\n */ /**\\n * @typedef {any} SubscriptionInternals Purposely opaque. Will be shared between\\n * machines, so it must be same to expose. But other software should avoid\\n * depending on its internal structure.\\n */ /**\\n * @template T\\n * @typedef {BaseSubscription<T> & AsyncIterable<T> & SharableSubscription} Subscription<T>\\n * A form of AsyncIterable supporting distributed and multicast usage.\\n */ /**\\n * @typedef {Object} SharableSubscription\\n * @property {() => SubscriptionInternals} getSharableSubscriptionInternals\\n * Used to replicate the multicast values at other sites. To manually create a\\n * local representative of a Subscription, do\\n * ```js\\n * localIterable =\\n *   makeAsyncIterable(E(remoteIterable).getSharableSubscriptionInternals());\\n * ```\\n * The resulting `localIterable` also supports such remote use, and\\n * will return access to the same representation.\\n */ /**\\n * @template T\\n * @typedef {AsyncIterator<T> & AsyncIterable<T>} SubscriptionIterator<T>\\n * an AsyncIterator supporting distributed and multicast usage.\\n *\\n * @property {() => Subscription<T>} subscribe\\n * Get a new subscription whose starting position is this iterator's current\\n * position.\\n */ /**\\n * @template T\\n * @typedef {Object} SubscriptionRecord<T>\\n * @property {IterationObserver<T>} publication\\n * @property {Subscription<T>} subscription\\n */\",\n  \"packages/promise-kit/src/promiseKit.js\": \"'use strict';\\n\\n\\n\\nObject.defineProperty(exports, '__esModule', { value: true }); /* global globalThis */ /* @ts-check*/ /* eslint-disable-next-line spaced-comment*/ /*/ <reference types=\\\"ses\\\"/>*/\\n\\nconst BestPipelinablePromise = globalThis.HandledPromise || Promise;\\n\\n/**\\n * @template T\\n * @typedef {Object} PromiseRecord A reified Promise\\n * @property {(value: ERef<T>) => void} resolve\\n * @property {(reason: any) => void} reject\\n * @property {Promise<T>} promise\\n */\\n\\n/**\\n * @template T\\n * @typedef {T | PromiseLike<T>} ERef\\n * A reference of some kind for to an object of type T. It may be a direct\\n * reference to a local T. It may be a local presence for a remote T. It may\\n * be a promise for a local or remote T. Or it may even be a thenable\\n * (a promise-like non-promise with a \\\"then\\\" method) for a T.\\n */\\n\\n/**\\n * Needed to prevent type errors where functions are detected to be undefined.\\n */\\nconst NOOP_INITIALIZER = harden((_) => {});\\n\\n/**\\n * makePromiseKit() builds a Promise object, and returns a record\\n * containing the promise itself, as well as separate facets for resolving\\n * and rejecting it.\\n *\\n * @template T\\n * @returns {PromiseRecord<T>}\\n */\\nfunction makePromiseKit() {\\n  /** @type {(value: T) => void} */\\n  let res = NOOP_INITIALIZER;\\n  /** @type {(reason: any) => void} */\\n  let rej = NOOP_INITIALIZER;\\n\\n  const p = new BestPipelinablePromise((resolve, reject) => {\\n    res = resolve;\\n    rej = reject;});\\n\\n  /* Node.js adds the `domain` property which is not a standard*/\\n  /* property on Promise. Because we do not know it to be ocap-safe,*/\\n  /* we remove it.*/\\n  if (p.domain) {\\n    /* deleting p.domain may break functionality. To retain current*/\\n    /* functionality at the expense of safety, set unsafe to true.*/\\n    const unsafe = false;\\n    if (unsafe) {\\n      const originalDomain = p.domain;\\n      Object.defineProperty(p, 'domain', {\\n        get() {\\n          return originalDomain;} });} else\\n\\n\\n    {\\n      delete p.domain;}}\\n\\n\\n  return harden({ promise: p, resolve: res, reject: rej });}\\n\\nharden(makePromiseKit);\\n\\n/**\\n * Determine if the argument is a Promise.\\n *\\n * @param {any} maybePromise The value to examine\\n * @returns {maybePromise is Promise} Whether it is a promise\\n */\\nfunction isPromise(maybePromise) {\\n  return Promise.resolve(maybePromise) === maybePromise;}\\n\\nharden(isPromise);exports.isPromise = isPromise;exports.makePromiseKit = makePromiseKit;\",\n  \"packages/same-structure/index.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var sameStructure = require('./src/sameStructure.js');exports.allComparable = sameStructure.allComparable;exports.mustBeComparable = sameStructure.mustBeComparable;exports.mustBeSameStructure = sameStructure.mustBeSameStructure;exports.sameStructure = sameStructure.sameStructure;exports.sameValueZero = sameStructure.sameValueZero;\",\n  \"packages/same-structure/src/sameStructure.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });require('../../marshal/index.js');var assert = require('../../assert/src/assert.js');var passStyleOf = require('../../marshal/src/passStyleOf.js'); /* @ts-check*/\\n\\n\\n\\n\\nconst {\\n  is,\\n  defineProperty,\\n  getOwnPropertyNames,\\n  getOwnPropertyDescriptor } =\\nObject;\\n\\n/* Shim of Object.fromEntries from*/\\n/* https://github.com/tc39/proposal-object-from-entries/blob/master/polyfill.js*/\\n/* TODO reconcile and dedup with the Object.fromEntries ponyfill in*/\\n/* SES-shim/packages/ses/src/commons.js*/\\nfunction objectFromEntries(iter) {\\n  const obj = {};\\n\\n  for (const pair of iter) {\\n    if (Object(pair) !== pair) {\\n      throw new TypeError('iterable for fromEntries should yield objects');}\\n\\n\\n    /* Consistency with Map: contract is that entry has \\\"0\\\" and \\\"1\\\" keys, not*/\\n    /* that it is an array or iterable.*/\\n\\n    const { '0': key, '1': val } = pair;\\n\\n    defineProperty(obj, key, {\\n      configurable: true,\\n      enumerable: true,\\n      writable: true,\\n      value: val });}\\n\\n\\n\\n  return obj;}\\n\\n\\n/**\\n * This is the equality comparison used by JavaScript's Map and Set\\n * abstractions, where NaN is the same as NaN and -0 is the same as\\n * 0. Marshal serializes -0 as zero, so the semantics of our distributed\\n * object system does not distinguish 0 from -0.\\n *\\n * `sameValueZero` is the EcmaScript spec name for this equality comparison,\\n * but TODO we need a better name for the API.\\n *\\n * @param {any} x\\n * @param {any} y\\n * @returns {boolean}\\n */\\nfunction sameValueZero(x, y) {\\n  return x === y || is(x, y);}\\n\\nharden(sameValueZero);\\n\\n/**\\n * A *passable* is something that may be marshalled. It consists of a\\n * graph of pass-by-copy data terminating in leaves of passable\\n * non-pass-by-copy data. These leaves may be promises, or\\n * pass-by-presence objects. A *comparable* is a passable whose leaves\\n * contain no promises. Two comparables can be synchronously compared\\n * for structural equivalence.\\n *\\n * TODO: Currently, all algorithms here treat the pass-by-copy\\n * superstructure as a tree. This means that dags are unwound at\\n * potentially exponential cost, and cycles cause failure to\\n * terminate. We must fix both problems, making all these algorithms\\n * graph-aware.\\n *\\n * We say that a function *reveals* an X when it returns either an X\\n * or a promise for an X.\\n *\\n * Given a passable, reveal a corresponding comparable, where each\\n * leaf promise of the passable has been replaced with its\\n * corresponding comparable.\\n *\\n * @param {Passable} passable\\n * @returns {Promise<Comparable>}\\n */\\nfunction allComparable(passable) {\\n  const passStyle = passStyleOf.passStyleOf(passable);\\n  switch (passStyle) {\\n    case 'null':\\n    case 'undefined':\\n    case 'string':\\n    case 'boolean':\\n    case 'number':\\n    case 'bigint':\\n    case 'remotable':\\n    case 'copyError':{\\n        return passable;}\\n\\n    case 'promise':{\\n        return passable.then((nonp) => allComparable(nonp));}\\n\\n    case 'copyArray':{\\n        const valPs = passable.map((p) => allComparable(p));\\n        return Promise.all(valPs).then((vals) => harden(vals));}\\n\\n    case 'copyRecord':{\\n        const names = getOwnPropertyNames(passable);\\n        const valPs = names.map((name) => allComparable(passable[name]));\\n        return Promise.all(valPs).then((vals) =>\\n        harden(objectFromEntries(vals.map((val, i) => [names[i], val]))));}\\n\\n\\n    default:{\\n        assert.assert.fail(assert.details`unrecognized passStyle ${passStyle}`, TypeError);}}}\\n\\n\\n\\nharden(allComparable);\\n\\n/**\\n * Are left and right structurally equivalent comparables? This\\n * compares pass-by-copy data deeply until non-pass-by-copy values are\\n * reached. The non-pass-by-copy values at the leaves of the\\n * comparison may only be pass-by-presence objects. If they are\\n * anything else, including promises, throw an error.\\n *\\n * Pass-by-presence objects compare identities.\\n *\\n * @param {Comparable} left\\n * @param {Comparable} right\\n * @returns {boolean}\\n */\\nfunction sameStructure(left, right) {\\n  const leftStyle = passStyleOf.passStyleOf(left);\\n  const rightStyle = passStyleOf.passStyleOf(right);\\n  assert.assert(\\n  leftStyle !== 'promise',\\n  assert.details`Cannot structurally compare promises: ${left}`);\\n\\n  assert.assert(\\n  rightStyle !== 'promise',\\n  assert.details`Cannot structurally compare promises: ${right}`);\\n\\n\\n  if (leftStyle !== rightStyle) {\\n    return false;}\\n\\n  switch (leftStyle) {\\n    case 'null':\\n    case 'undefined':\\n    case 'string':\\n    case 'boolean':\\n    case 'number':\\n    case 'bigint':\\n    case 'remotable':{\\n        return sameValueZero(left, right);}\\n\\n    case 'copyRecord':\\n    case 'copyArray':{\\n        const leftNames = getOwnPropertyNames(left);\\n        const rightNames = getOwnPropertyNames(right);\\n        if (leftNames.length !== rightNames.length) {\\n          return false;}\\n\\n        for (const name of leftNames) {\\n          /* TODO: Better hasOwnProperty check*/\\n          if (!getOwnPropertyDescriptor(right, name)) {\\n            return false;}\\n\\n          /* TODO: Make cycle tolerant*/\\n          if (!sameStructure(left[name], right[name])) {\\n            return false;}}\\n\\n\\n        return true;}\\n\\n    case 'copyError':{\\n        return left.name === right.name && left.message === right.message;}\\n\\n    default:{\\n        assert.assert.fail(assert.details`unrecognized passStyle ${leftStyle}`, TypeError);}}}\\n\\n\\n\\nharden(sameStructure);\\n\\nfunction pathStr(path) {\\n  if (path === null) {\\n    return 'top';}\\n\\n  const [base, index] = path;\\n  let i = index;\\n  const baseStr = pathStr(base);\\n  if (typeof i === 'string' && /^[a-zA-Z]\\\\w*$/.test(i)) {\\n    return `${baseStr}.${i}`;}\\n\\n  if (typeof i === 'string' && `${+i}` === i) {\\n    i = +i;}\\n\\n  return `${baseStr}[${JSON.stringify(i)}]`;}\\n\\n\\n/* TODO: Reduce redundancy between sameStructure and*/\\n/* mustBeSameStructureInternal*/\\nfunction mustBeSameStructureInternal(left, right, message, path) {\\n  function complain(problem) {\\n    assert.assert.fail(\\n    assert.details`${assert.quote(message)}: ${assert.quote(problem)} at ${assert.quote(\\n    pathStr(path))\\n    }: (${left}) vs (${right})`);}\\n\\n\\n\\n  const leftStyle = passStyleOf.passStyleOf(left);\\n  const rightStyle = passStyleOf.passStyleOf(right);\\n  if (leftStyle === 'promise') {\\n    complain('Promise on left');}\\n\\n  if (rightStyle === 'promise') {\\n    complain('Promise on right');}\\n\\n\\n  if (leftStyle !== rightStyle) {\\n    complain('different passing style');}\\n\\n  switch (leftStyle) {\\n    case 'null':\\n    case 'undefined':\\n    case 'string':\\n    case 'boolean':\\n    case 'number':\\n    case 'bigint':\\n    case 'remotable':{\\n        if (!sameValueZero(left, right)) {\\n          complain('different');}\\n\\n        break;}\\n\\n    case 'copyRecord':\\n    case 'copyArray':{\\n        const leftNames = getOwnPropertyNames(left);\\n        const rightNames = getOwnPropertyNames(right);\\n        if (leftNames.length !== rightNames.length) {\\n          complain(`${leftNames.length} vs ${rightNames.length} own properties`);}\\n\\n        for (const name of leftNames) {\\n          /* TODO: Better hasOwnProperty check*/\\n          if (!getOwnPropertyDescriptor(right, name)) {\\n            complain(`${name} not found on right`);}\\n\\n          /* TODO: Make cycle tolerant*/\\n          mustBeSameStructureInternal(left[name], right[name], message, [\\n          path,\\n          name]);}\\n\\n\\n        break;}\\n\\n    case 'copyError':{\\n        if (left.name !== right.name) {\\n          complain(`different error name: ${left.name} vs ${right.name}`);}\\n\\n        if (left.message !== right.message) {\\n          complain(\\n          `different error message: ${left.message} vs ${right.message}`);}\\n\\n\\n        break;}\\n\\n    default:{\\n        complain(`unrecognized passStyle ${leftStyle}`);\\n        break;}}}\\n\\n\\n\\n\\n/**\\n * @param {Comparable} left\\n * @param {Comparable} right\\n * @param {string} message\\n */\\nfunction mustBeSameStructure(left, right, message) {\\n  mustBeSameStructureInternal(left, right, `${message}`, null);}\\n\\nharden(mustBeSameStructure);\\n\\n/**\\n * If `val` would be a valid input to `sameStructure`, return\\n * normally. Otherwise error.\\n *\\n * @param {Comparable} val\\n */\\nfunction mustBeComparable(val) {\\n  mustBeSameStructure(val, val, 'not comparable');}exports.allComparable = allComparable;exports.mustBeComparable = mustBeComparable;exports.mustBeSameStructure = mustBeSameStructure;exports.sameStructure = sameStructure;exports.sameValueZero = sameValueZero;\",\n  \"packages/store/exported.js\": \"'use strict';require('./src/types.js');\",\n  \"packages/store/src/external/default.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });require('../types.js');var memory = require('./memory.js'); /* Copyright (C) 2019 Agoric, under Apache license 2.0*/\\n\\n\\n\\n\\n\\n\\nconst makeExternalStore = memory.makeMemoryExternalStore;exports.makeExternalStore = makeExternalStore;\",\n  \"packages/store/src/external/hydrate.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });require('../types.js');var weakStore = require('../weak-store.js');var\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nstore = require('../store.js'); /* @ts-check*/ /**\\n * @callback MakeBackingStore\\n * @param {HydrateHook} hydrateHook\\n * @returns {BackingStore}\\n */ /**\\n * This creates an external store maker for a given storage backend, supporting\\n * the Closure interface that the rewriter targets.\\n *\\n * @template {Array<any>} A\\n * @template {ExternalInstance} T\\n * @param {MakeBackingStore} makeBackingStore\\n * @returns {MakeHydrateExternalStore<A, T>}\\n */const makeHydrateExternalStoreMaker = (makeBackingStore) => {/** @type {WeakStore<T, HydrateKey>} */const instanceToKey = weakStore.makeWeakStore('instance');\\n  let lastStoreId = 0;\\n\\n  /* This has to be a strong store, since it is indexed by ID.*/\\n  const storeIdToHydrate = store.makeStore('storeId');\\n\\n  /**\\n   * Create a data object that queues writes to the store.\\n   *\\n   * @param {HydrateData} data\\n   * @param {() => void} markDirty\\n   */\\n  const makeActiveData = (data, markDirty) => {\\n    const activeData = {};\\n    /* For every property in data...*/\\n    for (const prop of Object.getOwnPropertyNames(data)) {\\n      /* Define a getter and setter on activeData.*/\\n      Object.defineProperty(activeData, prop, {\\n        get: () => data[prop],\\n        set: (value) => {\\n          data[prop] = value;\\n          markDirty();} });}\\n\\n\\n\\n    return harden(activeData);};\\n\\n\\n  /** @type {BackingStore} */\\n  let backing;\\n\\n  /** @type {HydrateHook} */\\n  const hydrateHook = {\\n    getKey(value) {\\n      return instanceToKey.get(value);},\\n\\n    load([storeId, instanceId]) {\\n      const hydrate = storeIdToHydrate.get(storeId);\\n      const store = backing.getHydrateStore(storeId);\\n\\n      const data = store.get(instanceId);\\n      const markDirty = () => store.set(instanceId, data);\\n\\n      const activeData = makeActiveData(data, markDirty);\\n      const obj = hydrate(activeData);\\n      instanceToKey.init(obj, [storeId, instanceId]);\\n      return obj;},\\n\\n    drop(storeId) {\\n      storeIdToHydrate.delete(storeId);} };\\n\\n\\n\\n  backing = makeBackingStore(hydrateHook);\\n\\n  /** @type {MakeHydrateExternalStore<A, T>} */\\n  function makeHydrateExternalStore(keyName, adaptArguments, makeHydrate) {\\n    let lastInstanceId = 0;\\n\\n    lastStoreId += 1;\\n    const storeId = lastStoreId;\\n    const hstore = backing.makeHydrateStore(storeId, keyName);\\n\\n    const initHydrate = makeHydrate(true);\\n    storeIdToHydrate.init(storeId, makeHydrate());\\n\\n    /** @type {ExternalStore<(...args: A) => T>} */\\n    const estore = {\\n      makeInstance(...args) {\\n        const data = adaptArguments(...args);\\n        /* Create a new object with the above guts.*/\\n        lastInstanceId += 1;\\n        const instanceId = lastInstanceId;\\n        initHydrate(data);\\n\\n        /* We store and reload it to sanity-check the initial state and also to*/\\n        /* ensure that the new object has active data.*/\\n        hstore.init(instanceId, data);\\n        return hydrateHook.load([storeId, instanceId]);},\\n\\n      makeWeakStore() {\\n        return hstore.makeWeakStore();} };\\n\\n\\n    return estore;}\\n\\n  return harden(makeHydrateExternalStore);};exports.makeHydrateExternalStoreMaker = makeHydrateExternalStoreMaker;\",\n  \"packages/store/src/external/memory.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var weakStore = require('../weak-store.js');\\n\\n\\n\\n\\n\\nrequire('../types.js'); /* Copyright (C) 2019-20 Agoric, under Apache license 2.0*/ /**\\n * Create a completely in-memory \\\"external\\\" store.  This store will be\\n * garbage-collected in the usual way, but it will not page out any objects to\\n * secondary storage.\\n *\\n * @template {(...args: any[]) => ExternalInstance} M\\n * @param {string} keyName\\n * @param {M} maker\\n * @returns {ExternalStore<M>}\\n */\\nfunction makeMemoryExternalStore(keyName, maker) {\\n  return harden({\\n    makeInstance: maker,\\n    makeWeakStore() {\\n      return weakStore.makeWeakStore(keyName);} });}\\n\\n\\n\\nharden(makeMemoryExternalStore);exports.makeMemoryExternalStore = makeMemoryExternalStore;\",\n  \"packages/store/src/helpers.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });require('../../marshal/index.js');var\\n\\n\\n\\npassStyleOf = require('../../marshal/src/passStyleOf.js'); /* @ts-check*/ /**\\n * Helper function to reject keys which are empty objects but not marked as\\n * Remotable. This is intended to catch code which uses harden({}) (which\\n * will become pass-by-copy, see #2018) as a \\\"handle\\\" or \\\"marker object\\\"\\n * when they should have used Far().\\n *\\n * @param { unknown } key\\n */\\nfunction isEmptyNonRemotableObject(key) {\\n  return (\\n    typeof key === 'object' &&\\n    key !== null &&\\n    Reflect.ownKeys(key).length === 0 &&\\n    passStyleOf.getInterfaceOf(key) === undefined);}\\n\\n\\nharden(isEmptyNonRemotableObject);exports.isEmptyNonRemotableObject = isEmptyNonRemotableObject;\",\n  \"packages/store/src/index.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var store = require('./store.js');var weakStore = require('./weak-store.js');var _default = require('./external/default.js');var memory = require('./external/memory.js');var hydrate = require('./external/hydrate.js');exports.default = store.makeStore;exports.makeStore = store.makeStore;exports.makeWeakStore = weakStore.makeWeakStore;exports.makeExternalStore = _default.makeExternalStore;exports.makeMemoryExternalStore = memory.makeMemoryExternalStore;exports.makeHydrateExternalStoreMaker = hydrate.makeHydrateExternalStoreMaker;\",\n  \"packages/store/src/store.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var assert = require('../../assert/src/assert.js');var\\n\\n\\n\\n\\n\\n\\nhelpers = require('./helpers.js'); /* Copyright (C) 2019 Agoric, under Apache license 2.0*/ /**\\n * Distinguishes between adding a new key (init) and updating or\\n * referencing a key (get, set, delete).\\n *\\n * `init` is only allowed if the key does not already exist. `Get`,\\n * `set` and `delete` are only allowed if the key does already exist.\\n *\\n * @template K,V\\n * @param  {string} [keyName='key'] - the column name for the key\\n * @returns {Store<K,V>}\\n */\\nfunction makeStore(keyName = 'key') {\\n  const store = new Map();\\n  const assertKeyDoesNotExist = (key) =>\\n  assert.assert(!store.has(key), assert.details`${assert.quote(keyName)} already registered: ${key}`);\\n  const assertKeyExists = (key) =>\\n  assert.assert(store.has(key), assert.details`${assert.quote(keyName)} not found: ${key}`);\\n  const assertNotBadKey = (key) =>\\n  assert.assert(!helpers.isEmptyNonRemotableObject(key), assert.details`${assert.quote(keyName)} bad key: ${key}`);\\n  return harden({\\n    has: (key) => {\\n      assertNotBadKey(key);\\n      return store.has(key);},\\n\\n    init: (key, value) => {\\n      assertNotBadKey(key);\\n      assertKeyDoesNotExist(key);\\n      store.set(key, value);},\\n\\n    get: (key) => {\\n      assertNotBadKey(key);\\n      assertKeyExists(key);\\n      return store.get(key);},\\n\\n    set: (key, value) => {\\n      assertNotBadKey(key);\\n      assertKeyExists(key);\\n      store.set(key, value);},\\n\\n    delete: (key) => {\\n      assertNotBadKey(key);\\n      assertKeyExists(key);\\n      store.delete(key);},\\n\\n    keys: () => Array.from(store.keys()),\\n    values: () => Array.from(store.values()),\\n    entries: () => Array.from(store.entries()) });}\\n\\n\\nharden(makeStore);exports.makeStore = makeStore;\",\n  \"packages/store/src/types.js\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n'use strict'; /* eslint-disable-next-line spaced-comment*/ /*/ <reference types=\\\"ses\\\"/>*/ /**\\n * @typedef {Record<string, Function>} ExternalInstance\\n */ /**\\n * @template K,V\\n * @typedef {Object} Store - A safety wrapper around a Map\\n * @property {(key: K) => boolean} has - Check if a key exists\\n * @property {(key: K, value: V) => void} init - Initialize the key only if it\\n * doesn't already exist\\n * @property {(key: K) => V} get - Return a value for the key. Throws if not\\n * found.\\n * @property {(key: K, value: V) => void} set - Set the key. Throws if not\\n * found.\\n * @property {(key: K) => void} delete - Remove the key. Throws if not found.\\n * @property {() => K[]} keys - Return an array of keys\\n * @property {() => V[]} values - Return an array of values\\n * @property {() => [K, V][]} entries - Return an array of entries\\n */ /**\\n * @template K,V\\n * @typedef {Object} WeakStore - A safety wrapper around a WeakMap\\n * @property {(key: any) => boolean} has - Check if a key exists\\n * @property {(key: K, value: V) => void} init - Initialize the key only if it\\n * doesn't already exist\\n * @property {(key: any) => V} get - Return a value for the key. Throws if not\\n * found.\\n * @property {(key: K, value: V) => void} set - Set the key. Throws if not\\n * found.\\n * @property {(key: K) => void} delete - Remove the key. Throws if not found.\\n */ /**\\n * Distinguishes between adding a new key (init) and updating or\\n * referencing a key (get, set, delete).\\n *\\n * `init` is only allowed if the key does not already exist. `Get`,\\n * `set` and `delete` are only allowed if the key does already exist.\\n *\\n * @template K,V\\n * @callback MakeWeakStore\\n * @param {string} [keyName='key'] - the column name for the key\\n * @returns {WeakStore<K,V>}\\n */ /**\\n * An external store for a given maker function.\\n * TODO: We should provide makers for other kinds of data structures.\\n * Weak sorted lists, weak priority queues, and many others.\\n *\\n * @template {(...args: Array<any>) => ExternalInstance} M\\n * @typedef {Object} ExternalStore\\n * @property {M} makeInstance Create a fresh instance\\n * @property {MakeWeakStore<ReturnType<M>, any>} makeWeakStore Create an\\n * external weak store indexed by an instance\\n */ /**\\n * @typedef {Record<string, any>} HydrateData\\n */ /**\\n * @typedef {[number, number]} HydrateKey\\n * @typedef {true} HydrateInit\\n * @typedef {Object} HydrateHook\\n * @property {(value: any) => HydrateKey} getKey\\n * @property {(key: HydrateKey) => any} load\\n * @property {(storeId: number) => void} drop\\n */ /**\\n * An external store that decouples the closure data from the returned\\n * \\\"representative\\\" instance.\\n *\\n * @template {Array<any>} A\\n * @template {ExternalInstance} T\\n * @callback MakeHydrateExternalStore\\n * @param {string} instanceKind\\n * @param {(...args: A) => HydrateData} adaptArguments\\n * @param {(init?: HydrateInit) => (data: HydrateData) => T} makeHydrate\\n * @returns {ExternalStore<(...args: A) => T>}\\n */ /**\\n * @typedef {Object} HydrateStore The store needed to save closed-over\\n * per-instance data\\n * @property {(id: number, data: HydrateData) => void} init\\n * @property {(id: number) => HydrateData} get\\n * @property {(id: number, data: HydrateData) => void} set\\n * @property {() => WeakStore<ExternalInstance, any>} makeWeakStore\\n */ /**\\n * @typedef {Object} BackingStore This is the master store that reifies storeIds\\n * @property {(storeId: number, instanceKind: string) => HydrateStore} makeHydrateStore\\n * @property {(storeId: number) => HydrateStore} getHydrateStore\\n */\",\n  \"packages/store/src/weak-store.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var assert = require('../../assert/src/assert.js');var helpers = require('./helpers.js');\\n\\n\\n\\n\\n\\n\\n\\nrequire('./types.js'); /* Copyright (C) 2019 Agoric, under Apache license 2.0*/ /**\\n * @template {Record<any, any>} K\\n * @template {any} V\\n * @param {string} [keyName='key']\\n * @returns {WeakStore<K, V>}\\n */\\nfunction makeWeakStore(keyName = 'key') {\\n  const wm = new WeakMap();\\n  const assertKeyDoesNotExist = (key) =>\\n  assert.assert(!wm.has(key), assert.details`${assert.quote(keyName)} already registered: ${key}`);\\n  const assertKeyExists = (key) =>\\n  assert.assert(wm.has(key), assert.details`${assert.quote(keyName)} not found: ${key}`);\\n  const assertNotBadKey = (key) =>\\n  assert.assert(!helpers.isEmptyNonRemotableObject(key), assert.details`${assert.quote(keyName)} bad key: ${key}`);\\n  return harden({\\n    has: (key) => {\\n      assertNotBadKey(key);\\n      return wm.has(key);},\\n\\n    init: (key, value) => {\\n      assertNotBadKey(key);\\n      assertKeyDoesNotExist(key);\\n      wm.set(key, value);},\\n\\n    get: (key) => {\\n      assertNotBadKey(key);\\n      assertKeyExists(key);\\n      return wm.get(key);},\\n\\n    set: (key, value) => {\\n      assertNotBadKey(key);\\n      assertKeyExists(key);\\n      wm.set(key, value);},\\n\\n    delete: (key) => {\\n      assertNotBadKey(key);\\n      assertKeyExists(key);\\n      wm.delete(key);} });}\\n\\n\\n\\nharden(makeWeakStore);exports.makeWeakStore = makeWeakStore;\",\n  \"packages/treasury/src/collectRewardFees.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });require('../../zoe/src/contractSupport/index.js');var noShim = require('../../eventual-send/src/no-shim.js');var zoeHelpers = require('../../zoe/src/contractSupport/zoeHelpers.js'); /* @ts-check*/\\n\\n\\n\\n\\nconst makeMakeCollectFeesInvitation = (\\nzcf,\\nfeeSeat,\\nautoswapCreatorFacet,\\nrunBrand) =>\\n{\\n  const collectFees = async (seat) => {\\n    const invitation = await noShim.E(\\n    autoswapCreatorFacet).\\n    makeCollectFeesInvitation();\\n    const { zcfSeat: transferSeat } = zcf.makeEmptySeatKit();\\n    await noShim.E.get(zoeHelpers.offerTo(zcf, invitation, {}, {}, transferSeat)).deposited;\\n\\n    seat.incrementBy(\\n    feeSeat.decrementBy({ RUN: feeSeat.getAmountAllocated('RUN', runBrand) }));\\n\\n    seat.incrementBy(\\n    transferSeat.decrementBy({\\n      RUN: transferSeat.getAmountAllocated('RUN', runBrand) }));\\n\\n\\n    const totalTransferred = seat.getStagedAllocation().RUN;\\n\\n    zcf.reallocate(transferSeat, feeSeat, seat);\\n    seat.exit();\\n    transferSeat.exit();\\n\\n    return `paid out ${totalTransferred.value}`;};\\n\\n\\n  const makeCollectFeesInvitation = () =>\\n  zcf.makeInvitation(collectFees, 'collect Fees');\\n\\n  return { makeCollectFeesInvitation };};exports.makeMakeCollectFeesInvitation = makeMakeCollectFeesInvitation;\",\n  \"packages/treasury/src/interest.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });require('../../zoe/exported.js');require('../../zoe/src/contracts/callSpread/types.js');require('./types.js');var ratio = require('../../zoe/src/contractSupport/ratio.js');require('../../ERTP/src/index.js');var amountMath = require('../../ERTP/src/amountMath.js'); /* @ts-check*/\\n\\n\\n\\n\\n\\n\\n\\nfunction makeResult(latestInterestUpdate, interest, newDebt) {\\n  return { latestInterestUpdate, interest, newDebt };}\\n\\n\\nconst SECONDS_PER_YEAR = 60n * 60n * 24n * 365n;\\nconst BASIS_POINTS = 10000;\\n/* single digit APR is less than a basis point per day.*/\\nconst LARGE_DENOMINATOR = BASIS_POINTS * BASIS_POINTS;\\n\\n/** @type {MakeInterestCalculator} */\\nfunction makeInterestCalculator(\\nbrand,\\nannualRate,\\nchargingPeriod,\\nrecordingPeriod)\\n{\\n  /* see https://en.wikipedia.org/wiki/Compound_interest#Compounding_basis*/\\n  const numeratorValue = Number(annualRate.numerator.value);\\n  const denominatorValue = Number(annualRate.denominator.value);\\n\\n  const rawAnnualRate = numeratorValue / denominatorValue;\\n  const chargingFrequency = Number(chargingPeriod) / Number(SECONDS_PER_YEAR);\\n  const periodicRate = (1 + rawAnnualRate) ** chargingFrequency - 1;\\n\\n  const ratePerChargingPeriod = ratio.makeRatio(\\n  BigInt(Math.floor(periodicRate * LARGE_DENOMINATOR)),\\n  annualRate.numerator.brand,\\n  BigInt(LARGE_DENOMINATOR));\\n\\n\\n  /* Calculate new debt for charging periods up to the present.*/\\n  /** @type {Calculate} */\\n  function calculate(debtStatus, currentTime) {\\n    const { newDebt, latestInterestUpdate } = debtStatus;\\n    let newRecent = latestInterestUpdate;\\n    let growingInterest = debtStatus.interest;\\n    let growingDebt = newDebt;\\n    while (newRecent + chargingPeriod <= currentTime) {\\n      newRecent += chargingPeriod;\\n      const newInterest = ratio.multiplyBy(growingDebt, ratePerChargingPeriod);\\n      growingInterest = amountMath.AmountMath.add(growingInterest, newInterest);\\n      growingDebt = amountMath.AmountMath.add(growingDebt, newInterest, brand);}\\n\\n    return makeResult(newRecent, growingInterest, growingDebt);}\\n\\n\\n  /* Calculate new debt for reporting periods up to the present. If some*/\\n  /* charging periods have elapsed that don't constitute whole reporting*/\\n  /* periods, the time is not updated past them and interest is not accumulated*/\\n  /* for them.*/\\n  /** @type {Calculate} */\\n  function calculateReportingPeriod(debtStatus, currentTime) {\\n    const { latestInterestUpdate } = debtStatus;\\n    const overshoot = (currentTime - latestInterestUpdate) % recordingPeriod;\\n    return calculate(debtStatus, currentTime - overshoot);}\\n\\n\\n  return harden({\\n    calculate,\\n    calculateReportingPeriod });}exports.SECONDS_PER_YEAR = SECONDS_PER_YEAR;exports.makeInterestCalculator = makeInterestCalculator;\",\n  \"packages/treasury/src/liquidateMinimum.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var noShim = require('../../eventual-send/src/no-shim.js');require('../../zoe/src/contractSupport/index.js');var assert = require('../../assert/src/assert.js');require('../../ERTP/src/index.js');var liquidation = require('./liquidation.js');var makeTracer = require('./makeTracer.js');var zoeHelpers = require('../../zoe/src/contractSupport/zoeHelpers.js');var\\n\\n\\n\\n\\n\\n\\n\\n\\n\\namountMath = require('../../ERTP/src/amountMath.js'); /* @ts-check*/ /* TODO(hibbert): export from autoswap*/\\nconst AutoswapInsufficientMsg = / is insufficient to buy amountOut /;\\n\\nconst trace = makeTracer.makeTracer('LM');\\n\\n/**\\n * This contract liquidates the minimum amount of vault's collateral necessary\\n * to satisfy the debt. It uses AutoSwap's swapOut, which sells no more than\\n * necessary. Because it has offer safety, it can refuse the trade. When that\\n * happens, we fall back to selling using the default strategy, which currently\\n * uses AutoSwap's swapIn instead.\\n */\\n\\n/** @type {ContractStartFn} */\\nasync function start(zcf) {\\n  const { autoswap } = zcf.getTerms();\\n\\n  function makeDebtorHook(runDebt) {\\n    const runBrand = runDebt.brand;\\n    return async function debtorHook(debtorSeat) {\\n      const {\\n        give: { In: amountIn } } =\\n      debtorSeat.getProposal();\\n\\n      trace(`Proposal: ${assert.quote(debtorSeat.getProposal())}`);\\n\\n      const swapInvitation = noShim.E(autoswap).makeSwapOutInvitation();\\n\\n      const liqProposal = harden({\\n        give: { In: amountIn },\\n        want: { Out: runDebt } });\\n\\n      trace(`OFFER TO DEBT: `, runDebt.value);\\n\\n      const { deposited, userSeatPromise: liqSeat } = await zoeHelpers.offerTo(\\n      zcf,\\n      swapInvitation,\\n      undefined, /* The keywords were mapped already*/\\n      liqProposal,\\n      debtorSeat);\\n\\n\\n      /* if swapOut failed for insufficient funds, we'll sell it all*/\\n      async function onSwapOutFail(error) {\\n        const strategy = liquidation.makeDefaultLiquidationStrategy(autoswap);\\n        trace(`onSwapoutFail`);\\n        assert.assert(\\n        error.message.match(AutoswapInsufficientMsg),\\n        `unable to liquidate: ${error}`);\\n\\n\\n        const {\\n          deposited: sellAllDeposited,\\n          userSeatPromise: sellAllSeat } =\\n        await zoeHelpers.offerTo(\\n        zcf,\\n        strategy.makeInvitation(),\\n        undefined, /* The keywords were mapped already*/\\n        strategy.makeProposal(amountIn, amountMath.AmountMath.makeEmpty(runBrand)),\\n        debtorSeat);\\n\\n        /* await sellAllDeposited, but don't need the value*/\\n        await Promise.all([\\n        noShim.E(sellAllSeat).getOfferResult(),\\n        sellAllDeposited]).\\n        catch((sellAllError) => {\\n          throw Error(`Unable to liquidate ${sellAllError}`);});}\\n\\n\\n\\n      /* await deposited, but we don't need the value. We'll need it to have*/\\n      /* resolved in both branches, so can't put it in Promise.all.*/\\n      await deposited;\\n      await noShim.E(liqSeat).\\n      getOfferResult().\\n      catch(onSwapOutFail);\\n      debtorSeat.exit();};}\\n\\n\\n\\n  const creatorFacet = {\\n    makeDebtorInvitation: (runDebt) =>\\n    zcf.makeInvitation(makeDebtorHook(runDebt), 'Liquidate') };\\n\\n\\n  return harden({ creatorFacet });}\\n\\n\\nfunction makeLiquidationStrategy(creatorFacet) {\\n  async function makeInvitation(runDebt) {\\n    return creatorFacet.makeDebtorInvitation(runDebt);}\\n\\n\\n  function keywordMapping() {\\n    return harden({\\n      Collateral: 'In',\\n      RUN: 'Out' });}\\n\\n\\n\\n  function makeProposal(collateral, run) {\\n    return harden({\\n      give: { In: collateral },\\n      want: { Out: amountMath.AmountMath.makeEmptyFromAmount(run) } });}\\n\\n\\n\\n  return {\\n    makeInvitation,\\n    keywordMapping,\\n    makeProposal };}exports.makeLiquidationStrategy = makeLiquidationStrategy;exports.start = start;\",\n  \"packages/treasury/src/liquidation.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var noShim = require('../../eventual-send/src/no-shim.js');require('../../ERTP/src/index.js');require('../../zoe/src/contractSupport/index.js');var makeTracer = require('./makeTracer.js');var zoeHelpers = require('../../zoe/src/contractSupport/zoeHelpers.js');var amountMath = require('../../ERTP/src/amountMath.js'); /* @ts-check*/\\n\\n\\n\\n\\n\\n\\nconst trace = makeTracer.makeTracer('LIQ');\\n\\n/* Liquidates a Vault, using the strategy to parameterize the particular*/\\n/* contract being used. The strategy provides a KeywordMapping and proposal*/\\n/* suitable for `offerTo()`, and an invitation.*/\\n/**/\\n/* Once collateral has been sold using the contract, we burn the amount*/\\n/* necessary to cover the debt and return the remainder.*/\\nasync function liquidate(\\nzcf,\\nvaultKit,\\nburnLosses,\\nstrategy,\\ncollateralBrand)\\n{\\n  const runDebt = vaultKit.vault.getDebtAmount();\\n  const { runBrand } = runDebt.brand;\\n\\n  const vaultSeat = vaultKit.vaultSeat;\\n  const collateralToSell = vaultSeat.getAmountAllocated(\\n  'Collateral',\\n  collateralBrand);\\n\\n  const { deposited, userSeatPromise: liqSeat } = await zoeHelpers.offerTo(\\n  zcf,\\n  strategy.makeInvitation(runDebt),\\n  strategy.keywordMapping(),\\n  strategy.makeProposal(collateralToSell, runDebt),\\n  vaultSeat);\\n\\n  trace(` offeredTo`, runDebt);\\n\\n  /* await deposited, but we don't need the value.*/\\n  await Promise.all([deposited, noShim.E(liqSeat).getOfferResult()]);\\n\\n  /* Now we need to know how much was sold so we can pay off the debt*/\\n  const runProceedsAmount = vaultSeat.getAmountAllocated('RUN', runBrand);\\n\\n  trace('RUN PROCEEDS', runProceedsAmount);\\n\\n  const otherRunProceedsAmount = await noShim.E(liqSeat).getCurrentAllocation();\\n  trace('other proceeds', otherRunProceedsAmount);\\n\\n  const isUnderwater = !amountMath.AmountMath.isGTE(runProceedsAmount, runDebt);\\n  const runToBurn = isUnderwater ? runProceedsAmount : runDebt;\\n  burnLosses({ RUN: runToBurn }, vaultSeat);\\n  vaultKit.liquidated(amountMath.AmountMath.subtract(runDebt, runToBurn));\\n\\n  /* any remaining RUN plus anything else leftover from the sale are refunded*/\\n  vaultSeat.exit();}\\n\\n\\n/* The default strategy converts of all the collateral to RUN using autoswap,*/\\n/* and refunds any excess RUN.*/\\nfunction makeDefaultLiquidationStrategy(autoswap) {\\n  function keywordMapping() {\\n    return harden({\\n      Collateral: 'In',\\n      RUN: 'Out' });}\\n\\n\\n\\n  function makeProposal(collateral, run) {\\n    return harden({\\n      give: { In: collateral },\\n      want: { Out: amountMath.AmountMath.makeEmptyFromAmount(run) } });}\\n\\n\\n\\n  trace(`return from makeDefault`);\\n\\n  return {\\n    makeInvitation: () => noShim.E(autoswap).makeSwapInInvitation(),\\n    keywordMapping,\\n    makeProposal };}exports.liquidate = liquidate;exports.makeDefaultLiquidationStrategy = makeDefaultLiquidationStrategy;\",\n  \"packages/treasury/src/makeTracer.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });let debugInstance = 1;\\n\\nfunction makeTracer(name) {\\n  debugInstance += 1;\\n  let debugCount = 1;\\n  const key = `----- ${name}.${debugInstance} `;\\n  function debugTick(...args) {\\n    console.log(key, debugCount += 1, ...args);}\\n\\n  return debugTick;}exports.makeTracer = makeTracer;\",\n  \"packages/treasury/src/prioritizedVaults.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });require('../../notifier/src/index.js');require('../../zoe/src/contractSupport/index.js');var assert = require('../../assert/src/assert.js');require('../../ERTP/src/index.js');var safeMath = require('../../zoe/src/contractSupport/safeMath.js');var amountMath = require('../../ERTP/src/amountMath.js');var ratio = require('../../zoe/src/contractSupport/ratio.js');var asyncIterableAdaptor = require('../../notifier/src/asyncIterableAdaptor.js'); /* @ts-check*/\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nconst { multiply, isGTE } = safeMath.natSafeMath;\\n\\n/* Stores a collection of Vaults, pretending to be indexed by ratio of*/\\n/* debt to collateral. Once performance is an issue, this should use Virtual*/\\n/* Objects. For now, it uses a Map (Vault->debtToCollateral).*/\\n/* debtToCollateral (which is not the collateralizationRatio) is updated using*/\\n/* an observer on the UIState.*/\\n\\nfunction ratioGTE(left, right) {\\n  assert.assert(\\n  left.numerator.brand === right.numerator.brand &&\\n  left.denominator.brand === right.denominator.brand,\\n  `brands must match`);\\n\\n  return isGTE(\\n  multiply(left.numerator.value, right.denominator.value),\\n  multiply(right.numerator.value, left.denominator.value));}\\n\\n\\n\\nfunction calculateDebtToCollateral(debtAmount, collateralAmount) {\\n  if (amountMath.AmountMath.isEmpty(collateralAmount)) {\\n    return ratio.makeRatioFromAmounts(\\n    debtAmount,\\n    amountMath.AmountMath.make(1n, collateralAmount.brand));}\\n\\n\\n  return ratio.makeRatioFromAmounts(debtAmount, collateralAmount);}\\n\\n\\nfunction currentDebtToCollateral(vaultKit) {\\n  return calculateDebtToCollateral(\\n  vaultKit.vault.getDebtAmount(),\\n  vaultKit.vault.getCollateralAmount());}\\n\\n\\n\\nfunction compareVaultKits(leftVaultPair, rightVaultPair) {\\n  const leftVaultRatio = leftVaultPair.debtToCollateral;\\n  const rightVaultRatio = rightVaultPair.debtToCollateral;\\n  const leftGTERight = ratioGTE(leftVaultRatio, rightVaultRatio);\\n  const rightGTEleft = ratioGTE(rightVaultRatio, leftVaultRatio);\\n  if (leftGTERight && rightGTEleft) {\\n    return 0;} else\\n  if (leftGTERight) {\\n    return -1;} else\\n  if (rightGTEleft) {\\n    return 1;}\\n\\n  throw Error(\\\"The vault's collateral ratios are not comparable\\\");}\\n\\n\\n/* makePrioritizedVaults() takes a function parameter, which will be called when*/\\n/* there is a new least-collateralized vault.*/\\n\\nfunction makePrioritizedVaults(reschedulePriceCheck) {\\n  /* Each entry is [Vault, debtToCollateralRatio]. The array must be resorted on*/\\n  /* every insert, and whenever any vault's ratio changes. We can remove an*/\\n  /* arbitrary number of vaults from the front of the list without resorting. We*/\\n  /* delete single entries using filter(), which leaves the array sorted.*/\\n  let vaultsWithDebtRatio = [];\\n\\n  /* To deal with fluctuating prices and varying collateralization, we schedule a*/\\n  /* new request to the priceAuthority when some vault's debtToCollateral ratio*/\\n  /* surpasses the current high-water mark. When the request that is at the*/\\n  /* current high-water mark fires, we reschedule at the new highest ratio*/\\n  /* (which should be lower, as we will have liquidated any that were at least*/\\n  /* as high.)*/\\n  let highestDebtToCollateral;\\n\\n  /* Check if this ratio of debt to collateral would be the highest known. If*/\\n  /* so, reset our highest and invoke the callback. This can be called on new*/\\n  /* vaults and when we get a state update for a vault changing balances.*/\\n  function rescheduleIfHighest(collateralToDebt) {\\n    if (\\n    !highestDebtToCollateral ||\\n    !ratioGTE(highestDebtToCollateral, collateralToDebt))\\n    {\\n      highestDebtToCollateral = collateralToDebt;\\n      reschedulePriceCheck();}}\\n\\n\\n\\n  function highestRatio() {\\n    const mostIndebted = vaultsWithDebtRatio[0];\\n    return mostIndebted ? mostIndebted.debtToCollateral : undefined;}\\n\\n\\n  function removeVault(vaultKit) {\\n    vaultsWithDebtRatio = vaultsWithDebtRatio.filter(\\n    (v) => v.vaultKit !== vaultKit);\\n\\n    /* don't call reschedulePriceCheck, but do reset the highest.*/\\n    highestDebtToCollateral = highestRatio();}\\n\\n\\n  function updateDebtRatio(vaultKit, debtRatio) {\\n    vaultsWithDebtRatio.forEach((vaultPair, index) => {\\n      if (vaultPair.vaultKit === vaultKit) {\\n        vaultsWithDebtRatio[index].debtToCollateral = debtRatio;}});}\\n\\n\\n\\n\\n  /* called after charging interest, which changes debts without affecting sort*/\\n  function updateAllDebts() {\\n    vaultsWithDebtRatio.forEach((vaultPair, index) => {\\n      const debtToCollateral = currentDebtToCollateral(vaultPair.vaultKit);\\n      vaultsWithDebtRatio[index].debtToCollateral = debtToCollateral;});\\n\\n    highestDebtToCollateral = highestRatio();}\\n\\n\\n  function makeObserver(vaultKit) {\\n    return {\\n      updateState: (state) => {\\n        if (amountMath.AmountMath.isEmpty(state.locked)) {\\n          return;}\\n\\n        const debtToCollateral = currentDebtToCollateral(vaultKit);\\n        updateDebtRatio(vaultKit, debtToCollateral);\\n        vaultsWithDebtRatio.sort(compareVaultKits);\\n        rescheduleIfHighest(debtToCollateral);},\\n\\n      finish: (_) => {\\n        removeVault(vaultKit);},\\n\\n      fail: (_) => {\\n        removeVault(vaultKit);} };}\\n\\n\\n\\n\\n  function addVaultKit(vaultKit, notifier) {\\n    const debtToCollateral = currentDebtToCollateral(vaultKit);\\n    vaultsWithDebtRatio.push({ vaultKit, debtToCollateral });\\n    vaultsWithDebtRatio.sort(compareVaultKits);\\n    asyncIterableAdaptor.observeNotifier(notifier, makeObserver(vaultKit));\\n    rescheduleIfHighest(debtToCollateral);}\\n\\n\\n  /* Invoke a function for vaults with debt to collateral at or above the ratio*/\\n  function forEachRatioGTE(ratio, func) {\\n    /* vaults are sorted with highest ratios first*/\\n    let index;\\n    for (index = 0; index < vaultsWithDebtRatio.length; index += 1) {\\n      const vaultPair = vaultsWithDebtRatio[index];\\n      if (ratioGTE(vaultPair.debtToCollateral, ratio)) {\\n        func(vaultPair);} else\\n      {\\n        /* stop once we are below the target ratio*/\\n        break;}}\\n\\n\\n\\n    if (index > 0) {\\n      vaultsWithDebtRatio = vaultsWithDebtRatio.slice(index);\\n      const highest = highestRatio();\\n      if (highest) {\\n        reschedulePriceCheck();}}\\n\\n\\n    highestDebtToCollateral = highestRatio();}\\n\\n\\n  function map(func) {\\n    return vaultsWithDebtRatio.map(func);}\\n\\n\\n  function reduce(func, init = undefined) {\\n    return vaultsWithDebtRatio.reduce(func, init);}\\n\\n\\n  return harden({\\n    addVaultKit,\\n    removeVault,\\n    map,\\n    reduce,\\n    forEachRatioGTE,\\n    highestRatio: () => highestDebtToCollateral,\\n    updateAllDebts });}exports.makePrioritizedVaults = makePrioritizedVaults;\",\n  \"packages/treasury/src/stablecoinMachine.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });require('../../zoe/exported.js');require('../../zoe/src/contracts/exported.js');var noShim = require('../../eventual-send/src/no-shim.js');var assert = require('../../assert/src/assert.js');require('../../store/src/index.js');require('../../zoe/src/contractSupport/index.js');var ratio = require('../../zoe/src/contractSupport/ratio.js');require('../../ERTP/src/index.js');var makeTracer = require('./makeTracer.js');var vaultManager = require('./vaultManager.js');var liquidateMinimum = require('./liquidateMinimum.js');var collectRewardFees = require('./collectRewardFees.js');var store = require('../../store/src/store.js');var zoeHelpers = require('../../zoe/src/contractSupport/zoeHelpers.js');var amountMath = require('../../ERTP/src/amountMath.js');var priceQuote = require('../../zoe/src/contractSupport/priceQuote.js'); /* @ts-check*/\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nconst trace = makeTracer.makeTracer('ST');\\n\\n/** @type {ContractStartFn} */\\nasync function start(zcf) {\\n  /* loanParams has time limits for charging interest*/\\n  const {\\n    autoswapInstall,\\n    priceAuthority,\\n    loanParams,\\n    timerService,\\n    liquidationInstall,\\n    bootstrapPaymentValue = 0n } =\\n  zcf.getTerms();\\n\\n  assert.assert.typeof(\\n  loanParams.chargingPeriod,\\n  'bigint',\\n  assert.details`chargingPeriod (${assert.quote(loanParams.chargingPeriod)}) must be a BigInt`);\\n\\n  assert.assert.typeof(\\n  loanParams.recordingPeriod,\\n  'bigint',\\n  assert.details`recordingPeriod (${assert.quote(\\n  loanParams.recordingPeriod)\\n  }) must be a BigInt`);\\n\\n\\n  const [runMint, govMint] = await Promise.all([\\n  zcf.makeZCFMint('RUN', undefined, harden({ decimalPlaces: 6 })),\\n  zcf.makeZCFMint('Governance', undefined, harden({ decimalPlaces: 6 }))]);\\n\\n  const { issuer: runIssuer, brand: runBrand } = runMint.getIssuerRecord();\\n\\n  const { brand: govBrand } = govMint.getIssuerRecord();\\n\\n  /* This is a stand-in for a reward pool. For now, it's a place to squirrel*/\\n  /* away fees so the tests show that the funds have been removed.*/\\n  const { zcfSeat: rewardPoolSeat } = zcf.makeEmptySeatKit();\\n\\n  /**\\n   * We provide an easy way for the vaultManager and vaults to add rewards to\\n   * the rewardPoolSeat, without directly exposing the rewardPoolSeat to them.\\n   *\\n   * @type {ReallocateReward}\\n   */\\n  function reallocateReward(amount, fromSeat, otherSeat = undefined) {\\n    rewardPoolSeat.incrementBy(\\n    fromSeat.decrementBy({\\n      RUN: amount }));\\n\\n\\n    if (otherSeat !== undefined) {\\n      zcf.reallocate(rewardPoolSeat, fromSeat, otherSeat);} else\\n    {\\n      zcf.reallocate(rewardPoolSeat, fromSeat);}}\\n\\n\\n\\n  /** @type {Store<Brand,VaultManager>} */\\n  const collateralTypes = store.makeStore(); /* Brand -> vaultManager*/\\n\\n  const zoe = zcf.getZoeService();\\n\\n  /* we assume the multipool-autoswap is public, so folks can buy/sell*/\\n  /* through it without our involvement*/\\n  /* Should it use creatorFacet, creatorInvitation, instance?*/\\n  /** @type {{ publicFacet: MultipoolAutoswapPublicFacet, instance: Instance,\\n   *  creatorFacet: MultipoolAutoswapCreatorFacet }} */\\n  const {\\n    publicFacet: autoswapAPI,\\n    instance: autoswapInstance,\\n    creatorFacet: autoswapCreatorFacet } =\\n  await noShim.E(zoe).startInstance(\\n  autoswapInstall,\\n  { Central: runIssuer },\\n  {\\n    timer: timerService,\\n    poolFee: loanParams.poolFee,\\n    protocolFee: loanParams.protocolFee });\\n\\n\\n\\n  /* We process only one offer per collateralType. They must tell us the*/\\n  /* dollar value of their collateral, and we create that many RUN.*/\\n  /* collateralKeyword = 'aEth'*/\\n  async function makeAddTypeInvitation(\\n  collateralIssuer,\\n  collateralKeyword,\\n  rates)\\n  {\\n    await zcf.saveIssuer(collateralIssuer, collateralKeyword);\\n    const collateralBrand = zcf.getBrandForIssuer(collateralIssuer);\\n    assert.assert(!collateralTypes.has(collateralBrand));\\n\\n    const { creatorFacet: liquidationFacet } = await noShim.E(zoe).startInstance(\\n    liquidationInstall,\\n    { RUN: runIssuer },\\n    { autoswap: autoswapAPI });\\n\\n\\n    async function addTypeHook(seat) {\\n      zoeHelpers.assertProposalShape(seat, {\\n        give: { Collateral: null },\\n        want: { Governance: null } });\\n\\n      const {\\n        give: { Collateral: collateralIn },\\n        want: { Governance: _govOut } /* ownership of the whole stablecoin machine*/ } =\\n      seat.getProposal();\\n      assert.assert(!collateralTypes.has(collateralBrand));\\n      const runAmount = ratio.multiplyBy(collateralIn, rates.initialPrice);\\n      /* arbitrarily, give governance tokens equal to RUN tokens*/\\n      const govAmount = amountMath.AmountMath.make(runAmount.value, govBrand);\\n\\n      /* Create new governance tokens, trade them with the incoming offer for*/\\n      /* collateral. The offer uses the keywords Collateral and Governance.*/\\n      /* govSeat stores the collateral as Secondary. We then mint new RUN for*/\\n      /* govSeat and store them as Central. govSeat then creates a liquidity*/\\n      /* pool for autoswap, trading in Central and Secondary for governance*/\\n      /* tokens as Liquidity. These governance tokens are held by govSeat*/\\n      const { zcfSeat: govSeat } = zcf.makeEmptySeatKit();\\n      /* TODO this should create the seat for us*/\\n      govMint.mintGains({ Governance: govAmount }, govSeat);\\n\\n      /* trade the governance tokens for collateral, putting the*/\\n      /* collateral on Secondary to be positioned for Autoswap*/\\n      seat.incrementBy(govSeat.decrementBy({ Governance: govAmount }));\\n      seat.decrementBy({ Collateral: collateralIn });\\n      govSeat.incrementBy({ Secondary: collateralIn });\\n\\n      zcf.reallocate(govSeat, seat);\\n      /* the collateral is now on the temporary seat*/\\n\\n      /* once we've done that, we can put both the collateral and the minted*/\\n      /* RUN into the autoswap, giving us liquidity tokens, which we store*/\\n\\n      /* mint the new RUN to the Central position on the govSeat*/\\n      /* so we can setup the autoswap pool*/\\n      runMint.mintGains({ Central: runAmount }, govSeat);\\n\\n      /* TODO: check for existing pool, use its price instead of the*/\\n      /* user-provided 'rate'. Or throw an error if it already exists.*/\\n      /* `addPool` should combine initial liquidity with pool setup*/\\n\\n      const liquidityIssuer = await noShim.E(autoswapAPI).addPool(\\n      collateralIssuer,\\n      collateralKeyword);\\n\\n      const { brand: liquidityBrand } = await zcf.saveIssuer(\\n      liquidityIssuer,\\n      `${collateralKeyword}_Liquidity`);\\n\\n\\n      /* inject both the collateral and the RUN into the new autoswap, to*/\\n      /* provide the initial liquidity pool*/\\n      const liqProposal = harden({\\n        give: {\\n          Secondary: collateralIn,\\n          Central: runAmount },\\n\\n        want: { Liquidity: amountMath.AmountMath.makeEmpty(liquidityBrand) } });\\n\\n      const liqInvitation = noShim.E(autoswapAPI).makeAddLiquidityInvitation();\\n\\n      const { deposited } = await zoeHelpers.offerTo(\\n      zcf,\\n      liqInvitation,\\n      undefined,\\n      liqProposal,\\n      govSeat);\\n\\n\\n      const depositValue = await deposited;\\n\\n      /* TODO(hibbert): make use of these assets (Liquidity: 19899 Aeth)*/\\n      trace('depositValue', depositValue);\\n\\n      const liquidationStrategy = liquidateMinimum.makeLiquidationStrategy(liquidationFacet);\\n\\n      /* do something with the liquidity we just bought*/\\n      const vm = vaultManager.makeVaultManager(\\n      zcf,\\n      autoswapAPI,\\n      runMint,\\n      collateralBrand,\\n      priceAuthority,\\n      rates,\\n      reallocateReward,\\n      timerService,\\n      loanParams,\\n      liquidationStrategy);\\n\\n      collateralTypes.init(collateralBrand, vm);\\n      return vm;}\\n\\n\\n    return zcf.makeInvitation(addTypeHook, 'AddCollateralType');}\\n\\n\\n  /**\\n   * Make a loan in the vaultManager based on the collateral type.\\n   */\\n  function makeLoanInvitation() {\\n    /**\\n     * @param {ZCFSeat} seat\\n     */\\n    async function makeLoanHook(seat) {\\n      zoeHelpers.assertProposalShape(seat, {\\n        give: { Collateral: null },\\n        want: { RUN: null } });\\n\\n      const {\\n        give: { Collateral: collateralAmount } } =\\n      seat.getProposal();\\n      const { brand: brandIn } = collateralAmount;\\n      assert.assert(\\n      collateralTypes.has(brandIn),\\n      assert.details`Not a supported collateral type ${brandIn}`);\\n\\n      /** @type {VaultManager} */\\n      const mgr = collateralTypes.get(brandIn);\\n      return mgr.makeLoanKit(seat);}\\n\\n\\n    return zcf.makeInvitation(makeLoanHook, 'MakeLoan');}\\n\\n\\n  zcf.setTestJig(() => ({\\n    runIssuerRecord: runMint.getIssuerRecord(),\\n    govIssuerRecord: govMint.getIssuerRecord(),\\n    autoswap: autoswapAPI }));\\n\\n\\n  async function getCollaterals() {\\n    /* should be collateralTypes.map((vm, brand) => ({*/\\n    return harden(\\n    Promise.all(\\n    collateralTypes.entries().map(async ([brand, vm]) => {\\n      const priceQuote$1 = await vm.getCollateralQuote();\\n      return {\\n        brand,\\n        interestRate: vm.getInterestRate(),\\n        liquidationMargin: vm.getLiquidationMargin(),\\n        initialMargin: vm.getInitialMargin(),\\n        stabilityFee: vm.getLoanFee(),\\n        marketPrice: ratio.makeRatioFromAmounts(\\n        priceQuote.getAmountOut(priceQuote$1),\\n        priceQuote.getAmountIn(priceQuote$1)) };})));}\\n\\n\\n\\n\\n\\n\\n\\n  /* Eventually the reward pool will live elsewhere. For now it's here for*/\\n  /* bookkeeping. It's needed in tests.*/\\n  function getRewardAllocation() {\\n    return rewardPoolSeat.getCurrentAllocation();}\\n\\n\\n  function mintBootstrapPayment() {\\n    const {\\n      zcfSeat: bootstrapZCFSeat,\\n      userSeat: bootstrapUserSeat } =\\n    zcf.makeEmptySeatKit();\\n    runMint.mintGains(\\n    {\\n      Bootstrap: amountMath.AmountMath.make(runBrand, bootstrapPaymentValue) },\\n\\n    bootstrapZCFSeat);\\n\\n    bootstrapZCFSeat.exit();\\n    const bootstrapPayment = noShim.E(bootstrapUserSeat).getPayout('Bootstrap');\\n\\n    function getBootstrapPayment() {\\n      return bootstrapPayment;}\\n\\n    return getBootstrapPayment;}\\n\\n\\n  const getBootstrapPayment = mintBootstrapPayment();\\n\\n  const publicFacet = harden({\\n    getAMM() {\\n      return autoswapInstance;},\\n\\n    makeLoanInvitation,\\n    getCollaterals,\\n    /* TODO this is in the terms, so could be retrieved from there.*/\\n    /* This API is here to consider for usability/discoverability*/\\n    getRunIssuer() {\\n      return runIssuer;} });\\n\\n\\n\\n  const { makeCollectFeesInvitation } = collectRewardFees.makeMakeCollectFeesInvitation(\\n  zcf,\\n  rewardPoolSeat,\\n  autoswapCreatorFacet,\\n  runBrand);\\n\\n\\n  /** @type {StablecoinMachine} */\\n  const stablecoinMachine = harden({\\n    makeAddTypeInvitation,\\n    getAMM() {\\n      return autoswapInstance;},\\n\\n    getCollaterals,\\n    getRewardAllocation,\\n    getBootstrapPayment,\\n    makeCollectFeesInvitation });\\n\\n\\n  return harden({ creatorFacet: stablecoinMachine, publicFacet });}exports.start = start;\",\n  \"packages/treasury/src/types.js\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n'use strict'; /* @ts-check*/ /**\\n * @typedef  {Object} AutoswapLocal\\n * @property {(amount: Amount, brand: Brand) => Amount} getInputPrice\\n * @property {() => Invitation} makeSwapInvitation\\n */ /**\\n * @typedef {Object} Collateral\\n * @property {Ratio} initialMargin\\n * @property {Ratio} liquidationMargin\\n * @property {Ratio} stabilityFee\\n * @property {Ratio} marketPrice\\n * @property {Brand} brand\\n */ /**\\n * @typedef {Object} Rates\\n * @property {Ratio} initialMargin minimum required over-collateralization\\n * required to open a loan\\n * @property {Ratio} liquidationMargin margin below which collateral will be\\n * liquidated to satisfy the debt.\\n * @property {Ratio} initialPrice price ratio of collateral to RUN\\n * @property {Ratio} interestRate - annual interest rate charged on loans\\n * @property {Ratio} loanFee The fee (in BasisPoints) charged when opening\\n * or increasing a loan.\\n */ /**\\n * @typedef  {Object} StablecoinMachine\\n * @property {(collateralIssuer: Issuer, collateralKeyword: Keyword, rates: Rates) => Promise<Invitation>} makeAddTypeInvitation\\n * @property {() => Instance} getAMM\\n * @property {() => Promise<Array<Collateral>>} getCollaterals\\n */ /**\\n * @typedef {Object} UIState\\n * @property {Ratio} interestRate Annual interest rate charge\\n * @property {Ratio} liquidationRatio\\n * @property {Amount} locked Amount of Collateral locked\\n * @property {Amount} debt Amount of Loan (including accrued interest)\\n * @property {Ratio} collateralizationRatio\\n * @property {boolean} liquidated boolean showing whether liquidation occurred\\n */ /**\\n * @callback ReallocateReward\\n *\\n * Transfer the indicated amount to the stablecoin machine's reward\\n * pool, taken from the `fromSeat`. Then reallocate over all the seat\\n * arguments and the rewardPoolSeat.\\n *\\n * @param {Amount} amount\\n * @param {ZCFSeat} fromSeat\\n * @param {ZCFSeat=} otherSeat\\n * @returns {void}\\n */ /**\\n * @typedef {Object} InnerVaultManager\\n * @property {Brand} collateralBrand\\n * @property {() => Ratio} getLiquidationMargin\\n * @property {() => Ratio} getLoanFee\\n * @property {() => Promise<PriceQuote>} getCollateralQuote\\n * @property {() => Ratio} getInitialMargin\\n * @property {() => Ratio} getInterestRate - The annual interest rate on a loan\\n * @property {ReallocateReward} reallocateReward\\n */ /**\\n * @typedef {Object} VaultManager\\n * @property {(ZCFSeat) => Promise<LoanKit>}  makeLoanKit\\n * @property {() => void} liquidateAll\\n * @property {() => Ratio} getLiquidationMargin\\n * @property {() => Ratio} getLoanFee\\n * @property {() => Promise<PriceQuote>} getCollateralQuote\\n * @property {() => Ratio} getInitialMargin\\n * @property {() => Ratio} getInterestRate\\n */ /**\\n * @typedef {Object} OpenLoanKit\\n * @property {Notifier<UIState>} notifier\\n * @property {Promise<PaymentPKeywordRecord>} collateralPayoutP\\n */ /**\\n * @typedef {Object} Vault\\n * @property {() => Promise<Invitation>} makeAdjustBalancesInvitation\\n * @property {() => Promise<Invitation>} makeCloseInvitation\\n * @property {() => Amount} getCollateralAmount\\n * @property {() => Amount} getDebtAmount\\n */ /**\\n * @typedef {Object} LoanKit\\n * @property {Vault} vault\\n * @property {Promise<PaymentPKeywordRecord>} liquidationPayout\\n * @property {Notifier<UIState>} uiNotifier\\n */ /**\\n * @typedef {Object} VaultKit\\n * @property {Vault} vault\\n * @property {(ZCFSeat) => Promise<OpenLoanKit>} openLoan\\n * @property {(Timestamp) => Amount} accrueInterestAndAddToPool\\n */ /**\\n * @typedef {Object} LoanParams\\n * @property {RelativeTime} chargingPeriod\\n * @property {RelativeTime} recordingPeriod\\n */ /**\\n * @typedef {Object} LiquidationStrategy\\n * @property {() => KeywordKeywordRecord} keywordMapping\\n * @property {(collateral: Amount, RUN: Amount) => Proposal} makeProposal\\n * @property {() => Promise<Invitation>} makeInvitation\\n */ /**\\n * @callback MakeVaultManager\\n * @param {ContractFacet} zcf\\n * @param {ERef<MultipoolAutoswapPublicFacet>} autoswap\\n * @param {ZCFMint} runMint\\n * @param {Brand} collateralBrand\\n * @param {ERef<PriceAuthority>} priceAuthority\\n * @param {Rates} rates\\n * @param {StageReward} rewardPoolStaging\\n * @param {TimerService} timerService\\n * @param {LoanParams} loanParams\\n * @param {LiquidationStrategy} liquidationStrategy\\n * @returns {VaultManager}\\n */ /**\\n * @callback MakeVaultKit\\n * @param {ContractFacet} zcf\\n * @param {InnerVaultManager} manager\\n * @param {ZCFMint} runMint\\n * @param {ERef<MultipoolAutoswapPublicFacet>} autoswap\\n * @param {ERef<PriceAuthority>} priceAuthority\\n * @param {LoanParams} loanParams\\n * @param {Timestamp} startTimeStamp\\n * @returns {VaultKit}\\n */ /**\\n * @typedef {Object} DebtStatus\\n * @property {Timestamp} latestInterestUpdate\\n * @property {Amount} interest\\n * @property {Amount} newDebt\\n */ /**\\n * @callback Calculate\\n * @param {DebtStatus} debtStatus\\n * @param {Timestamp} currentTime\\n * @returns {DebtStatus}\\n */ /**\\n * @typedef {Object} CalculatorKit\\n * @property {Calculate} calculate calculate new debt for charging periods up to\\n * the present.\\n * @property {Calculate} calculateReportingPeriod calculate new debt for\\n * reporting periods up to the present. If some charging periods have elapsed\\n * that don't constitute whole reporting periods, the time is not updated past\\n * them and interest is not accumulated for them.\\n */ /**\\n * @callback MakeInterestCalculator\\n * @param {Brand} brand\\n * @param {Ratio} rate\\n * @param {RelativeTime} chargingPeriod\\n * @param {RelativeTime} recordingPeriod\\n * @returns {CalculatorKit}\\n */\",\n  \"packages/treasury/src/vault.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });require('../../zoe/exported.js');var assert = require('../../assert/src/assert.js');var noShim = require('../../eventual-send/src/no-shim.js');require('../../zoe/src/contractSupport/index.js');require('../../notifier/src/index.js');var ratio = require('../../zoe/src/contractSupport/ratio.js');require('../../ERTP/src/index.js');var makeTracer = require('./makeTracer.js');var interest = require('./interest.js');var notifier = require('../../notifier/src/notifier.js');var amountMath = require('../../ERTP/src/amountMath.js');var priceQuote = require('../../zoe/src/contractSupport/priceQuote.js');var\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nzoeHelpers = require('../../zoe/src/contractSupport/zoeHelpers.js'); /* @ts-check*/ /* a Vault is an individual loan, using some collateralType as the*/ /* collateral, and lending RUN to the borrower*/ /** @type {MakeVaultKit} */\\nfunction makeVaultKit(\\nzcf,\\nmanager,\\nrunMint,\\nautoswap,\\npriceAuthority,\\nloanParams,\\nstartTimeStamp)\\n{\\n  const trace = makeTracer.makeTracer('VV');\\n  const { updater: uiUpdater, notifier: notifier$1 } = notifier.makeNotifierKit();\\n\\n  let active = true; /* liquidation halts all user actions*/\\n\\n  function assertVaultIsOpen() {\\n    assert.assert(active, 'vault must still be active');}\\n\\n\\n  const collateralBrand = manager.collateralBrand;\\n  /* timestamp of most recent update to interest*/\\n  let latestInterestUpdate = startTimeStamp;\\n\\n  /* vaultSeat will hold the collateral until the loan is retired. The*/\\n  /* payout from it will be handed to the user: if the vault dies early*/\\n  /* (because the StableCoinMachine vat died), they'll get all their*/\\n  /* collateral back. If that happens, the issuer for the RUN will be dead,*/\\n  /* so their loan will be worthless.*/\\n  const { zcfSeat: vaultSeat, userSeat } = zcf.makeEmptySeatKit();\\n\\n  trace('vaultSeat proposal', vaultSeat.getProposal());\\n\\n  const { brand: runBrand } = runMint.getIssuerRecord();\\n  let runDebt = amountMath.AmountMath.makeEmpty(runBrand);\\n  const interestCalculator = interest.makeInterestCalculator(\\n  runBrand,\\n  manager.getInterestRate(),\\n  loanParams.chargingPeriod,\\n  loanParams.recordingPeriod);\\n\\n\\n  function getCollateralAllocated(seat) {\\n    return seat.getAmountAllocated('Collateral', collateralBrand);}\\n\\n  function getRunAllocated(seat) {\\n    return seat.getAmountAllocated('RUN', runBrand);}\\n\\n\\n  function assertVaultHoldsNoRun() {\\n    assert.assert(\\n    amountMath.AmountMath.isEmpty(getRunAllocated(vaultSeat)),\\n    assert.details`Vault should be empty of RUN`);}\\n\\n\\n\\n  async function maxDebtFor(collateralAmount) {\\n    const quoteAmount = await noShim.E(priceAuthority).quoteGiven(\\n    collateralAmount,\\n    runBrand);\\n\\n\\n    return ratio.divideBy(priceQuote.getAmountOut(quoteAmount), manager.getLiquidationMargin());}\\n\\n\\n  async function assertSufficientCollateral(collateralAmount, wantedRun) {\\n    const maxRun = await maxDebtFor(collateralAmount);\\n    assert.assert(\\n    amountMath.AmountMath.isGTE(maxRun, wantedRun, runBrand),\\n    assert.details`Requested ${assert.quote(wantedRun)} exceeds max ${assert.quote(maxRun)}`);}\\n\\n\\n\\n  function getCollateralAmount() {\\n    /* getCollateralAllocated would return final allocations*/\\n    return vaultSeat.hasExited() ?\\n    amountMath.AmountMath.makeEmpty(collateralBrand) :\\n    getCollateralAllocated(vaultSeat);}\\n\\n\\n  async function getCollateralizationRatio() {\\n    const collateralAmount = getCollateralAmount();\\n    /* TODO: allow Ratios to represent X/0.*/\\n    if (amountMath.AmountMath.isEmpty(runDebt)) {\\n      return ratio.makeRatio(collateralAmount.value, runBrand, 1n);}\\n\\n\\n    const quoteAmount = await noShim.E(priceAuthority).quoteGiven(\\n    collateralAmount,\\n    runBrand);\\n\\n    const collateralValueInRun = priceQuote.getAmountOut(quoteAmount);\\n    return ratio.makeRatioFromAmounts(collateralValueInRun, runDebt);}\\n\\n\\n  /* call this whenever anything changes!*/\\n  async function updateUiState() {\\n    /* TODO(123): track down all calls and ensure that they all update a*/\\n    /* lastKnownCollateralizationRatio (since they all know) so we don't have to*/\\n    /* await quoteGiven() here*/\\n    /* [https://github.com/Agoric/dapp-token-economy/issues/123]*/\\n    const collateralizationRatio = await getCollateralizationRatio();\\n    /** @type {UIState} */\\n    const uiState = harden({\\n      interestRate: manager.getInterestRate(),\\n      liquidationRatio: manager.getLiquidationMargin(),\\n      locked: getCollateralAmount(),\\n      debt: runDebt,\\n      collateralizationRatio,\\n      liquidated: !active });\\n\\n\\n    if (active) {\\n      uiUpdater.updateState(uiState);} else\\n    {\\n      uiUpdater.finish(uiState);}}\\n\\n\\n\\n  function liquidated(newDebt) {\\n    runDebt = newDebt;\\n    active = false;\\n    updateUiState();}\\n\\n\\n  /** @type {OfferHandler} */\\n  async function closeHook(seat) {\\n    assertVaultIsOpen();\\n    zoeHelpers.assertProposalShape(seat, {\\n      give: { RUN: null },\\n      want: { Collateral: null } });\\n\\n    const {\\n      give: { RUN: runReturned },\\n      want: { Collateral: _collateralWanted } } =\\n    seat.getProposal();\\n\\n    /* you're paying off the debt, you get everything back. If you were*/\\n    /* underwater, we should have liquidated some collateral earlier: we*/\\n    /* missed our chance.*/\\n\\n    /* you must pay off the entire remainder but if you offer too much, we won't*/\\n    /* take more than you owe*/\\n    assert.assert(amountMath.AmountMath.isGTE(runReturned, runDebt));\\n\\n    /* Return any overpayment*/\\n    vaultSeat.incrementBy(seat.decrementBy({ RUN: runDebt }));\\n    seat.incrementBy(\\n    vaultSeat.decrementBy({ Collateral: getCollateralAllocated(vaultSeat) }));\\n\\n    zcf.reallocate(seat, vaultSeat);\\n\\n    seat.exit();\\n    runDebt = amountMath.AmountMath.makeEmpty(runBrand);\\n    active = false;\\n    updateUiState();\\n\\n    runMint.burnLosses({ RUN: runDebt }, vaultSeat);\\n    vaultSeat.exit();\\n\\n    return 'your loan is closed, thank you for your business';}\\n\\n\\n  function makeCloseInvitation() {\\n    assertVaultIsOpen();\\n    return zcf.makeInvitation(closeHook, 'CloseVault');}\\n\\n\\n  /* The proposal is not allowed to include any keys other than these,*/\\n  /* usually 'Collateral' and 'RUN'.*/\\n  function assertOnlyKeys(proposal, keys) {\\n    function onlyKeys(clause) {\\n      return Object.getOwnPropertyNames(clause).every((c) => keys.includes(c));}\\n\\n\\n    assert.assert(\\n    onlyKeys(proposal.give),\\n    assert.details`extraneous terms in give: ${proposal.give}`);\\n\\n    assert.assert(\\n    onlyKeys(proposal.want),\\n    assert.details`extraneous terms in want: ${proposal.want}`);}\\n\\n\\n\\n  /* Calculate the target level for Collateral for the vaultSeat and*/\\n  /* clientSeat implied by the proposal. If the proposal wants Collateral,*/\\n  /* transfer that amount from vault to client. If the proposal gives*/\\n  /* Collateral, transfer the opposite direction. Otherwise, return the current level.*/\\n  function TargetCollateralLevels(seat) {\\n    const proposal = seat.getProposal();\\n    const startVaultAmount = getCollateralAllocated(vaultSeat);\\n    const startClientAmount = getCollateralAllocated(seat);\\n    if (proposal.want.Collateral) {\\n      return {\\n        vault: amountMath.AmountMath.subtract(startVaultAmount, proposal.want.Collateral),\\n        client: amountMath.AmountMath.add(startClientAmount, proposal.want.Collateral) };} else\\n\\n    if (proposal.give.Collateral) {\\n      return {\\n        vault: amountMath.AmountMath.add(startVaultAmount, proposal.give.Collateral),\\n        client: amountMath.AmountMath.subtract(\\n        startClientAmount,\\n        proposal.give.Collateral) };} else\\n\\n\\n    {\\n      return {\\n        vault: startVaultAmount,\\n        client: startClientAmount };}}\\n\\n\\n\\n\\n  function transferCollateral(seat) {\\n    const proposal = seat.getProposal();\\n    if (proposal.want.Collateral) {\\n      seat.incrementBy(\\n      vaultSeat.decrementBy({ Collateral: proposal.want.Collateral }));} else\\n\\n    if (proposal.give.Collateral) {\\n      vaultSeat.incrementBy(\\n      seat.decrementBy({ Collateral: proposal.give.Collateral }));}}\\n\\n\\n\\n\\n  /* Calculate the target RUN level for the vaultSeat and clientSeat implied*/\\n  /* by the proposal. If the proposal wants collateral, transfer that amount*/\\n  /* from vault to client. If the proposal gives collateral, transfer the*/\\n  /* opposite direction. Otherwise, return the current level.*/\\n  /**/\\n  /* Since we don't allow the debt to go negative, we will reduce the amount we*/\\n  /* accept when the proposal says to give more RUN than are owed.*/\\n  function targetRunLevels(seat) {\\n    const clientAllocation = getRunAllocated(seat);\\n    const proposal = seat.getProposal();\\n    if (proposal.want.RUN) {\\n      return {\\n        vault: amountMath.AmountMath.makeEmpty(runBrand),\\n        client: amountMath.AmountMath.add(clientAllocation, proposal.want.RUN) };} else\\n\\n    if (proposal.give.RUN) {\\n      /* We don't allow runDebt to be negative, so we'll refund overpayments*/\\n      const acceptedRun = amountMath.AmountMath.isGTE(proposal.give.RUN, runDebt) ?\\n      runDebt :\\n      proposal.give.RUN;\\n\\n      return {\\n        vault: acceptedRun,\\n        client: amountMath.AmountMath.subtract(clientAllocation, acceptedRun) };} else\\n\\n    {\\n      return {\\n        vault: amountMath.AmountMath.makeEmpty(runBrand),\\n        client: clientAllocation };}}\\n\\n\\n\\n\\n  function transferRun(seat) {\\n    const proposal = seat.getProposal();\\n    if (proposal.want.RUN) {\\n      seat.incrementBy(vaultSeat.decrementBy({ RUN: proposal.want.RUN }));} else\\n    if (proposal.give.RUN) {\\n      /* We don't allow runDebt to be negative, so we'll refund overpayments*/\\n      const acceptedRun = amountMath.AmountMath.isGTE(proposal.give.RUN, runDebt) ?\\n      runDebt :\\n      proposal.give.RUN;\\n\\n      vaultSeat.incrementBy(seat.decrementBy({ RUN: acceptedRun }));}}\\n\\n\\n\\n  /* Calculate the fee, the amount to mint and the resulting debt.*/\\n  function loanFee(proposal, runAfter) {\\n    let newDebt;\\n    let toMint = amountMath.AmountMath.makeEmpty(runBrand);\\n    let fee = amountMath.AmountMath.makeEmpty(runBrand);\\n    if (proposal.want.RUN) {\\n      fee = ratio.multiplyBy(proposal.want.RUN, manager.getLoanFee());\\n      toMint = amountMath.AmountMath.add(proposal.want.RUN, fee);\\n      newDebt = amountMath.AmountMath.add(runDebt, toMint);} else\\n    if (proposal.give.RUN) {\\n      newDebt = amountMath.AmountMath.subtract(runDebt, runAfter.vault);} else\\n    {\\n      newDebt = runDebt;}\\n\\n    return { newDebt, toMint, fee };}\\n\\n\\n  /** @param {ZCFSeat} clientSeat */\\n  async function adjustBalancesHook(clientSeat) {\\n    assertVaultIsOpen();\\n    const proposal = clientSeat.getProposal();\\n\\n    assertOnlyKeys(proposal, ['Collateral', 'RUN']);\\n\\n    const targetCollateralAmount = TargetCollateralLevels(clientSeat).vault;\\n    /* max debt supported by current Collateral as modified by proposal*/\\n    const maxDebtForOriginalTarget = await maxDebtFor(targetCollateralAmount);\\n\\n    const priceOfCollateralInRun = ratio.makeRatioFromAmounts(\\n    maxDebtForOriginalTarget,\\n    targetCollateralAmount);\\n\\n\\n    /* After the AWAIT, we retrieve the vault's allocations again.*/\\n    const collateralAfter = TargetCollateralLevels(clientSeat);\\n    const runAfter = targetRunLevels(clientSeat);\\n\\n    /* Calculate the fee, the amount to mint and the resulting debt. We'll*/\\n    /* verify that the target debt doesn't violate the collateralization ratio,*/\\n    /* then mint, reallocate, and burn.*/\\n    const { fee, toMint, newDebt } = loanFee(proposal, runAfter);\\n\\n    /* Get new balances after calling the priceAuthority, so we can compare*/\\n    /* to the debt limit based on the new values.*/\\n    const vaultCollateral =\\n    collateralAfter.vault || amountMath.AmountMath.makeEmpty(collateralBrand);\\n\\n    /* If the collateral decreased, we pro-rate maxDebt*/\\n    if (amountMath.AmountMath.isGTE(targetCollateralAmount, vaultCollateral)) {\\n      /* We can pro-rate maxDebt because the quote is either linear (price is*/\\n      /* unchanging) or super-linear (meaning it's an AMM. When the volume sold*/\\n      /* falls, the proceeds fall less than linearly, so this is a conservative*/\\n      /* choice.)*/\\n      const maxDebtAfter = ratio.multiplyBy(vaultCollateral, priceOfCollateralInRun);\\n      assert.assert(\\n      amountMath.AmountMath.isGTE(maxDebtAfter, newDebt),\\n      assert.details`The requested debt ${assert.quote(\\n      newDebt)\\n      } is more than the collateralization ratio allows: ${assert.quote(maxDebtAfter)}`);\\n\\n\\n      /* When the re-checked collateral was larger than the original amount, we*/\\n      /* should restart, unless the new debt is less than the original target*/\\n      /* (in which case, we're fine to proceed with the reallocate)*/} else\\n    if (!amountMath.AmountMath.isGTE(maxDebtForOriginalTarget, newDebt)) {\\n      return adjustBalancesHook(clientSeat);}\\n\\n\\n    /* mint to vaultSeat, then reallocate to reward and client, then burn from*/\\n    /* vaultSeat. Would using a separate seat clarify the accounting?*/\\n    runMint.mintGains({ RUN: toMint }, vaultSeat);\\n    transferCollateral(clientSeat);\\n    transferRun(clientSeat);\\n    manager.reallocateReward(fee, vaultSeat, clientSeat);\\n\\n    runDebt = newDebt;\\n    runMint.burnLosses({ RUN: runAfter.vault }, vaultSeat);\\n\\n    assertVaultHoldsNoRun();\\n\\n    updateUiState();\\n    clientSeat.exit();\\n\\n    return 'We have adjusted your balances, thank you for your business';}\\n\\n\\n  function makeAdjustBalancesInvitation() {\\n    assertVaultIsOpen();\\n    return zcf.makeInvitation(adjustBalancesHook, 'AdjustBalances');}\\n\\n\\n  /** @type {OfferHandler} */\\n  async function openLoan(seat) {\\n    assert.assert(amountMath.AmountMath.isEmpty(runDebt), assert.details`vault must be empty initially`);\\n    /* get the payout to provide access to the collateral if the*/\\n    /* contract abandons*/\\n    const {\\n      give: { Collateral: collateralAmount },\\n      want: { RUN: wantedRun } } =\\n    seat.getProposal();\\n\\n    const collateralPayoutP = noShim.E(userSeat).getPayouts();\\n\\n    /* todo trigger process() check right away, in case the price dropped while we ran*/\\n\\n    const fee = ratio.multiplyBy(wantedRun, manager.getLoanFee());\\n    if (amountMath.AmountMath.isEmpty(fee)) {\\n      throw seat.fail(\\n      Error('loan requested is too small; cannot accrue interest'));}\\n\\n\\n\\n    runDebt = amountMath.AmountMath.add(wantedRun, fee);\\n    await assertSufficientCollateral(collateralAmount, runDebt);\\n\\n    runMint.mintGains({ RUN: runDebt }, vaultSeat);\\n\\n    seat.incrementBy(vaultSeat.decrementBy({ RUN: wantedRun }));\\n    vaultSeat.incrementBy(seat.decrementBy({ Collateral: collateralAmount }));\\n    manager.reallocateReward(fee, vaultSeat, seat);\\n\\n    updateUiState();\\n\\n    return { notifier: notifier$1, collateralPayoutP };}\\n\\n\\n  function accrueInterestAndAddToPool(currentTime) {\\n    const interestKit = interestCalculator.calculateReportingPeriod(\\n    {\\n      latestInterestUpdate,\\n      newDebt: runDebt,\\n      interest: amountMath.AmountMath.makeEmpty(runBrand) },\\n\\n    currentTime);\\n\\n\\n    if (interestKit.latestInterestUpdate === latestInterestUpdate) {\\n      return amountMath.AmountMath.makeEmpty(runBrand);}\\n\\n\\n    ({ latestInterestUpdate, newDebt: runDebt } = interestKit);\\n    updateUiState();\\n    return interestKit.interest;}\\n\\n\\n  function getDebtAmount() {\\n    return runDebt;}\\n\\n\\n  /** @type {Vault} */\\n  const vault = harden({\\n    makeAdjustBalancesInvitation,\\n    makeCloseInvitation,\\n\\n    /* for status/debugging*/\\n    getCollateralAmount,\\n    getDebtAmount });\\n\\n\\n  return harden({\\n    vault,\\n    openLoan,\\n    accrueInterestAndAddToPool,\\n    vaultSeat,\\n    liquidated });}exports.makeVaultKit = makeVaultKit;\",\n  \"packages/treasury/src/vaultManager.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });require('../../zoe/exported.js');var noShim = require('../../eventual-send/src/no-shim.js');var nat_esm = require('../../../node_modules/@agoric/nat/dist/nat.esm.js');require('../../zoe/src/contractSupport/index.js');require('../../notifier/src/index.js');require('../../ERTP/src/index.js');var vault = require('./vault.js');var prioritizedVaults = require('./prioritizedVaults.js');var liquidation = require('./liquidation.js');var makeTracer = require('./makeTracer.js');var amountMath = require('../../ERTP/src/amountMath.js');var ratio = require('../../zoe/src/contractSupport/ratio.js');var priceQuote = require('../../zoe/src/contractSupport/priceQuote.js');var asyncIterableAdaptor = require('../../notifier/src/asyncIterableAdaptor.js');var zoeHelpers = require('../../zoe/src/contractSupport/zoeHelpers.js'); /* @ts-check*/\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nconst { details: X } = assert;\\n\\nconst trace = makeTracer.makeTracer(' VM ');\\n\\n/* Each VaultManager manages a single collateralType. It owns an autoswap*/\\n/* instance which trades this collateralType against RUN. It also manages*/\\n/* some number of outstanding loans, each called a Vault, for which the*/\\n/* collateral is provided in exchange for borrowed RUN.*/\\n\\n/** @type {MakeVaultManager} */\\nfunction makeVaultManager(\\nzcf,\\nautoswap,\\nrunMint,\\ncollateralBrand,\\npriceAuthority,\\nrates,\\nreallocateReward,\\ntimerService,\\nloanParams,\\nliquidationStrategy)\\n{\\n  const { brand: runBrand } = runMint.getIssuerRecord();\\n\\n  const shared = {\\n    /* loans below this margin may be liquidated*/\\n    getLiquidationMargin() {\\n      return rates.liquidationMargin;},\\n\\n    /* loans must initially have at least 1.2x collateralization*/\\n    getInitialMargin() {\\n      return rates.initialMargin;},\\n\\n    getLoanFee() {\\n      return rates.loanFee;},\\n\\n    getInterestRate() {\\n      return rates.interestRate;},\\n\\n    async getCollateralQuote() {\\n      /* get a quote for one unit of the collateral*/\\n      const displayInfo = await noShim.E(collateralBrand).getDisplayInfo();\\n      const decimalPlaces = displayInfo && displayInfo.decimalPlaces || 0n;\\n      return noShim.E(priceAuthority).quoteGiven(\\n      amountMath.AmountMath.make(10n ** nat_esm.Nat(decimalPlaces), collateralBrand),\\n      runBrand);},\\n\\n\\n    reallocateReward };\\n\\n\\n  /* A Map from vaultKits to their most recent ratio of debt to*/\\n  /* collateralization. (This representation won't be optimized; when we need*/\\n  /* better performance, use virtual objects.)*/\\n  /* eslint-disable-next-line no-use-before-define*/\\n  const sortedVaultKits = prioritizedVaults.makePrioritizedVaults(reschedulePriceCheck);\\n  let outstandingQuote;\\n\\n  /* When any Vault's debt ratio is higher than the current high-water level,*/\\n  /* call reschedulePriceCheck() to request a fresh notification from the*/\\n  /* priceAuthority. There will be extra outstanding requests since we can't*/\\n  /* cancel them. (https://github.com/Agoric/agoric-sdk/issues/2713). When the*/\\n  /* vault with the current highest debt ratio is removed or reduces its ratio,*/\\n  /* we won't reschedule the priceAuthority requests to reduce churn. Instead,*/\\n  /* when a priceQuote is received, we'll only reschedule if the high-water*/\\n  /* level when the request was made matches the current high-water level.*/\\n  async function reschedulePriceCheck() {\\n    const highestDebtRatio = sortedVaultKits.highestRatio();\\n    if (!highestDebtRatio) {\\n      /* if there aren't any open vaults, we don't need an outstanding RFQ.*/\\n      return;}\\n\\n\\n    const liquidationMargin = shared.getLiquidationMargin();\\n\\n    /* ask to be alerted when the price level falls enough that the vault*/\\n    /* with the highest debt to collateral ratio will no longer be valued at the*/\\n    /* liquidationMargin above its debt.*/\\n    const triggerPoint = ratio.multiplyBy(\\n    highestDebtRatio.numerator,\\n    liquidationMargin);\\n\\n\\n    /* if there's an outstanding quote, reset the level. If there's no current*/\\n    /* quote (because this is the first loan, or because a quote just resolved)*/\\n    /* then make a new request to the priceAuthority, and when it resolves,*/\\n    /* liquidate anything that's above the price level.*/\\n    if (outstandingQuote) {\\n      noShim.E(outstandingQuote).updateLevel(\\n      highestDebtRatio.denominator,\\n      triggerPoint);\\n\\n      return;}\\n\\n\\n    outstandingQuote = await noShim.E(priceAuthority).mutableQuoteWhenLT(\\n    highestDebtRatio.denominator,\\n    triggerPoint);\\n\\n\\n    /* There are two awaits in a row here. The first gets a mutableQuote object*/\\n    /* relatively quickly from the PriceAuthority. The second schedules a*/\\n    /* callback that may not fire until much later.*/\\n    /* Callers shouldn't expect a response from this function.*/\\n    const quote = await noShim.E(outstandingQuote).getPromise();\\n    /* When we receive a quote, we liquidate all the vaults that don't have*/\\n    /* sufficient collateral, (even if the trigger was set for a different*/\\n    /* level) because we use the actual price ratio plus margin here.*/\\n    const quoteRatioPlusMargin = ratio.makeRatioFromAmounts(\\n    ratio.divideBy(priceQuote.getAmountOut(quote), liquidationMargin),\\n    priceQuote.getAmountIn(quote));\\n\\n\\n    sortedVaultKits.forEachRatioGTE(quoteRatioPlusMargin, ({ vaultKit }) => {\\n      trace('liquidating', vaultKit.vaultSeat.getProposal());\\n\\n      liquidation.liquidate(\\n      zcf,\\n      vaultKit,\\n      runMint.burnLosses,\\n      liquidationStrategy,\\n      collateralBrand);});\\n\\n\\n    outstandingQuote = undefined;\\n    reschedulePriceCheck();}\\n\\n\\n  function liquidateAll() {\\n    const promises = sortedVaultKits.map(({ vaultKit }) =>\\n    liquidation.liquidate(\\n    zcf,\\n    vaultKit,\\n    runMint.burnLosses,\\n    liquidationStrategy,\\n    collateralBrand));\\n\\n\\n    return Promise.all(promises);}\\n\\n\\n  async function chargeAllVaults(updateTime, poolIncrementSeat) {\\n    const poolIncrement = sortedVaultKits.reduce(\\n    (total, vaultPair) =>\\n    amountMath.AmountMath.add(\\n    total,\\n    vaultPair.vaultKit.accrueInterestAndAddToPool(updateTime)),\\n\\n    amountMath.AmountMath.makeEmpty(runBrand));\\n\\n    sortedVaultKits.updateAllDebts();\\n    reschedulePriceCheck();\\n    runMint.mintGains({ RUN: poolIncrement }, poolIncrementSeat);\\n    reallocateReward(poolIncrement, poolIncrementSeat);}\\n\\n\\n  const periodNotifier = noShim.E(timerService).makeNotifier(\\n  0n,\\n  loanParams.recordingPeriod);\\n\\n  const { zcfSeat: poolIncrementSeat } = zcf.makeEmptySeatKit();\\n\\n  const timeObserver = {\\n    updateState: (updateTime) =>\\n    chargeAllVaults(updateTime, poolIncrementSeat).catch((_) => {}),\\n    fail: (reason) => {\\n      zcf.shutdownWithFailure(\\n      assert.error(X`Unable to continue without a timer: ${reason}`));},\\n\\n\\n    finish: (done) => {\\n      zcf.shutdownWithFailure(\\n      assert.error(X`Unable to continue without a timer: ${done}`));} };\\n\\n\\n\\n\\n  asyncIterableAdaptor.observeNotifier(periodNotifier, timeObserver);\\n\\n  /** @type {InnerVaultManager} */\\n  const innerFacet = harden({\\n    ...shared,\\n    collateralBrand });\\n\\n\\n  /** @param {ZCFSeat} seat */\\n  async function makeLoanKit(seat) {\\n    zoeHelpers.assertProposalShape(seat, {\\n      give: { Collateral: null },\\n      want: { RUN: null } });\\n\\n\\n    const startTimeStamp = await noShim.E(timerService).getCurrentTimestamp();\\n    const vaultKit = vault.makeVaultKit(\\n    zcf,\\n    innerFacet,\\n    runMint,\\n    autoswap,\\n    priceAuthority,\\n    loanParams,\\n    startTimeStamp);\\n\\n\\n    const { vault: vault$1, openLoan } = vaultKit;\\n    const { notifier, collateralPayoutP } = await openLoan(seat);\\n    sortedVaultKits.addVaultKit(vaultKit, notifier);\\n\\n    seat.exit();\\n\\n    /* TODO: nicer to return single objects, find a better way to give them*/\\n    /* the payout object*/\\n    return harden({\\n      uiNotifier: notifier,\\n      invitationMakers: {\\n        AdjustBalances: vault$1.makeAdjustBalancesInvitation,\\n        CloseVault: vault$1.makeCloseInvitation },\\n\\n      vault: vault$1,\\n      liquidationPayout: collateralPayoutP });}\\n\\n\\n\\n  /** @type {VaultManager} */\\n  return harden({\\n    ...shared,\\n    makeLoanKit,\\n    liquidateAll });}exports.makeVaultManager = makeVaultManager;\",\n  \"packages/zoe/exported.js\": \"'use strict';require('./src/contractFacet/types.js');require('./src/zoeService/types.js');require('./src/contractSupport/types.js');require('./src/contracts/exported.js');require('./src/types.js');require('./tools/types.js');require('../notifier/exported.js');require('../ERTP/exported.js');require('../store/exported.js');require('../SwingSet/exported.js');\",\n  \"packages/zoe/src/contractFacet/offerSafety.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });require('../../../ERTP/src/index.js');var\\n\\n\\n\\namountMath = require('../../../ERTP/src/amountMath.js'); /* @ts-check*/ /**\\n * Helper to perform satisfiesWant and satisfiesGive. Is\\n * allocationAmount greater than or equal to requiredAmount for every\\n * keyword of giveOrWant?\\n *\\n * @param {AmountKeywordRecord} giveOrWant\\n * @param {AmountKeywordRecord} allocation\\n */\\nconst satisfiesInternal = (giveOrWant = {}, allocation) => {\\n  const isGTEByKeyword = ([keyword, requiredAmount]) => {\\n    /* If there is no allocation for a keyword, we know the giveOrWant*/\\n    /* is not satisfied without checking further.*/\\n    if (allocation[keyword] === undefined) {\\n      return false;}\\n\\n    const allocationAmount = allocation[keyword];\\n    return amountMath.AmountMath.isGTE(allocationAmount, requiredAmount);};\\n\\n  return Object.entries(giveOrWant).every(isGTEByKeyword);};\\n\\n\\n/**\\n * For this allocation to satisfy what the user wanted, their\\n * allocated amounts must be greater than or equal to proposal.want.\\n *\\n * @param {ProposalRecord} proposal - the rules that accompanied the\\n * escrow of payments that dictate what the user expected to get back\\n * from Zoe. A proposal is a record with keys `give`, `want`, and\\n * `exit`. `give` and `want` are records with keywords as keys and\\n * amounts as values. The proposal is a user's understanding of the\\n * contract that they are entering when they make an offer.\\n * @param {AmountKeywordRecord} allocation - a record with keywords\\n * as keys and amounts as values. These amounts are the reallocation\\n * to be given to a user.\\n */\\nconst satisfiesWant = (proposal, allocation) =>\\nsatisfiesInternal(proposal.want, allocation);\\n\\n/**\\n * For this allocation to count as a full refund, the allocated\\n * amounts must be greater than or equal to what was originally\\n * offered (proposal.give).\\n *\\n * @param  {ProposalRecord} proposal - the rules that accompanied the\\n * escrow of payments that dictate what the user expected to get back\\n * from Zoe. A proposal is a record with keys `give`, `want`, and\\n * `exit`. `give` and `want` are records with keywords as keys and\\n * amounts as values. The proposal is a user's understanding of the\\n * contract that they are entering when they make an offer.\\n * @param  {AmountKeywordRecord} allocation - a record with keywords\\n * as keys and amounts as values. These amounts are the reallocation\\n * to be given to a user.\\n */\\nconst satisfiesGive = (proposal, allocation) =>\\nsatisfiesInternal(proposal.give, allocation);\\n\\n/**\\n * `isOfferSafe` checks offer safety for a single offer.\\n *\\n * Note: This implementation checks whether we fully satisfy\\n * `proposal.give` (giving a refund) or whether we fully satisfy\\n * `proposal.want`. Both can be fully satisfied.\\n *\\n * @param  {ProposalRecord} proposal - the rules that accompanied the\\n * escrow of payments that dictate what the user expected to get back\\n * from Zoe. A proposal is a record with keys `give`, `want`, and\\n * `exit`. `give` and `want` are records with keywords as keys and\\n * amounts as values. The proposal is a user's understanding of the\\n * contract that they are entering when they make an offer.\\n * @param  {AmountKeywordRecord} allocation - a record with keywords\\n * as keys and amounts as values. These amounts are the reallocation\\n * to be given to a user.\\n */\\nfunction isOfferSafe(proposal, allocation) {\\n  return (\\n    satisfiesGive(proposal, allocation) || satisfiesWant(proposal, allocation));}exports.isOfferSafe = isOfferSafe;exports.satisfiesWant = satisfiesWant;\",\n  \"packages/zoe/src/contractFacet/types.js\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n'use strict'; /* eslint-disable-next-line spaced-comment*/ /*/ <reference types=\\\"ses\\\"/>*/ /**\\n * @typedef {any} Completion\\n * Any passable non-thenable. Often an explanatory string.\\n */ /**\\n * @callback ZCFMakeEmptySeatKit\\n * @param {ExitRule=} exit\\n * @returns {ZcfSeatKit}\\n */ /**\\n * @typedef {Object} ContractFacet\\n *\\n * The Zoe interface specific to a contract instance. The Zoe Contract\\n * Facet is an API object used by running contract instances to access\\n * the Zoe state for that instance. The Zoe Contract Facet is accessed\\n * synchronously from within the contract, and usually is referred to\\n * in code as zcf.\\n *\\n * @property {Reallocate} reallocate - reallocate amounts among seats\\n * @property {(keyword: Keyword) => void} assertUniqueKeyword - check\\n * whether a keyword is valid and unique and could be added in\\n * `saveIssuer`\\n * @property {SaveIssuer} saveIssuer - save an issuer to ZCF and Zoe\\n * and get the AmountMath and brand synchronously accessible after\\n * saving\\n * @property {MakeInvitation} makeInvitation\\n * @property {(completion: Completion) => void} shutdown\\n * @property {ShutdownWithFailure} shutdownWithFailure\\n * @property {Assert} assert\\n * @property {() => ERef<ZoeService>} getZoeService\\n * @property {() => Issuer} getInvitationIssuer\\n * @property {() => Terms} getTerms\\n * @property {(issuer: Issuer) => Brand} getBrandForIssuer\\n * @property {(brand: Brand) => Issuer} getIssuerForBrand\\n * @property {GetAssetKindByBrand} getAssetKind\\n * @property {MakeZCFMint} makeZCFMint\\n * @property {ZCFMakeEmptySeatKit} makeEmptySeatKit\\n * @property {SetTestJig} setTestJig\\n * @property {() => void} stopAcceptingOffers\\n */ /**\\n * @typedef {(seat1: ZCFSeat, seat2: ZCFSeat, ...seatRest:\\n * Array<ZCFSeat>) => void} Reallocate\\n *\\n * The contract can reallocate over seats, which commits the staged\\n * allocation for each seat. On commit, the staged allocation becomes\\n * the current allocation and the staged allocation is deleted.\\n *\\n * The reallocation will only succeed if the reallocation 1) conserves\\n * rights (the amounts specified have the same total value as the\\n * current total amount), and 2) is 'offer-safe' for all parties\\n * involved. All seats that have staged allocations must be included\\n * as arguments to `reallocate`, or an error is thrown. Additionally,\\n * an error is thrown if any seats included in `reallocate` do not\\n * have a staged allocation.\\n *\\n * The reallocation is partial, meaning that it applies only to the\\n * seats passed in as arguments. By induction, if rights conservation\\n * and offer safety hold before, they will hold after a safe\\n * reallocation, even though we only re-validate for the seats whose\\n * allocations will change. Since rights are conserved for the change,\\n * overall rights will be unchanged, and a reallocation can only\\n * effect offer safety for seats whose allocations change.\\n */ /**\\n * @callback SaveIssuer\\n *\\n * Informs Zoe about an issuer and returns a promise for acknowledging\\n * when the issuer is added and ready.\\n *\\n * @param {ERef<Issuer>} issuerP Promise for issuer\\n * @param {Keyword} keyword Keyword for added issuer\\n * @returns {Promise<IssuerRecord>} Issuer is added and ready\\n */ /**\\n * @callback MakeInvitation\\n *\\n * Make a credible Zoe invitation for a particular smart contract\\n * indicated by the `instance` in the details of the invitation. Zoe\\n * also puts the `installation` and a unique `handle` in the details of\\n * the invitation. The contract must provide a `description` for the\\n * invitation and should include whatever information is\\n * necessary for a potential buyer of the invitation to know what they are\\n * getting in the `customProperties`. `customProperties` will be\\n * placed in the details of the invitation.\\n *\\n * @param {OfferHandler=} offerHandler - a contract specific function\\n * that handles the offer, such as saving it or performing a trade\\n * @param {string} description\\n * @param {Object=} customProperties\\n * @returns {Promise<Invitation>}\\n */ /**\\n * @callback MakeZCFMint\\n * @param {Keyword} keyword\\n * @param {AssetKind=} assetKind\\n * @param {AdditionalDisplayInfo=} displayInfo\\n * @returns {Promise<ZCFMint>}\\n */ /**\\n * Provide a jig object for testing purposes only.\\n *\\n * The contract code provides a callback whose return result will\\n * be made available to the test that started this contract. The\\n * supplied callback will only be called in a testing context,\\n * never in production; i.e., it is only called if `testJigSetter`\\n * was supplied.\\n *\\n * If no, \\\\testFn\\\\ is supplied, then an empty jig will be used.\\n * An additional `zcf` property set to the current ContractFacet\\n * will be appended to the returned jig object (overriding any\\n * provided by the `testFn`).\\n *\\n * @callback SetTestJig\\n * @param {() => any} testFn\\n * @returns {void}\\n */ /**\\n * @callback ZCFMintMintGains\\n * @param {AmountKeywordRecord} gains\\n * @param {ZCFSeat=} zcfSeat\\n * @returns {ZCFSeat}\\n */ /**\\n * @typedef {Object} ZCFMint\\n * @property {() => IssuerRecord} getIssuerRecord\\n * @property {ZCFMintMintGains} mintGains\\n * All the amounts in gains must be of this ZCFMint's brand.\\n * The gains' keywords are in the namespace of that seat.\\n * Add the gains to that seat's allocation.\\n * The resulting state must be offer safe. (Currently, increasing assets can\\n * never violate offer safety anyway.)\\n *\\n * Mint that amount of assets into the pooled purse.\\n * If a seat is provided, it is returned. Otherwise a new seat is\\n * returned.\\n * TODO unimplemented\\n * This creation-on-demand is not yet implemented.\\n *\\n * @property {(losses: AmountKeywordRecord,\\n *             zcfSeat: ZCFSeat,\\n *            ) => void} burnLosses\\n * All the amounts in losses must be of this ZCFMint's brand.\\n * The losses' keywords are in the namespace of that seat.\\n * Subtract losses from that seat's allocation.\\n * The resulting state must be offer safe.\\n *\\n * Burn that amount of assets from the pooled purse.\\n */ /**\\n * @callback ZCFSeatFail\\n *\\n * fail called with the reason for this failure, where reason is\\n * normally an instanceof Error.\\n * @param {Error} reason\\n * @returns {Error}\\n */ /**\\n * @callback ZCFGetAmountAllocated\\n * The brand is used for filling in an empty amount if the `keyword`\\n * is not present in the allocation\\n * @param {Keyword} keyword\\n * @param {Brand=} brand\\n * @returns {Amount}\\n */ /**\\n * @typedef {Object} ZCFSeat\\n * @property {() => void} exit\\n * @property {ZCFSeatFail} fail\\n * @property {() => Notifier<Allocation>} getNotifier\\n * @property {() => boolean} hasExited\\n * @property {() => ProposalRecord} getProposal\\n * @property {ZCFGetAmountAllocated} getAmountAllocated\\n * @property {() => Allocation} getCurrentAllocation\\n * @property {() => Allocation} getStagedAllocation\\n * @property {() => boolean} hasStagedAllocation\\n * @property {(newAllocation: Allocation) => boolean} isOfferSafe\\n * @property {(amountKeywordRecord: AmountKeywordRecord) => AmountKeywordRecord} incrementBy\\n * @property {(amountKeywordRecord: AmountKeywordRecord) => AmountKeywordRecord} decrementBy\\n * @property {() => void} clear\\n */ /**\\n * @typedef {{ zcfSeat: ZCFSeat, userSeat: ERef<UserSeat>}} ZcfSeatKit\\n */ /**\\n * @callback OfferHandler\\n * @param {ZCFSeat} seat\\n * @returns {any}\\n */ /**\\n * @callback ContractStartFn\\n * @param {ContractFacet} zcf\\n * @returns {ContractStartFnResult}\\n */ /**\\n * @typedef {Object} ContractStartFnResult\\n * @property {Object=} creatorFacet\\n * @property {Promise<Invitation>=} creatorInvitation\\n * @property {Object=} publicFacet\\n */\",\n  \"packages/zoe/src/contractSupport/bondingCurves.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var assert = require('../../../assert/src/assert.js');var nat_esm = require('../../../../node_modules/@agoric/nat/dist/nat.esm.js');var safeMath = require('./safeMath.js'); /* @ts-check*/\\n\\n\\n\\n\\n\\nconst { subtract, add, multiply, floorDivide } = safeMath.natSafeMath;\\n\\nconst BASIS_POINTS = 10000n; /* TODO change to 10_000n once tooling copes.*/\\n\\n/**\\n * Calculations for constant product markets like Uniswap.\\n * https://github.com/runtimeverification/verified-smart-contracts/blob/uniswap/uniswap/x-y-k.pdf\\n */\\n\\n/**\\n * Contains the logic for calculating how much should be given\\n * back to the user in exchange for what they sent in. Reused in\\n * several different places, including to check whether an offer\\n * is valid, getting the current price for an asset on user\\n * request, and to do the actual reallocation after an offer has\\n * been made.\\n *\\n * @param {any} inputValue - the value of the asset sent\\n * in to be swapped\\n * @param {any} inputReserve - the value in the liquidity\\n * pool of the kind of asset sent in\\n * @param {any} outputReserve - the value in the liquidity\\n * pool of the kind of asset to be sent out\\n * @param {bigint} [feeBasisPoints=30n] - the fee taken in\\n * basis points. The default is 0.3% or 30 basis points. The fee\\n * is taken from inputValue\\n * @returns {NatValue} outputValue - the current price, in value form\\n */\\nconst getInputPrice = (\\ninputValue,\\ninputReserve,\\noutputReserve,\\nfeeBasisPoints = 30n) =>\\n{\\n  inputValue = nat_esm.Nat(inputValue);\\n  inputReserve = nat_esm.Nat(inputReserve);\\n  outputReserve = nat_esm.Nat(outputReserve);\\n  assert.assert(inputValue > 0n, assert.details`inputValue ${inputValue} must be positive`);\\n  assert.assert(inputReserve > 0n, assert.details`inputReserve ${inputReserve} must be positive`);\\n  assert.assert(\\n  outputReserve > 0n,\\n  assert.details`outputReserve ${outputReserve} must be positive`);\\n\\n\\n  const oneMinusFeeScaled = subtract(BASIS_POINTS, feeBasisPoints);\\n  const inputWithFee = multiply(inputValue, oneMinusFeeScaled);\\n  const numerator = multiply(inputWithFee, outputReserve);\\n  const denominator = add(multiply(inputReserve, BASIS_POINTS), inputWithFee);\\n  return floorDivide(numerator, denominator);};\\n\\n\\n/**\\n * Contains the logic for calculating how much should be taken\\n * from the user in exchange for what they want to obtain. Reused in\\n * several different places, including to check whether an offer\\n * is valid, getting the current price for an asset on user\\n * request, and to do the actual reallocation after an offer has\\n * been made.\\n *\\n * @param {any} outputValue - the value of the asset the user wants\\n * to get\\n * @param {any} inputReserve - the value in the liquidity\\n * pool of the asset being spent\\n * @param {any} outputReserve - the value in the liquidity\\n * pool of the kind of asset to be sent out\\n * @param {bigint} [feeBasisPoints=30n] - the fee taken in\\n * basis points. The default is 0.3% or 30 basis points. The fee is taken from\\n * outputValue\\n * @returns {NatValue} inputValue - the value of input required to purchase output\\n */\\nconst getOutputPrice = (\\noutputValue,\\ninputReserve,\\noutputReserve,\\nfeeBasisPoints = 30n) =>\\n{\\n  outputValue = nat_esm.Nat(outputValue);\\n  inputReserve = nat_esm.Nat(inputReserve);\\n  outputReserve = nat_esm.Nat(outputReserve);\\n\\n  assert.assert(inputReserve > 0n, assert.details`inputReserve ${inputReserve} must be positive`);\\n  assert.assert(\\n  outputReserve > 0n,\\n  assert.details`outputReserve ${outputReserve} must be positive`);\\n\\n  assert.assert(\\n  outputReserve > outputValue,\\n  assert.details`outputReserve ${outputReserve} must be greater than outputValue ${outputValue}`);\\n\\n\\n  const oneMinusFeeScaled = subtract(BASIS_POINTS, feeBasisPoints);\\n  const numerator = multiply(multiply(outputValue, inputReserve), BASIS_POINTS);\\n  const denominator = multiply(\\n  subtract(outputReserve, outputValue),\\n  oneMinusFeeScaled);\\n\\n  return add(floorDivide(numerator, denominator), 1n);};\\n\\n\\n/* Calculate how many liquidity tokens we should be minting to send back to the*/\\n/* user when adding liquidity. We provide new liquidity equal to the existing*/\\n/* liquidity multiplied by the ratio of new central tokens to central tokens*/\\n/* already held. If the current supply is zero, return the inputValue as the*/\\n/* initial liquidity to mint is arbitrary.*/\\nconst calcLiqValueToMint = (\\nliqTokenSupply,\\ninputValue,\\ninputReserve) =>\\n{\\n  liqTokenSupply = nat_esm.Nat(liqTokenSupply);\\n  inputValue = nat_esm.Nat(inputValue);\\n  inputReserve = nat_esm.Nat(inputReserve);\\n\\n  if (liqTokenSupply === 0n) {\\n    return inputValue;}\\n\\n  return floorDivide(multiply(inputValue, liqTokenSupply), inputReserve);};\\n\\n\\n/**\\n * Calculate how much of the secondary token is required from the user when\\n * adding liquidity. We require that the deposited ratio of central to secondary\\n * match the current ratio of holdings in the pool.\\n *\\n * @param {any} centralIn - The value of central assets being deposited\\n * @param {any} centralPool - The value of central assets in the pool\\n * @param {any} secondaryPool - The value of secondary assets in the pool\\n * @param {any} secondaryIn - The value of secondary assets provided. If\\n * the pool is empty, the entire amount will be accepted\\n * @returns {NatValue} - the amount of secondary required\\n */\\nconst calcSecondaryRequired = (\\ncentralIn,\\ncentralPool,\\nsecondaryPool,\\nsecondaryIn) =>\\n{\\n  centralIn = nat_esm.Nat(centralIn);\\n  centralPool = nat_esm.Nat(centralPool);\\n  secondaryPool = nat_esm.Nat(secondaryPool);\\n  secondaryIn = nat_esm.Nat(secondaryIn);\\n\\n  if (centralPool === 0n || secondaryPool === 0n) {\\n    return secondaryIn;}\\n\\n\\n  const scaledSecondary = floorDivide(\\n  multiply(centralIn, secondaryPool),\\n  centralPool);\\n\\n  const exact =\\n  multiply(centralIn, secondaryPool) ===\\n  multiply(scaledSecondary, centralPool);\\n\\n  /* doesn't match the x-y-k.pdf paper, but more correct. When the ratios are*/\\n  /* exactly equal, lPrime is exactly l * (1 + alpha) and adding one is wrong*/\\n  return exact ? scaledSecondary : 1n + scaledSecondary;};\\n\\n\\n/* Calculate how many underlying tokens (in the form of a value) should be*/\\n/* returned when removing liquidity.*/\\nconst calcValueToRemove = (\\nliqTokenSupply,\\npoolValue,\\nliquidityValueIn) =>\\n{\\n  liqTokenSupply = nat_esm.Nat(liqTokenSupply);\\n  liquidityValueIn = nat_esm.Nat(liquidityValueIn);\\n  poolValue = nat_esm.Nat(poolValue);\\n\\n  return floorDivide(multiply(liquidityValueIn, poolValue), liqTokenSupply);};exports.calcLiqValueToMint = calcLiqValueToMint;exports.calcSecondaryRequired = calcSecondaryRequired;exports.calcValueToRemove = calcValueToRemove;exports.getInputPrice = getInputPrice;exports.getOutputPrice = getOutputPrice;\",\n  \"packages/zoe/src/contractSupport/index.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var bondingCurves = require('./bondingCurves.js');var priceAuthority = require('./priceAuthority.js');var priceQuote = require('./priceQuote.js');var safeMath = require('./safeMath.js');var stateMachine = require('./stateMachine.js');var statistics = require('./statistics.js');var zoeHelpers = require('./zoeHelpers.js');var ratio = require('./ratio.js'); /* @ts-check*/exports.calcLiqValueToMint = bondingCurves.calcLiqValueToMint;exports.calcSecondaryRequired = bondingCurves.calcSecondaryRequired;exports.calcValueToRemove = bondingCurves.calcValueToRemove;exports.getInputPrice = bondingCurves.getInputPrice;exports.getOutputPrice = bondingCurves.getOutputPrice;exports.makeOnewayPriceAuthorityKit = priceAuthority.makeOnewayPriceAuthorityKit;exports.getAmountIn = priceQuote.getAmountIn;exports.getAmountOut = priceQuote.getAmountOut;exports.getQuoteValues = priceQuote.getQuoteValues;exports.getTimestamp = priceQuote.getTimestamp;exports.natSafeMath = safeMath.natSafeMath;exports.makeStateMachine = stateMachine.makeStateMachine;exports.calculateMedian = statistics.calculateMedian;exports.assertIssuerKeywords = zoeHelpers.assertIssuerKeywords;exports.assertNatAssetKind = zoeHelpers.assertNatAssetKind;exports.assertProposalShape = zoeHelpers.assertProposalShape;exports.checkZCF = zoeHelpers.checkZCF;exports.defaultAcceptanceMsg = zoeHelpers.defaultAcceptanceMsg;exports.depositToSeat = zoeHelpers.depositToSeat;exports.offerTo = zoeHelpers.offerTo;exports.satisfies = zoeHelpers.satisfies;exports.saveAllIssuers = zoeHelpers.saveAllIssuers;exports.swap = zoeHelpers.swap;exports.swapExact = zoeHelpers.swapExact;exports.withdrawFromSeat = zoeHelpers.withdrawFromSeat;exports.addRatios = ratio.addRatios;exports.assertIsRatio = ratio.assertIsRatio;exports.divideBy = ratio.divideBy;exports.invertRatio = ratio.invertRatio;exports.makeRatio = ratio.makeRatio;exports.makeRatioFromAmounts = ratio.makeRatioFromAmounts;exports.multiplyBy = ratio.multiplyBy;exports.multiplyRatios = ratio.multiplyRatios;exports.oneMinus = ratio.oneMinus;\",\n  \"packages/zoe/src/contractSupport/priceAuthority.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var noShim = require('../../../eventual-send/src/no-shim.js');require('../../../marshal/index.js');var assert = require('../../../assert/src/assert.js');var promiseKit = require('../../../promise-kit/src/promiseKit.js');require('../../../ERTP/src/index.js');require('../../../notifier/src/index.js');require('../../exported.js');var amountMath = require('../../../ERTP/src/amountMath.js');var marshal = require('../../../marshal/src/marshal.js');var\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nnotifier = require('../../../notifier/src/notifier.js'); /* @ts-check*/ /**\\n * @callback CompareAmount\\n * @param {Amount} amount\\n * @param {Amount} amountLimit\\n * @returns {boolean}\\n */ /** @type {CompareAmount} */const isLT = (amountOut, amountLimit) => !amountMath.AmountMath.isGTE(amountOut, amountLimit); /** @type {CompareAmount} */const isLTE = (amount, amountLimit) => amountMath.AmountMath.isGTE(amountLimit, amount);\\n\\n/** @type {CompareAmount} */\\nconst isGTE = (amount, amountLimit) => amountMath.AmountMath.isGTE(amount, amountLimit);\\n\\n/** @type {CompareAmount} */\\nconst isGT = (amount, amountLimit) => !amountMath.AmountMath.isGTE(amountLimit, amount);\\n\\n/**\\n * @typedef {Object} OnewayPriceAuthorityOptions\\n * @property {Issuer} quoteIssuer\\n * @property {ERef<Notifier<Timestamp>>} notifier\\n * @property {TimerService} timer\\n * @property {PriceQuoteCreate} createQuote\\n * @property {Brand} actualBrandIn\\n * @property {Brand} actualBrandOut\\n */\\n\\n/**\\n * @callback Trigger\\n * @param {PriceQuoteCreate} createInstantQuote\\n * @returns {Promise<void>}\\n */\\n\\n/**\\n * @param {OnewayPriceAuthorityOptions} opts\\n * @returns {PriceAuthorityKit}\\n */\\nfunction makeOnewayPriceAuthorityKit(opts) {\\n  const {\\n    timer,\\n    createQuote,\\n    actualBrandIn,\\n    actualBrandOut,\\n    quoteIssuer,\\n    notifier: notifier$1 } =\\n  opts;\\n\\n  let haveFirstQuote = false;\\n\\n  noShim.E(notifier$1).\\n  getUpdateSince().\\n  then((_) => haveFirstQuote = true);\\n\\n  /** @type {Set<Trigger>} */\\n  const triggers = new Set();\\n  const mutableTriggers = new Map();\\n\\n  /**\\n   * @param {PriceQuoteCreate} triggerCreateQuote\\n   * @returns {Promise<void>}\\n   */\\n  const fireTriggers = async (triggerCreateQuote) => {\\n    if (!haveFirstQuote) {\\n      return;}\\n\\n    await Promise.all(\\n    [...triggers, ...Array.from(mutableTriggers.values())].map((trigger) =>\\n    trigger(triggerCreateQuote)));};\\n\\n\\n\\n\\n  /**\\n   * Create a quoteWhen* function.\\n   *\\n   * @param {CompareAmount} compareAmountsFn\\n   */\\n  const makeQuoteWhenOut = (compareAmountsFn) =>\\n  /**\\n   * Return a quote when triggerWhen is true of the arguments.\\n   *\\n   * @param {Amount} amountIn the input value to the calcAmountTrigger\\n   * @param {Amount} amountOutLimit the value to compare with the output\\n   * of calcAmountTrigger\\n   */\\n  async function quoteWhenOutTrigger(amountIn, amountOutLimit) {\\n    amountMath.AmountMath.coerce(amountIn, actualBrandIn);\\n    amountMath.AmountMath.coerce(amountOutLimit, actualBrandOut);\\n\\n    /** @type {PromiseRecord<PriceQuote>} */\\n    const triggerPK = promiseKit.makePromiseKit();\\n\\n    /** @type {PriceQuoteTrigger} */\\n    const trigger = async (createInstantQuote) => {\\n      try {\\n        const quoteP = createInstantQuote((calcAmountOut) => {\\n          if (!triggers.has(trigger)) {\\n            /* Already fired.*/\\n            return undefined;}\\n\\n          const amountOut = calcAmountOut(amountIn);\\n\\n          if (!compareAmountsFn(amountOut, amountOutLimit)) {\\n            /* Don't fire the trigger yet.*/\\n            return undefined;}\\n\\n\\n          /* Generate the quote.*/\\n          return { amountIn, amountOut };});\\n\\n\\n        if (!quoteP) {\\n          /* We shouldn't resolve yet.*/\\n          return;}\\n\\n\\n        triggers.delete(trigger);\\n        triggerPK.resolve(quoteP);}\\n      catch (e) {\\n        /* Trigger failed, so reject and drop.*/\\n        triggerPK.reject(e);\\n        triggers.delete(trigger);}};\\n\\n\\n\\n    triggers.add(trigger);\\n\\n    /* Fire now, just in case.*/\\n    await trigger(createQuote);\\n\\n    return triggerPK.promise;};\\n\\n\\n  const makeMutableQuote = (compareAmountsFn) =>\\n  async function mutableQuoteWhenOutTrigger(amountInArg, amountOutLimitArg) {\\n    let amountIn = amountMath.AmountMath.coerce(amountInArg, actualBrandIn);\\n    let amountOutLimit = amountMath.AmountMath.coerce(amountOutLimitArg, actualBrandOut);\\n\\n    /** @type {PromiseRecord<PriceQuote>} */\\n    const triggerPK = promiseKit.makePromiseKit();\\n\\n    const mutableQuote = marshal.Far('MutableQuote', {\\n      cancel: (e) => triggerPK.reject(e),\\n      updateLevel: (newAmountIn, newAmountOutLimit) => {\\n        const coercedAmountIn = amountMath.AmountMath.coerce(newAmountIn, actualBrandIn);\\n        const coercedAmountOutLimit = amountMath.AmountMath.coerce(\\n        newAmountOutLimit,\\n        actualBrandOut);\\n\\n        amountIn = coercedAmountIn;\\n        amountOutLimit = coercedAmountOutLimit;},\\n\\n      getPromise: () => triggerPK.promise });\\n\\n\\n    /** @type {PriceQuoteTrigger} */\\n    const mutableTrigger = async (createInstantQuote) => {\\n      try {\\n        const quoteP = createInstantQuote((calcAmountOut) => {\\n          if (!mutableTriggers.has(mutableQuote)) {\\n            /* Already fired.*/\\n            return undefined;}\\n\\n          const amountOut = calcAmountOut(amountIn);\\n\\n          if (!compareAmountsFn(amountOut, amountOutLimit)) {\\n            /* Don't fire the mutableTrigger yet.*/\\n            return undefined;}\\n\\n\\n          /* Generate the quote.*/\\n          return { amountIn, amountOut };});\\n\\n\\n        if (!quoteP) {\\n          /* We shouldn't resolve yet.*/\\n          return;}\\n\\n\\n        mutableTriggers.delete(mutableQuote);\\n        triggerPK.resolve(quoteP);}\\n      catch (e) {\\n        /* Trigger failed, so reject and drop.*/\\n        triggerPK.reject(e);\\n        mutableTriggers.delete(mutableQuote);}};\\n\\n\\n\\n    mutableTriggers.set(mutableQuote, mutableTrigger);\\n\\n    /* Fire now, just in case.*/\\n    await mutableTrigger(createQuote);\\n\\n    return mutableQuote;};\\n\\n\\n  /**\\n   * Ensure that the brandIn/brandOut pair is supported.\\n   *\\n   * @param {Brand} brandIn\\n   * @param {Brand} brandOut\\n   */\\n  const assertBrands = (brandIn, brandOut) => {\\n    assert.assert.equal(\\n    brandIn,\\n    actualBrandIn,\\n    assert.details`Desired brandIn ${brandIn} must match ${actualBrandIn}`);\\n\\n    assert.assert.equal(\\n    brandOut,\\n    actualBrandOut,\\n    assert.details`Desired brandOut ${brandOut} must match ${actualBrandOut}`);};\\n\\n\\n\\n  /** @type {PriceAuthority} */\\n  const priceAuthority = marshal.Far('PriceAuthority', {\\n    getQuoteIssuer(brandIn, brandOut) {\\n      assertBrands(brandIn, brandOut);\\n      return quoteIssuer;},\\n\\n    getTimerService(brandIn, brandOut) {\\n      assertBrands(brandIn, brandOut);\\n      return timer;},\\n\\n    makeQuoteNotifier(amountIn, brandOut) {\\n      amountMath.AmountMath.coerce(amountIn, actualBrandIn);\\n      assertBrands(amountIn.brand, brandOut);\\n\\n      /* Wrap our underlying notifier with specific quotes.*/\\n      const specificBaseNotifier = harden({\\n        async getUpdateSince(updateCount = NaN) {\\n          /* We use the same updateCount as our underlying notifier.*/\\n          const record = await noShim.E(notifier$1).getUpdateSince(updateCount);\\n\\n          /* We create a quote inline.*/\\n          const quote = createQuote((calcAmountOut) => ({\\n            amountIn,\\n            amountOut: calcAmountOut(amountIn) }));\\n\\n          assert.assert(quote);\\n\\n          const value = await quote;\\n          return harden({\\n            value,\\n            updateCount: record.updateCount });} });\\n\\n\\n\\n\\n      /** @type {Notifier<PriceQuote>} */\\n      const specificNotifier = marshal.Far('QuoteNotifier', {\\n        ...notifier.makeNotifier(specificBaseNotifier),\\n        /* TODO stop exposing baseNotifier methods directly.*/\\n        ...specificBaseNotifier });\\n\\n      return specificNotifier;},\\n\\n    async quoteGiven(amountIn, brandOut) {\\n      amountMath.AmountMath.coerce(amountIn, actualBrandIn);\\n      assertBrands(amountIn.brand, brandOut);\\n\\n      await noShim.E(notifier$1).getUpdateSince();\\n      const quote = createQuote((calcAmountOut) => ({\\n        amountIn,\\n        amountOut: calcAmountOut(amountIn) }));\\n\\n      assert.assert(quote);\\n      return quote;},\\n\\n    async quoteWanted(brandIn, amountOut) {\\n      amountMath.AmountMath.coerce(amountOut, actualBrandOut);\\n      assertBrands(brandIn, amountOut.brand);\\n\\n      await noShim.E(notifier$1).getUpdateSince();\\n      const quote = createQuote((calcAmountOut, calcAmountIn) => {\\n        /* We need to determine an amountIn that guarantees at least the amountOut.*/\\n        const amountIn = calcAmountIn(amountOut);\\n        const actualAmountOut = calcAmountOut(amountIn);\\n\\n        assert.assert(\\n        amountMath.AmountMath.isGTE(actualAmountOut, amountOut),\\n        assert.details`Calculation of ${actualAmountOut} didn't cover expected ${amountOut}`);\\n\\n        return { amountIn, amountOut };});\\n\\n      assert.assert(quote);\\n      return quote;},\\n\\n    async quoteAtTime(deadline, amountIn, brandOut) {\\n      assert.assert.typeof(deadline, 'bigint');\\n      amountMath.AmountMath.coerce(amountIn, actualBrandIn);\\n      assertBrands(amountIn.brand, brandOut);\\n\\n      await noShim.E(notifier$1).getUpdateSince();\\n      const quotePK = promiseKit.makePromiseKit();\\n      await noShim.E(timer).setWakeup(\\n      deadline,\\n      marshal.Far('wakeObj', {\\n        async wake(timestamp) {\\n          try {\\n            const quoteP = createQuote((calcAmountOut) => ({\\n              amountIn,\\n              amountOut: calcAmountOut(amountIn),\\n              timestamp }));\\n\\n\\n            /* We don't wait for the quote to be authenticated; resolve*/\\n            /* immediately.*/\\n            quotePK.resolve(quoteP);\\n            await quotePK.promise;}\\n          catch (e) {\\n            quotePK.reject(e);}} }));\\n\\n\\n\\n\\n\\n      /* Wait until the wakeup passes.*/\\n      return quotePK.promise;},\\n\\n    quoteWhenLT: makeQuoteWhenOut(isLT),\\n    quoteWhenLTE: makeQuoteWhenOut(isLTE),\\n    quoteWhenGTE: makeQuoteWhenOut(isGTE),\\n    quoteWhenGT: makeQuoteWhenOut(isGT),\\n    mutableQuoteWhenLT: makeMutableQuote(isLT),\\n    mutableQuoteWhenLTE: makeMutableQuote(isLTE),\\n    mutableQuoteWhenGT: makeMutableQuote(isGT),\\n    mutableQuoteWhenGTE: makeMutableQuote(isGTE) });\\n\\n\\n  return { priceAuthority, adminFacet: { fireTriggers } };}exports.makeOnewayPriceAuthorityKit = makeOnewayPriceAuthorityKit;\",\n  \"packages/zoe/src/contractSupport/priceQuote.js\": \"'use strict';\\n\\n\\n\\n\\nObject.defineProperty(exports, '__esModule', { value: true }); /* @ts-check*/ /* PriceAuthorities return quotes as a pair of an amount and a payment, both*/ /* with the same value. The underlying amount wraps amountIn, amountOut, timer*/ /* and timestamp. The payment is issued by the quoteIssuer to support veracity*/ /* checking. These helpers make it easier to extract the components of the Quote*/\\n\\nconst getAmountIn = (quote) => quote.quoteAmount.value[0].amountIn;\\nconst getAmountOut = (quote) => quote.quoteAmount.value[0].amountOut;\\nconst getTimestamp = (quote) => quote.quoteAmount.value[0].timestamp;\\nconst getQuoteValues = (quote) => quote.quoteAmount.value[0];exports.getAmountIn = getAmountIn;exports.getAmountOut = getAmountOut;exports.getQuoteValues = getQuoteValues;exports.getTimestamp = getTimestamp;\",\n  \"packages/zoe/src/contractSupport/ratio.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });require('./types.js');var assert = require('../../../assert/src/assert.js');var nat_esm = require('../../../../node_modules/@agoric/nat/dist/nat.esm.js');var safeMath = require('./safeMath.js'); /* @ts-check*/\\n\\n\\n\\n\\n\\n\\nconst { multiply, floorDivide, add, subtract } = safeMath.natSafeMath;\\n\\n/* make a Ratio, which represents a fraction. It is a pass-by-copy record.*/\\n/**/\\n/* The natural syntax for the most common operations we want to support*/\\n/* are Amount * Ratio and Amount / Ratio. Since the operations want to adhere to*/\\n/* the ratio rather than the amount, we settled on a calling convention of*/\\n/* multiplyBy(Amount, Ratio) and divideBy(Amount, Ratio).*/\\n/**/\\n/* The most common kind of Ratio can be applied to Amounts of a particular*/\\n/* brand, and produces results of the same brand. This represents a multiplier*/\\n/* that is only applicable to that brand. The less common kind of Ratio can be*/\\n/* applied to one particular brand of amounts, and produces results of another*/\\n/* particular brand. This represents some kind of exchange rate. The*/\\n/* brand-checking helps us ensure that normal Ratios aren't applied to amounts*/\\n/* of the wrong brand, and that exchange rates are only used in the appropriate*/\\n/* direction.*/\\n\\nconst PERCENT = 100n;\\n\\nconst ratioPropertyNames = ['numerator', 'denominator'];\\n\\nconst assertIsRatio = (ratio) => {\\n  const propertyNames = Object.getOwnPropertyNames(ratio);\\n  assert.assert(\\n  propertyNames.length === 2,\\n  assert.details`Ratio ${ratio} must be a record with 2 fields.`);\\n\\n  for (const name of propertyNames) {\\n    assert.assert(\\n    ratioPropertyNames.includes(name),\\n    assert.details`Parameter must be a Ratio record, but ${ratio} has ${assert.quote(name)}`);}\\n\\n\\n  nat_esm.Nat(ratio.numerator.value);\\n  nat_esm.Nat(ratio.denominator.value);};\\n\\n\\n/**\\n * @param {bigint | number} numerator\\n * @param {Brand} numeratorBrand\\n * @param {bigint | number} denominator\\n * @param {Brand} denominatorBrand\\n * @returns {Ratio}\\n */\\nconst makeRatio = (\\nnumerator,\\nnumeratorBrand,\\ndenominator = PERCENT,\\ndenominatorBrand = numeratorBrand) =>\\n{\\n  assert.assert(\\n  denominator > 0n,\\n  assert.details`No infinite ratios! Denominator was 0/${assert.quote(denominatorBrand)}`);\\n\\n\\n  /* TODO(https://github.com/Agoric/agoric-sdk/pull/2310) after the refactoring*/\\n  /* use AmountMath's constructor here rather than building the record directly*/\\n  return harden({\\n    numerator: { value: nat_esm.Nat(numerator), brand: numeratorBrand },\\n    denominator: { value: nat_esm.Nat(denominator), brand: denominatorBrand } });};\\n\\n\\n\\nconst makeRatioFromAmounts = (numeratorAmount, denominatorAmount) => {\\n  /* TODO(https://github.com/Agoric/agoric-sdk/pull/2310) after the refactoring*/\\n  /* coerce amounts using a native AmountMath operation.*/\\n\\n  return makeRatio(\\n  nat_esm.Nat(numeratorAmount.value),\\n  numeratorAmount.brand,\\n  nat_esm.Nat(denominatorAmount.value),\\n  denominatorAmount.brand);};\\n\\n\\n\\nconst multiplyBy = (amount, ratio) => {\\n  /* TODO(https://github.com/Agoric/agoric-sdk/pull/2310) after the refactoring*/\\n  /* coerce amount using a native AmountMath operation.*/\\n  assert.assert(amount.brand, assert.details`Expected an amount: ${amount}`);\\n  nat_esm.Nat(amount.value);\\n\\n  assertIsRatio(ratio);\\n  assert.assert(\\n  amount.brand === ratio.denominator.brand,\\n  assert.details`amount's brand ${assert.quote(amount.brand)} must match ratio's denominator ${assert.quote(\\n  ratio.denominator.brand)\\n  }`);\\n\\n\\n  /* TODO(https://github.com/Agoric/agoric-sdk/pull/2310) after the refactoring*/\\n  /* use AmountMath's constructor here rather than building the record directly*/\\n  return harden({\\n    value: floorDivide(\\n    multiply(amount.value, ratio.numerator.value),\\n    ratio.denominator.value),\\n\\n    brand: ratio.numerator.brand });};\\n\\n\\n\\nconst divideBy = (amount, ratio) => {\\n  /* TODO(https://github.com/Agoric/agoric-sdk/pull/2310) after the refactoring*/\\n  /* coerce amount using a native AmountMath operation.*/\\n  assert.assert(amount.brand, assert.details`Expected an amount: ${amount}`);\\n  nat_esm.Nat(amount.value);\\n\\n  assertIsRatio(ratio);\\n  assert.assert(\\n  amount.brand === ratio.numerator.brand,\\n  assert.details`amount's brand ${assert.quote(amount.brand)} must match ratio's numerator ${assert.quote(\\n  ratio.numerator.brand)\\n  }`);\\n\\n\\n  /* TODO(https://github.com/Agoric/agoric-sdk/pull/2310) after the refactoring*/\\n  /* use AmountMath's constructor here rather than building the record directly*/\\n  return harden({\\n    value: floorDivide(\\n    multiply(amount.value, ratio.denominator.value),\\n    ratio.numerator.value),\\n\\n    brand: ratio.denominator.brand });};\\n\\n\\n\\nconst invertRatio = (ratio) => {\\n  assertIsRatio(ratio);\\n\\n  return makeRatio(\\n  ratio.denominator.value,\\n  ratio.denominator.brand,\\n  ratio.numerator.value,\\n  ratio.numerator.brand);};\\n\\n\\n\\nconst addRatios = (left, right) => {\\n  assertIsRatio(right);\\n  assertIsRatio(left);\\n  assert.assert(\\n  left.numerator.brand === left.denominator.brand &&\\n  left.numerator.brand === right.numerator.brand &&\\n  left.numerator.brand === right.denominator.brand,\\n  assert.details`all brands must match:  ${assert.quote(left)} ${assert.quote(right)}`);\\n\\n\\n  return makeRatio(\\n  add(\\n  multiply(left.numerator.value, right.denominator.value),\\n  multiply(left.denominator.value, right.numerator.value)),\\n\\n  left.numerator.brand,\\n  multiply(left.denominator.value, right.denominator.value));};\\n\\n\\n\\nconst multiplyRatios = (left, right) => {\\n  assertIsRatio(right);\\n  assertIsRatio(left);\\n  assert.assert(\\n  left.numerator.brand === left.denominator.brand &&\\n  left.numerator.brand === right.numerator.brand &&\\n  left.numerator.brand === right.denominator.brand,\\n  assert.details`all brands must match:  ${assert.quote(left)} ${assert.quote(right)}`);\\n\\n\\n  return makeRatio(\\n  multiply(left.numerator.value, right.numerator.value),\\n  left.numerator.brand,\\n  multiply(left.denominator.value, right.denominator.value));};\\n\\n\\n\\n/* If ratio is between 0 and 1, subtract from 1.*/\\nconst oneMinus = (ratio) => {\\n  assertIsRatio(ratio);\\n  assert.assert(\\n  ratio.numerator.brand === ratio.denominator.brand,\\n  assert.details`oneMinus only supports ratios with a single brand, but ${ratio.numerator.brand} doesn't match ${ratio.denominator.brand}`);\\n\\n  assert.assert(\\n  ratio.numerator.value <= ratio.denominator.value,\\n  assert.details`Parameter must be less than or equal to 1: ${ratio.numerator.value}/${ratio.denominator.value}`);\\n\\n  return makeRatio(\\n  subtract(ratio.denominator.value, ratio.numerator.value),\\n  ratio.numerator.brand,\\n  ratio.denominator.value,\\n  ratio.numerator.brand);};exports.addRatios = addRatios;exports.assertIsRatio = assertIsRatio;exports.divideBy = divideBy;exports.invertRatio = invertRatio;exports.makeRatio = makeRatio;exports.makeRatioFromAmounts = makeRatioFromAmounts;exports.multiplyBy = multiplyBy;exports.multiplyRatios = multiplyRatios;exports.oneMinus = oneMinus;\",\n  \"packages/zoe/src/contractSupport/safeMath.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var\\n\\n\\n\\nnat_esm = require('../../../../node_modules/@agoric/nat/dist/nat.esm.js'); /* @ts-check*/ /**\\n * These operations should be used for calculations with the values of\\n * basic fungible tokens.\\n *\\n * natSafeMath is designed to be used directly, and so it needs to\\n * validate the inputs, as well as the outputs when necessary.\\n */\\nconst natSafeMath = harden({\\n  /* BigInts don't observably overflow*/\\n  add: (x, y) => nat_esm.Nat(x) + nat_esm.Nat(y),\\n  subtract: (x, y) => nat_esm.Nat(nat_esm.Nat(x) - nat_esm.Nat(y)),\\n  multiply: (x, y) => nat_esm.Nat(x) * nat_esm.Nat(y),\\n  floorDivide: (x, y) => nat_esm.Nat(x) / nat_esm.Nat(y),\\n  ceilDivide: (x, y) => {\\n    y = nat_esm.Nat(y);\\n    return nat_esm.Nat(nat_esm.Nat(x) + y - 1n) / y;},\\n\\n  /* Numbers and BigInts already compare magnitudes correctly.*/\\n  isGTE: (x, y) => x >= y });exports.natSafeMath = natSafeMath;\",\n  \"packages/zoe/src/contractSupport/stateMachine.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });var\\n\\n\\n\\nassert = require('../../../assert/src/assert.js'); /* @ts-check*/ /* allowedTransitions is an array of arrays which gets turned into a\\n * map. The map maps string states to an array of potential next\\n * states. For example,\\n * const allowedTransitions = [\\n ['open', ['closed']],\\n ['closed', []],\\n * ];\\n*/\\nconst makeStateMachine = (initialState, allowedTransitionsArray) => {\\n  let state = initialState;\\n  const allowedTransitions = new Map(allowedTransitionsArray);\\n  return harden({\\n    canTransitionTo: (nextState) =>\\n    allowedTransitions.get(state).includes(nextState),\\n    transitionTo: (nextState) => {\\n      assert.assert(allowedTransitions.get(state).includes(nextState));\\n      state = nextState;},\\n\\n    getStatus: (_) => state });};\\n\\n\\nharden(makeStateMachine);exports.makeStateMachine = makeStateMachine;\",\n  \"packages/zoe/src/contractSupport/statistics.js\": \"'use strict';\\n\\n\\n\\n\\n\\n\\n\\nObject.defineProperty(exports, '__esModule', { value: true }); /**\\n * @template T\\n * @typedef {Object} TypedMath\\n * @property {(a: T, b: T) => T} add\\n * @property {(a: T, b: T) => T} divide\\n * @property {(a: T, b: T) => boolean} isGTE\\n */ /**\\n * Calculate the median of a set of samples\\n *\\n * @template T\\n * @param {Array<T>} samples the input measurements\\n * @param {TypedMath<T>} math\\n * @returns {T=} the median (undefined if no samples)\\n */const calculateMedian = (samples, math) => {const sorted = samples.sort((a, b) => {if (!math.isGTE(a, b)) {return -1;} else if (!math.isGTE(b, a)) {return 1;}\\n\\n    return 0;});\\n\\n\\n  if (sorted.length === 0) {\\n    /* No valid samples, don't report anything.*/\\n    return undefined;}\\n\\n\\n  if (sorted.length % 2 !== 0) {\\n    /* Odd length, just pick the middle element.*/\\n    return sorted[(sorted.length - 1) / 2];}\\n\\n\\n  /* Even length, take the mean of the two middle values.*/\\n  const secondIndex = sorted.length / 2;\\n  const sum = math.add(sorted[secondIndex - 1], sorted[secondIndex]);\\n  return math.divide(sum, 2);};exports.calculateMedian = calculateMedian;\",\n  \"packages/zoe/src/contractSupport/types.js\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n'use strict'; /* eslint-disable-next-line spaced-comment*/ /*/ <reference types=\\\"ses\\\"/>*/ /**\\n * @typedef {Object} SeatGainsLossesRecord\\n * @property {ZCFSeat} seat\\n * @property {AmountKeywordRecord} gains - what the seat will\\n * gain as a result of this trade\\n * @property {AmountKeywordRecord=} losses - what the seat will\\n * give up as a result of this trade. Losses is optional, but can\\n * only be omitted if the keywords for both seats are the same.\\n * If losses is not defined, the gains of the other seat is\\n * subtracted.\\n */ /**\\n * @callback Swap\\n * If two seats can satisfy each other's wants, trade enough to\\n * satisfy the wants of both seats and exit both seats.\\n *\\n * The surplus remains with the original seat. For example if seat A\\n * gives 5 moola and seat B only wants 3 moola, seat A retains 2\\n * moola.\\n *\\n * If the swap fails, no assets are transferred, both seats will fail,\\n * and the function throws.\\n *\\n * The keywords for both seats must match.\\n *\\n * @param {ContractFacet} zcf\\n * @param {ZCFSeat} leftSeat\\n * @param {ZCFSeat} rightSeat\\n * @returns {string}\\n */ /**\\n * @callback SwapExact\\n *\\n * Swap such that both seats gain what they want and lose everything\\n * that they gave. Only good for exact and entire swaps where each\\n * seat wants everything that the other seat has. The benefit of using\\n * this method is that the keywords of each seat do not matter.\\n *\\n * If the swap fails, no assets are transferred, both seats will fail,\\n * and the function throws.\\n *\\n * @param {ContractFacet} zcf\\n * @param {ZCFSeat} leftSeat\\n * @param {ZCFSeat} rightSeat\\n * @returns {string}\\n */ /**\\n * @typedef {Object} OfferToReturns\\n *\\n * The return value of offerTo is a promise for the userSeat for the\\n * offer to the other contract, and a promise (`deposited`) which\\n * resolves when the payout for the offer has been deposited to the `toSeat`\\n * @property {Promise<UserSeat>} userSeatPromise\\n * @property {Promise<AmountKeywordRecord>} deposited\\n */ /**\\n * @typedef {Record<Keyword,Keyword>} KeywordKeywordRecord\\n *\\n * A mapping of keywords to keywords.\\n */ /**\\n * @callback OfferTo\\n *\\n * Make an offer to another contract instance (labeled contractB below),\\n * withdrawing the payments for the offer from a seat in the current\\n * contract instance (contractA) and depositing the payouts in another\\n * seat in the current contract instance (contractA).\\n *\\n * @param {ContractFacet} zcf\\n *   Zoe Contract Facet for contractA\\n *\\n * @param {ERef<Invitation>} invitation\\n *   Invitation to contractB\\n *\\n * @param {KeywordKeywordRecord=} keywordMapping\\n *   Mapping of keywords used in contractA to keywords to be used in\\n *   contractB. Note that the pathway to deposit the payout back to\\n *   contractA reverses this mapping.\\n *\\n * @param {Proposal} proposal\\n *   The proposal for the offer to be made to contractB\\n *\\n * @param {ZCFSeat} fromSeat\\n *   The seat in contractA to take the offer payments from.\\n *\\n * @param {ZCFSeat=} toSeat\\n *   The seat in contractA to deposit the payout of the offer to.\\n *   If `toSeat` is not provided, this defaults to the `fromSeat`.\\n *\\n * @returns {OfferToReturns}\\n */ /**\\n * @callback Reverse\\n *\\n * Given a mapping of keywords to keywords, invert the keys and\\n * values. This is used to map the offers made to another contract\\n * back to the keywords used in the first contract.\\n * @param {KeywordKeywordRecord=} keywordRecord\\n * @returns {KeywordKeywordRecord }\\n */ /**\\n * @callback MapKeywords\\n *\\n * Remap the keywords of an amountKeywordRecord or a\\n * PaymentPKeywordRecord according to a mapping. This is used to remap\\n * from keywords used in contractA to keywords used in contractB and\\n * vice versa in `offerTo`\\n *\\n * @param {AmountKeywordRecord | PaymentPKeywordRecord | undefined }\\n * keywordRecord\\n * @param {KeywordKeywordRecord} keywordMapping\\n */ /**\\n * @typedef {Object} Ratio\\n * @property {Amount} numerator\\n * @property {Amount} denominator\\n */ /**\\n * @callback MakeRatio\\n * @param {bigint} numerator\\n * @param {Brand} numeratorBrand\\n * @param {bigint=} denominator The default denomiator is 100\\n * @param {Brand=} denominatorBrand The default is to reuse the numeratorBrand\\n * @returns {Ratio}\\n */ /**\\n * @callback MakeRatioFromAmounts\\n * @param {Amount} numerator\\n * @param {Amount} denominator\\n * @returns {Ratio}\\n */ /**\\n * @callback MultiplyBy\\n * @param {Amount} amount\\n * @param {Ratio} ratio\\n * @returns {amount}\\n */ /**\\n * @callback DivideBy\\n * @param {Amount} amount\\n * @param {Ratio} ratio\\n * @returns {amount}\\n */ /**\\n * @callback InvertRatio\\n * @param {Ratio} ratio\\n * @returns {Ratio}\\n */ /**\\n * @callback oneMinus\\n * @param {Ratio} ratio\\n * @returns {Ratio}\\n */ /**\\n * @callback addRatios\\n * @param {Ratio} left\\n * @param {Ratio} right\\n * @returns {Ratio}\\n */ /**\\n * @callback multiplyRatios\\n * @param {Ratio} left\\n * @param {Ratio} right\\n * @returns {Ratio}\\n */\",\n  \"packages/zoe/src/contractSupport/zoeHelpers.js\": \"'use strict';Object.defineProperty(exports, '__esModule', { value: true });require('../../exported.js');var assert = require('../../../assert/src/assert.js');require('../../../same-structure/index.js');var noShim = require('../../../eventual-send/src/no-shim.js');var promiseKit = require('../../../promise-kit/src/promiseKit.js');require('../../../ERTP/src/index.js');var offerSafety = require('../contractFacet/offerSafety.js');var sameStructure = require('../../../same-structure/src/sameStructure.js');var amountMath = require('../../../ERTP/src/amountMath.js'); /* @ts-check*/\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nconst defaultAcceptanceMsg = `The offer has been accepted. Once the contract has been completed, please check your payout`;\\n\\nconst getKeysSorted = (obj) =>\\nharden(Object.getOwnPropertyNames(obj || {}).sort());\\n\\nconst assertIssuerKeywords = (zcf, expected) => {\\n  const { issuers } = zcf.getTerms();\\n  const actual = getKeysSorted(issuers);\\n  expected = [...expected]; /* in case hardened*/\\n  expected.sort();\\n  assert.assert(\\n  sameStructure.sameStructure(actual, harden(expected)),\\n  assert.details`keywords: ${actual} were not as expected: ${expected}`);};\\n\\n\\n\\n/**\\n * @typedef {Object} ZcfSeatPartial\\n * @property {() => ProposalRecord} getProposal\\n * @property {() => Allocation} getCurrentAllocation\\n */\\n\\n/**\\n * Check whether an update to currentAllocation satisfies\\n * proposal.want. Note that this is half of the offer safety\\n * check; whether the allocation constitutes a refund is not\\n * checked. The update is merged with currentAllocation\\n * (update's values prevailing if the keywords are the same)\\n * to produce the newAllocation.\\n *\\n * @param {ContractFacet} zcf\\n * @param {ZcfSeatPartial} seat\\n * @param {AmountKeywordRecord} update\\n * @returns {boolean}\\n */\\nconst satisfies = (zcf, seat, update) => {\\n  const currentAllocation = seat.getCurrentAllocation();\\n  const newAllocation = { ...currentAllocation, ...update };\\n  const proposal = seat.getProposal();\\n  return offerSafety.satisfiesWant(proposal, newAllocation);};\\n\\n\\n/** @type {Swap} */\\nconst swap = (zcf, leftSeat, rightSeat) => {\\n  try {\\n    rightSeat.decrementBy(leftSeat.getProposal().want);\\n    leftSeat.incrementBy(leftSeat.getProposal().want);\\n\\n    leftSeat.decrementBy(rightSeat.getProposal().want);\\n    rightSeat.incrementBy(rightSeat.getProposal().want);\\n\\n    zcf.reallocate(leftSeat, rightSeat);}\\n  catch (err) {\\n    leftSeat.fail(err);\\n    rightSeat.fail(err);\\n    throw err;}\\n\\n\\n  leftSeat.exit();\\n  rightSeat.exit();\\n  return defaultAcceptanceMsg;};\\n\\n\\n/** @type {SwapExact} */\\nconst swapExact = (zcf, leftSeat, rightSeat) => {\\n  try {\\n    rightSeat.decrementBy(rightSeat.getProposal().give);\\n    leftSeat.incrementBy(leftSeat.getProposal().want);\\n\\n    leftSeat.decrementBy(leftSeat.getProposal().give);\\n    rightSeat.incrementBy(rightSeat.getProposal().want);\\n\\n    zcf.reallocate(leftSeat, rightSeat);}\\n  catch (err) {\\n    leftSeat.fail(err);\\n    rightSeat.fail(err);\\n    throw err;}\\n\\n\\n  leftSeat.exit();\\n  rightSeat.exit();\\n  return defaultAcceptanceMsg;};\\n\\n\\n/**\\n * @typedef ExpectedRecord\\n * @property {Record<Keyword, null>} [want]\\n * @property {Record<Keyword, null>} [give]\\n * @property {Partial<Record<keyof ProposalRecord['exit'], null>>} [exit]\\n */\\n\\n/**\\n * Check the seat's proposal against an `expected` record that says\\n * what shape of proposal is acceptable.\\n *\\n * This ExpectedRecord is like a Proposal, but the amounts in 'want'\\n * and 'give' should be null; the exit clause should specify a rule with\\n * null contents. If the client submits an offer which does not match\\n * these expectations, the seat will be exited (and payments refunded).\\n *\\n * @param {ZCFSeat} seat\\n * @param {ExpectedRecord} expected\\n */\\nconst assertProposalShape = (seat, expected) => {\\n  assert.assert.typeof(expected, 'object');\\n  assert.assert(!Array.isArray(expected), assert.details`Expected must be an non-array object`);\\n  const assertValuesNull = (e) => {\\n    if (e !== undefined) {\\n      Object.values(e).forEach((value) =>\\n      assert.assert(\\n      value === null,\\n      assert.details`The value of the expected record must be null but was ${value}`));}};\\n\\n\\n\\n\\n\\n  /* Assert values of the expected record are all null. We do not*/\\n  /* check the values of the actual proposal.*/\\n  assertValuesNull(expected.give);\\n  assertValuesNull(expected.want);\\n  assertValuesNull(expected.exit);\\n\\n  const actual = seat.getProposal();\\n  const assertKeys = (a, e) => {\\n    if (e !== undefined) {\\n      assert.assert(\\n      sameStructure.sameStructure(getKeysSorted(a), getKeysSorted(e)),\\n      assert.details`actual ${a} did not match expected ${e}`);}};\\n\\n\\n\\n  assertKeys(actual.give, expected.give);\\n  assertKeys(actual.want, expected.want);\\n  assertKeys(actual.exit, expected.exit);};\\n\\n\\n/* Given a brand, assert that brand is AssetKind.NAT. */\\nconst assertNatAssetKind = (zcf, brand) => {\\n  assert.assert(\\n  zcf.getAssetKind(brand) === amountMath.AssetKind.NAT,\\n  assert.details`brand must be AssetKind.NAT`);};\\n\\n\\n\\nconst depositToSeatSuccessMsg = `Deposit and reallocation successful.`;\\n\\n/**\\n * Deposit payments such that their amounts are reallocated to a seat.\\n * The `amounts` and `payments` records must have corresponding\\n * keywords.\\n *\\n * @param {ContractFacet} zcf\\n * @param {ZCFSeat} recipientSeat\\n * @param {AmountKeywordRecord} amounts\\n * @param {PaymentPKeywordRecord} payments\\n * @returns {Promise<string>} `Deposit and reallocation successful.`\\n */\\n\\nasync function depositToSeat(zcf, recipientSeat, amounts, payments) {\\n  assert.assert(!recipientSeat.hasExited(), 'The recipientSeat cannot have exited.');\\n\\n  /* We will create a temporary offer to be able to escrow our payments*/\\n  /* with Zoe.*/\\n  function reallocateAfterDeposit(tempSeat) {\\n    /* After the assets are deposited, reallocate them onto the recipient seat and*/\\n    /* exit the temporary seat. Note that the offerResult is the return value of this*/\\n    /* function, so this synchronous trade must happen before the*/\\n    /* offerResult resolves.*/\\n    tempSeat.decrementBy(amounts);\\n    recipientSeat.incrementBy(amounts);\\n    zcf.reallocate(tempSeat, recipientSeat);\\n    tempSeat.exit();\\n    return depositToSeatSuccessMsg;}\\n\\n  const invitation = zcf.makeInvitation(\\n  reallocateAfterDeposit,\\n  'temporary seat for deposit');\\n\\n  const proposal = harden({ give: amounts });\\n  harden(payments);\\n  /* To escrow the payment, we must get the Zoe Service facet and*/\\n  /* make an offer*/\\n  const zoe = zcf.getZoeService();\\n  const tempUserSeat = noShim.E(zoe).offer(invitation, proposal, payments);\\n  /* This will be a promise for the string: `Deposit and reallocation*/\\n  /* successful.` It will only fulfill after the assets have been*/\\n  /* successfully reallocated to the recipient seat.*/\\n  return noShim.E(tempUserSeat).getOfferResult();}\\n\\n\\n/**\\n * Withdraw payments from a seat. Note that withdrawing the amounts of\\n * the payments must not and cannot violate offer safety for the seat. The\\n * `amounts` and `payments` records must have corresponding keywords.\\n *\\n * @param {ContractFacet} zcf\\n * @param {ZCFSeat} seat\\n * @param {AmountKeywordRecord} amounts\\n * @returns {Promise<PaymentPKeywordRecord>}\\n */\\nasync function withdrawFromSeat(zcf, seat, amounts) {\\n  assert.assert(!seat.hasExited(), 'The seat cannot have exited.');\\n  const { zcfSeat: tempSeat, userSeat: tempUserSeatP } = zcf.makeEmptySeatKit();\\n  seat.decrementBy(amounts);\\n  tempSeat.incrementBy(amounts);\\n  zcf.reallocate(tempSeat, seat);\\n  tempSeat.exit();\\n  return noShim.E(tempUserSeatP).getPayouts();}\\n\\n\\n/**\\n * Save all of the issuers in an issuersKeywordRecord to ZCF, using\\n * the method `zcf.saveIssuer`. This does not error if any of the keywords\\n * already exist. If the keyword is already present, it is ignored.\\n *\\n * @param {ContractFacet} zcf\\n * @param {IssuerKeywordRecord} issuerKeywordRecord Issuers to save to\\n * ZCF\\n */\\nasync function saveAllIssuers(zcf, issuerKeywordRecord = harden({})) {\\n  const { issuers } = zcf.getTerms();\\n  const issuersPSaved = Object.entries(issuerKeywordRecord).map(\\n  ([keyword, issuer]) => {\\n    /* If the keyword does not yet exist, add it and the*/\\n    /* associated issuer.*/\\n    if (issuers[keyword] === undefined) {\\n      return zcf.saveIssuer(issuer, keyword);}\\n\\n    return undefined;});\\n\\n\\n  return Promise.all(issuersPSaved);}\\n\\n\\n/** @type {MapKeywords} */\\nconst mapKeywords = (keywordRecord = {}, keywordMapping) => {\\n  return Object.fromEntries(\\n  Object.entries(keywordRecord).map(([keyword, value]) => {\\n    if (keywordMapping[keyword] === undefined) {\\n      return [keyword, value];}\\n\\n    return [keywordMapping[keyword], value];}));};\\n\\n\\n\\n/** @type {Reverse} */\\nconst reverse = (keywordRecord = {}) => {\\n  return Object.fromEntries(\\n  Object.entries(keywordRecord).map(([key, value]) => [value, key]));};\\n\\n\\n\\n/** @type {OfferTo} */\\nconst offerTo = async (\\nzcf,\\ninvitation,\\nkeywordMapping = {},\\nproposal,\\nfromSeat,\\ntoSeat) =>\\n{\\n  const definedToSeat = toSeat !== undefined ? toSeat : fromSeat;\\n\\n  const zoe = zcf.getZoeService();\\n  const mappingReversed = reverse(keywordMapping);\\n\\n  /* the proposal is in the other contract's keywords, but we want to*/\\n  /* use `proposal.give` to withdraw*/\\n  const payments = await withdrawFromSeat(\\n  zcf,\\n  fromSeat,\\n  /* `proposal.give` may be undefined*/\\n  mapKeywords(proposal.give, mappingReversed));\\n\\n\\n  /* Map to the other contract's keywords*/\\n  const paymentsForOtherContract = mapKeywords(payments, keywordMapping);\\n\\n  const userSeatPromise = noShim.E(zoe).offer(\\n  invitation,\\n  proposal,\\n  paymentsForOtherContract);\\n\\n\\n  const depositedPromiseKit = promiseKit.makePromiseKit();\\n\\n  const doDeposit = async (payoutPayments) => {\\n    const amounts = await noShim.E(userSeatPromise).getCurrentAllocation();\\n\\n    /* Map back to the original contract's keywords*/\\n    const mappedAmounts = mapKeywords(amounts, mappingReversed);\\n    const mappedPayments = mapKeywords(payoutPayments, mappingReversed);\\n    await depositToSeat(zcf, definedToSeat, mappedAmounts, mappedPayments);\\n    depositedPromiseKit.resolve(mappedAmounts);};\\n\\n\\n  noShim.E(userSeatPromise).\\n  getPayouts().\\n  then(doDeposit);\\n\\n  return harden({ userSeatPromise, deposited: depositedPromiseKit.promise });};\\n\\n\\n/**\\n * Create a wrapped version of zcf that asserts an invariant\\n * before performing a reallocation.\\n *\\n * @param {ContractFacet} zcf\\n * @param {(seats: ZCFSeat[]) => void} assertFn - an assertion\\n * that must be true for the reallocate to occur\\n * @returns {ContractFacet}\\n */\\nconst checkZCF = (zcf, assertFn) => {\\n  const checkedZCF = harden({\\n    ...zcf,\\n    reallocate: (...seats) => {\\n      assertFn(seats);\\n      /* @ts-ignore The types aren't right for spreading*/\\n      zcf.reallocate(...seats);} });\\n\\n\\n  return checkedZCF;};exports.assertIssuerKeywords = assertIssuerKeywords;exports.assertNatAssetKind = assertNatAssetKind;exports.assertProposalShape = assertProposalShape;exports.checkZCF = checkZCF;exports.defaultAcceptanceMsg = defaultAcceptanceMsg;exports.depositToSeat = depositToSeat;exports.depositToSeatSuccessMsg = depositToSeatSuccessMsg;exports.mapKeywords = mapKeywords;exports.offerTo = offerTo;exports.satisfies = satisfies;exports.saveAllIssuers = saveAllIssuers;exports.swap = swap;exports.swapExact = swapExact;exports.withdrawFromSeat = withdrawFromSeat;\",\n  \"packages/zoe/src/contracts/callSpread/types.js\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n'use strict'; /**\\n * @typedef {'long' | 'short'} PositionKind\\n */ /**\\n * @callback MakeOptionInvitation\\n * @param {PositionKind} positionKind\\n * @returns {Promise<Payment>}\\n */ /**\\n * @typedef {Object} PayoffHandler\\n * @property {() => void} schedulePayoffs\\n * @property  {MakeOptionInvitation} makeOptionInvitation\\n */ /**\\n * @callback MakePayoffHandler\\n * @param {ContractFacet} zcf\\n * @param {Record<PositionKind,PromiseRecord<ZCFSeat>>} seatPromiseKits\\n * @param {ZCFSeat} collateralSeat\\n * @returns {PayoffHandler}\\n */ /**\\n * @typedef {Object} CalculateSharesReturn\\n * Return value from calculateShares, which represents the portions assigned to\\n * the long and short side of a transaction. These will be two non-negative\\n * integers that sum to 100.\\n * @property {Ratio} longShare\\n * @property {Ratio} shortShare\\n */ /**\\n * @callback CalculateShares\\n * calculate the portion (as a percentage) of the collateral that should be\\n * allocated to the long side of a call spread contract. price gives the value\\n * of the underlying asset at closing that determines the payouts to the parties\\n *\\n * if price <= strikePrice1, return Ratio representing 0\\n * if price >= strikePrice2, return Ratio representing 1.\\n * Otherwise return longShare and shortShare representing ratios between 0% and\\n * 100% reflecting the position of the price in the range from strikePrice1 to\\n * strikePrice2.\\n * @param {Brand} collateralBrand\\n * @param {Amount} price\\n * @param {Amount} strikePrice1\\n * @param {Amount} strikePrice2\\n * @returns {CalculateSharesReturn}\\n */ /**\\n * @callback Make100Percent\\n * @param {Brand} brand\\n * @returns {Ratio}\\n */ /**\\n * @callback Make0Percent\\n * @param {Brand} brand\\n * @returns {Ratio}\\n */\",\n  \"packages/zoe/src/contracts/exported.js\": \"'use strict';require('./types.js');require('./loan/types.js');require('./multipoolAutoswap/types.js');require('./priceAggregatorTypes.js');require('./callSpread/types.js');\",\n  \"packages/zoe/src/contracts/loan/types.js\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n'use strict'; /**\\n * @typedef {Notifier<Timestamp>} PeriodNotifier\\n *\\n *  The Notifier that provides notifications that periods have passed.\\n *  Since notifiers can't be relied on to produce an output every time\\n *  they should, we'll track the time of last payment, and catch up if\\n *  any times have been missed. Compound interest will be calculated\\n *  using the interestRate.\\n */ /**\\n * @typedef {Instance} AutoswapInstance\\n *   The running contract instance for an Autoswap or Multipool\\n *   Autoswap installation.  The publicFacet from the Autoswap\\n *   instance is used for producing an invitation to sell the\\n *   collateral on liquidation.\\n */ /**\\n * @typedef LoanTerms\\n *\\n * @property {Ratio} mmr - Maintenance Margin Requirement, a Ratio record.\\n * Default is 150%\\n *\\n * @property {AutoswapInstance} autoswapInstance\\n *\\n * @property {PriceAuthority} priceAuthority\\n *\\n *   Used for getting the current value of collateral and setting\\n *   liquidation triggers.\\n *\\n * @property {PeriodNotifier} periodNotifier\\n *\\n * @property {Ratio} interestRate\\n *   The rate in basis points that will be multiplied with the debt on\\n *   every period to compound interest.\\n *\\n * @property {RelativeTime} interestPeriod\\n *\\n * @property {Brand} loanBrand\\n * @property {Brand} collateralBrand\\n */ /**\\n * @typedef LenderSeatProperty\\n * @property {ZCFSeat} lenderSeat\\n *\\n *   The ZCFSeat representing the lender's position in the contract.\\n */ /**\\n * @typedef {LoanTerms & LenderSeatProperty} LoanConfigWithLender\\n *\\n * The loan now has a lenderSeat, which is added to the config.\\n */ /**\\n * @typedef BorrowerConfigProperties\\n *\\n * @property {ZCFSeat} collateralSeat\\n *\\n *   The ZCFSeat holding the collateral in escrow after the borrower\\n *   escrows it\\n *\\n * @property {() => Amount} getDebt\\n *\\n *   A function to get the current debt\\n *\\n * @property {PromiseRecord<PriceQuote>} liquidationPromiseKit\\n *\\n *   PromiseKit that includes a promise that resolves to a PriceQuote\\n *   when liquidation is triggered\\n */ /**\\n * @typedef BorrowerConfigPropertiesMinusDebt\\n *\\n * @property {ZCFSeat} collateralSeat\\n *\\n *   The ZCFSeat holding the collateral in escrow after the borrower\\n *   escrows it\\n *\\n * @property {PromiseRecord<PriceQuote>} liquidationPromiseKit\\n *\\n *   PromiseKit that includes a promise that resolves to a PriceQuote\\n *   when liquidation is triggered\\n */ /**\\n * @typedef {LoanConfigWithLender & BorrowerConfigProperties } LoanConfigWithBorrower\\n *\\n * The loan has a lender, a borrower, and collateral escrowed.\\n */ /**\\n * @typedef {LoanConfigWithLender & BorrowerConfigPropertiesMinusDebt\\n * } LoanConfigWithBorrowerMinusDebt\\n */ /**\\n * @callback ScheduleLiquidation\\n * @param {ContractFacet} zcf\\n * @param {LoanConfigWithBorrower} config\\n */ /**\\n * @callback MakeLendInvitation\\n * @param {ContractFacet} zcf\\n * @param {LoanTerms} config\\n * @returns {Promise<Invitation>} lendInvitation\\n */ /**\\n * @callback MakeBorrowInvitation\\n * @param {ContractFacet} zcf\\n * @param {LoanConfigWithLender} config\\n * @returns {Promise<Invitation>} borrowInvitation\\n */ /**\\n * @callback MakeCloseLoanInvitation\\n * @param {ContractFacet} zcf\\n * @param {LoanConfigWithBorrower} config\\n * @returns {Promise<Invitation>} closeLoanInvitation\\n */ /**\\n * Allows holder to add collateral to the contract. Exits the seat\\n * after adding.\\n *\\n * @callback MakeAddCollateralInvitation\\n * @param {ContractFacet} zcf\\n * @param {LoanConfigWithBorrower} config\\n * @returns {Promise<Invitation>} addCollateralInvitation\\n */ /**\\n * @callback Liquidate\\n * @param {ContractFacet} zcf\\n * @param {LoanConfigWithBorrower} config\\n * @returns {void}\\n */ /**\\n * @callback MakeDebtCalculator\\n * @param {DebtCalculatorConfig} debtCalculatorConfig\\n */ /**\\n * @callback CalcInterestFn\\n * @param {Amount} oldDebt\\n * @param {Ratio} interestRate\\n * @returns {Amount} interest\\n */ /**\\n * @typedef {Object} DebtCalculatorConfig\\n * @property {CalcInterestFn} calcInterestFn\\n *\\n *   A function to calculate the interest, given the debt value and an\\n *   interest rate in basis points.\\n *\\n * @property {Amount} originalDebt\\n *\\n *   The debt at the start of the loan, in Loan brand\\n *\\n * @property {PeriodNotifier} periodNotifier\\n *\\n *   The AsyncIterable to notify when a period has occurred\\n *\\n * @property {Ratio} interestRate\\n * @property {RelativeTime} interestPeriod\\n *\\n *  the period at which the outstanding debt increases by the interestRate\\n *\\n * @property {ContractFacet} zcf\\n *\\n * @property {LoanConfigWithBorrowerMinusDebt} configMinusGetDebt\\n * @property {Timestamp} basetime The starting point from which to calculate\\n * interest.\\n */ /**\\n * @typedef {Object} ConfigMinusGetDebt\\n * @property {ZCFSeat} collateralSeat\\n * @property {PromiseRecord<any>} liquidationPromiseKit\\n * @property {bigint} [mmr]\\n * @property {Handle<'Instance'>} autoswapInstance\\n * @property {PriceAuthority} priceAuthority\\n * @property {PeriodNotifier} periodNotifier\\n * @property {bigint} interestRate\\n * @property {RelativeTime} interestPeriod\\n * @property {ZCFSeat} lenderSeat\\n */ /**\\n * @typedef {Object} BorrowFacet\\n *\\n * @property {() => Promise<Invitation>} makeCloseLoanInvitation\\n *\\n * Make an invitation to close the loan by repaying the debt\\n *   (including interest).\\n *\\n * @property {() => Promise<Invitation>} makeAddCollateralInvitation\\n *\\n * Make an invitation to add collateral to protect against liquidation\\n *\\n * @property {() => Promise<PriceQuote>} getLiquidationPromise\\n *\\n * Get a promise for a priceQuote that will resolve if liquidation\\n * occurs. The priceQuote is for the value of the collateral that\\n * triggered the liquidation. This may be lower than expected if the\\n * price is moving quickly.\\n *\\n * @property {() => Timestamp} getLastCalculationTimestamp\\n *\\n * Get the timestamp at which the debt was most recently recalculated.\\n *\\n * @property {() => Notifier<Amount>} getDebtNotifier\\n *\\n * Get a Notifier that will be updated when the current debt (an Amount with the Loan\\n * Brand) changes. This will increase as interest is added.\\n *\\n * @property {() => Amount} getRecentCollateralAmount\\n *\\n * Get a recent report of the amount of collateral in the loan\\n */\",\n  \"packages/zoe/src/contracts/multipoolAutoswap/types.js\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n'use strict'; /**\\n * @typedef {Object} AutoswapPublicFacet\\n * @property {() => Promise<Invitation>} makeSwapInvitation synonym for\\n * makeSwapInInvitation\\n * @property {() => Promise<Invitation>} makeSwapInInvitation make an invitation\\n * that allows one to do a swap in which the In amount is specified and the Out\\n * amount is calculated\\n * @property {() => Promise<Invitation>} makeSwapOutInvitation make an invitation\\n * that allows one to do a swap in which the Out amount is specified and the In\\n * amount is calculated\\n * @property {() => Promise<Invitation>} makeAddLiquidityInvitation make an\\n * invitation that allows one to add liquidity to the pool.\\n * @property {() => Promise<Invitation>} makeRemoveLiquidityInvitation make an\\n * invitation that allows one to remove liquidity from the pool.\\n * @property {() => Issuer} getLiquidityIssuer\\n * @property {() => bigint} getLiquiditySupply get the current value of\\n * liquidity held by investors.\\n * @property {(amountIn: Amount, brandOut: Brand) => Amount} getInputPrice\\n * calculate the amount of brandOut that will be returned if the amountIn is\\n * offered using makeSwapInInvitation at the current price.\\n * @property {(amountOut: Amount, brandIn: Brand) => Amount} getOutputPrice\\n * calculate the amount of brandIn that is required in order to get amountOut\\n * using makeSwapOutInvitation at the current price\\n * @property {() => Record<string, Amount>} getPoolAllocation get an\\n * AmountKeywordRecord showing the current balances in the pool.\\n */ /**\\n * @typedef {Object} PriceAmountPair\\n *\\n * @property {Amount} amountOut\\n * @property {Amount} amountIn\\n */ /**\\n * @typedef {Object} Pool\\n * @property {(inputAmount: Amount, outputBrand: Brand, feeBP: bigint=) => PriceAmountPair } getPriceGivenAvailableInput\\n * @property {(inputBrand: Brand, outputAmount: Amount, feeBP: bigint=) => PriceAmountPair } getPriceGivenRequiredOutput\\n * @property {() => bigint} getLiquiditySupply\\n * @property {() => Issuer} getLiquidityIssuer\\n * @property {(seat: ZCFSeat) => string} addLiquidity\\n * @property {(seat: ZCFSeat) => string} removeLiquidity\\n * @property {() => ZCFSeat} getPoolSeat\\n * @property {() => Amount} getSecondaryAmount\\n * @property {() => Amount} getCentralAmount\\n * @property {() => Notifier} getNotifier\\n * @property {() => void} updateState\\n * @property {() => PriceAuthority} getToCentralPriceAuthority\\n * @property {() => PriceAuthority} getFromCentralPriceAuthority\\n */ /**\\n * @typedef {Object} MultipoolAutoswapPublicFacet\\n * @property {(issuer: Issuer, keyword: Keyword) => Promise<Issuer>} addPool\\n * add a new liquidity pool\\n * @property {() => Promise<Invitation>} makeSwapInvitation synonym for\\n * makeSwapInInvitation\\n * @property {() => Promise<Invitation>} makeSwapInInvitation make an invitation\\n * that allows one to do a swap in which the In amount is specified and the Out\\n * amount is calculated\\n * @property {() => Promise<Invitation>} makeSwapOutInvitation make an invitation\\n * that allows one to do a swap in which the Out amount is specified and the In\\n * amount is calculated\\n * @property {() => Promise<Invitation>} makeAddLiquidityInvitation make an\\n * invitation that allows one to add liquidity to the pool.\\n * @property {() => Promise<Invitation>} makeRemoveLiquidityInvitation make an\\n * invitation that allows one to remove liquidity from the pool.\\n * @property {(brand: Brand) => Issuer} getLiquidityIssuer\\n * @property {(brand: Brand) => bigint} getLiquiditySupply get the current value of\\n * liquidity in the pool for brand held by investors.\\n * @property {(amountIn: Amount, brandOut: Brand) => Amount} getInputPrice\\n * calculate the amount of brandOut that will be returned if the amountIn is\\n * offered using makeSwapInInvitation at the current price.\\n * @property {(amountOut: Amount, brandIn: Brand) => Amount} getOutputPrice\\n * calculate the amount of brandIn that is required in order to get amountOut\\n * using makeSwapOutInvitation at the current price\\n * @property {(amountIn: Amount, brandOut: Brand) => PriceAmountPair} getPriceGivenAvailableInput\\n * calculate the amount of brandOut that will be returned if the amountIn is\\n * offered using makeSwapInInvitation at the current price. Include the minimum\\n * amountIn required to gain that much.\\n * @property {(amountOut: Amount, brandIn: Brand) => PriceAmountPair} getPriceGivenRequiredOutput\\n * calculate the amount of brandIn that is required in order to get amountOut\\n * using makeSwapOutInvitation at the current price. Include the maximum amount\\n * of amountOut that can be gained for that amountIn.\\n * @property {(brand: Brand) => Record<string, Amount>} getPoolAllocation get an\\n * AmountKeywordRecord showing the current balances in the pool for brand.\\n * @property {() => Issuer} getQuoteIssuer - get the Issuer that attests to\\n * the prices in the priceQuotes issued by the PriceAuthorities\\n * @property {(brand: Brand) => {toCentral: PriceAuthority, fromCentral: PriceAuthority}} getPriceAuthorities\\n * get a pair of PriceAuthorities { toCentral, fromCentral } for requesting\\n * Prices and notifications about changing prices.\\n */ /**\\n * @typedef {Object} MultipoolAutoswapCreatorFacet\\n * @property {() => Invitation<Issuer>} makeCollectFeesInvitation\\n * return an invitation that allows the caller to collect fees paid to the\\n * autoswap\\n */\",\n  \"packages/zoe/src/contracts/priceAggregatorTypes.js\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n'use strict'; /**\\n * @typedef {Object} OracleAdmin\\n * @property {() => Promise<void>} delete Remove the oracle from the aggregator\\n * @property {(result: any) => Promise<void>} pushResult rather than waiting for\\n * the polling query, push a result directly from this oracle\\n */ /**\\n * @callback PriceAggregatorCreatorFacetInitOracle\\n * @param {Instance} oracleInstance\\n * @param {unknown=} query\\n * @returns {Promise<OracleAdmin>}\\n */ /**\\n * @typedef {Object} PriceAggregatorCreatorFacet\\n * @property {(quoteMint: Mint) => Promise<void>} initializeQuoteMint\\n * @property {PriceAggregatorCreatorFacetInitOracle} initOracle\\n */ /**\\n * @typedef {Object} PriceAggregatorPublicFacet\\n * @property {() => PriceAuthority} getPriceAuthority\\n */ /**\\n * @typedef {Object} PriceAggregatorKit\\n * @property {PriceAggregatorPublicFacet} publicFacet\\n * @property {PriceAggregatorCreatorFacet} creatorFacet\\n */ /**\\n * @typedef {Object} OraclePublicFacet the public methods accessible from the\\n * contract instance\\n * @property {(query: any) => ERef<Invitation>} makeQueryInvitation create an\\n * invitation for an oracle query\\n * @property {(query: any) => ERef<any>} query make an unpaid query\\n */ /**\\n * @callback OracleCreatorFacetMakeWithdrawInvitation\\n * @param {boolean=} total\\n * @returns {ERef<Invitation>}\\n */ /**\\n * @typedef {Object} OracleCreatorFacet the private methods accessible from the\\n * contract instance\\n * @property {() => AmountKeywordRecord} getCurrentFees get the current\\n * fee amounts\\n * @property {OracleCreatorFacetMakeWithdrawInvitation}\\n * makeWithdrawInvitation create an invitation to withdraw fees\\n * @property {() => Promise<Invitation>} makeShutdownInvitation\\n *   Make an invitation to withdraw all fees and shutdown\\n */ /**\\n * @typedef {Object} OraclePrivateParameters\\n * @property {OracleHandler} oracleHandler\\n */ /**\\n * @typedef {Object} OracleInitializationFacet\\n * @property {(privateParams: OraclePrivateParameters) => OracleCreatorFacet} initialize\\n */ /**\\n * @typedef {Object} OracleStartFnResult\\n * @property {OracleInitializationFacet} creatorFacet\\n * @property {OraclePublicFacet} publicFacet\\n * @property {Instance} instance\\n */ /**\\n * @typedef {Object} OracleKit\\n * @property {OracleCreatorFacet} creatorFacet\\n * @property {OraclePublicFacet} publicFacet\\n * @property {Instance} instance\\n */ /**\\n * @typedef {Object} OracleReply\\n * @property {any} reply\\n * @property {Amount} [requiredFee]\\n */ /**\\n * @typedef {Object} OracleHandler\\n * @property {(query: any, fee: Amount) => Promise<OracleReply>} onQuery\\n * callback to reply to a query\\n * @property {(query: any, reason: any) => void} onError notice an error\\n * @property {(query: any, reply: any, requiredFee: Amount | undefined) => void}\\n * onReply notice a successful reply\\n */\",\n  \"packages/zoe/src/contracts/types.js\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n'use strict'; /**\\n * @typedef {Object} SellItemsPublicFacet\\n * @property {() => Issuer} getItemsIssuer\\n * @property {() => Amount} getAvailableItems\\n *\\n * @typedef {Object} SellItemsCreatorOnly\\n * @property {() => Promise<Invitation>} makeBuyerInvitation\\n *\\n * @typedef {SellItemsPublicFacet & SellItemsCreatorOnly} SellItemsCreatorFacet\\n */ /**\\n * @typedef {Object} SellItemsParameters\\n * @property {Record<string, any>} customValueProperties\\n * @property {bigint} count\\n * @property {Issuer} moneyIssuer\\n * @property {Installation} sellItemsInstallation\\n * @property {Amount} pricePerItem\\n *\\n * @typedef {Object} SellItemsResult\\n * @property {UserSeat} sellItemsCreatorSeat\\n * @property {SellItemsCreatorFacet} sellItemsCreatorFacet\\n * @property {Instance} sellItemsInstance\\n * @property {SellItemsPublicFacet} sellItemsPublicFacet\\n *\\n * @typedef {Object} MintAndSellNFTCreatorFacet\\n * @property {(sellParams: SellItemsParameters) => Promise<SellItemsResult>} sellTokens\\n * @property {() => Issuer} getIssuer\\n */ /**\\n * @typedef {Object} AutomaticRefundPublicFacet\\n * @property {() => bigint} getOffersCount\\n * @property {() => Promise<Invitation>} makeInvitation\\n */ /**\\n * @typedef {Object} SimpleExchangePublicFacet\\n * @property {() => Promise<Invitation>} makeInvitation\\n * @property {() => Notifier<any>} getNotifier\\n */\",\n  \"packages/zoe/src/types.js\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n'use strict'; /* eslint-disable-next-line spaced-comment*/ /*/ <reference types=\\\"ses\\\"/>*/ /**\\n * @template {string} H - the name of the handle\\n * @typedef {H & {}} Handle A type constructor for an opaque type\\n * identified by the H string. This uses an intersection type\\n * ('MyHandle' & {}) to tag the handle's type even though the actual\\n * value is just an empty object.\\n */ /**\\n * @typedef {string} Keyword\\n * @typedef {Handle<'Invitation'>} InvitationHandle - an opaque handle for an invitation\\n * @typedef {Record<Keyword,Issuer>} IssuerKeywordRecord\\n * @typedef {Record<Keyword,ERef<Issuer>>} IssuerPKeywordRecord\\n * @typedef {Record<Keyword,Brand>} BrandKeywordRecord\\n */ /**\\n * @typedef {Object} StandardTerms\\n * @property {IssuerKeywordRecord} issuers - record with\\n * keywords keys, issuer values\\n * @property {BrandKeywordRecord} brands - record with keywords\\n * keys, brand values\\n *\\n * @typedef {StandardTerms & Record<string, any>} Terms\\n *\\n * @typedef {object} InstanceRecord\\n * @property {Installation} installation\\n * @property {Instance} instance\\n * @property {Terms} terms - contract parameters\\n *\\n * @typedef {Object} IssuerRecord\\n * @property {Brand} brand\\n * @property {Issuer} issuer\\n * @property {AssetKind} assetKind\\n * @property {any} [displayInfo]\\n *\\n * @typedef {AmountKeywordRecord} Allocation\\n * @typedef {Record<Keyword,AmountMath>} AmountMathKeywordRecord\\n */ /**\\n * @typedef {Payment} Invitation\\n */\",\n  \"packages/zoe/src/zoeService/types.js\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n'use strict'; /* eslint-disable-next-line spaced-comment*/ /*/ <reference types=\\\"ses\\\"/>*/ /**\\n * @typedef {Object} ZoeService\\n *\\n * Zoe provides a framework for deploying and working with smart\\n * contracts. It is accessed as a long-lived and well-trusted service\\n * that enforces offer safety for the contracts that use it. Zoe has a\\n * single `invitationIssuer` for the entirety of its lifetime. By\\n * having a reference to Zoe, a user can get the `invitationIssuer`\\n * and thus validate any `invitation` they receive from someone else.\\n *\\n * Zoe has two different facets: the public Zoe service and the\\n * contract facet (ZCF). Each contract instance has a copy of ZCF\\n * within its vat. The contract and ZCF never have direct access to\\n * the users' payments or the Zoe purses.\\n *\\n * @property {() => Issuer} getInvitationIssuer\\n *\\n * Zoe has a single `invitationIssuer` for the entirety of its\\n * lifetime. By having a reference to Zoe, a user can get the\\n * `invitationIssuer` and thus validate any `invitation` they receive\\n * from someone else. The mint associated with the invitationIssuer\\n * creates the ERTP payments that represent the right to interact with\\n * a smart contract in particular ways.\\n *\\n * @property {Install} install\\n * @property {StartInstance} startInstance\\n * @property {Offer} offer\\n * @property {GetPublicFacet} getPublicFacet\\n * @property {GetIssuers} getIssuers\\n * @property {GetBrands} getBrands\\n * @property {GetTerms} getTerms\\n * @property {GetInstance} getInstance\\n * @property {GetInstallation} getInstallation\\n * @property {GetInvitationDetails} getInvitationDetails - return an\\n * object with the instance, installation, description, invitation\\n * handle, and any custom properties specific to the contract.\\n */ /**\\n * @callback GetPublicFacet\\n * @param {Instance} instance\\n * @returns {Object}\\n */ /**\\n * @callback GetIssuers\\n * @param {Instance} instance\\n * @returns {IssuerKeywordRecord}\\n */ /**\\n * @callback GetBrands\\n * @param {Instance} instance\\n * @returns {BrandKeywordRecord}\\n */ /**\\n * @callback GetTerms\\n * @param {Instance} instance\\n * @returns {Terms}\\n */ /**\\n * @callback GetInstance\\n * @param {ERef<Invitation>} invitation\\n * @returns {Promise<Instance>}\\n */ /**\\n * @callback GetInstallation\\n * @param {ERef<Invitation>} invitation\\n * @returns {Promise<Installation>}\\n */ /**\\n * @callback GetInvitationDetails\\n * @param {ERef<Invitation>} invitation\\n * @returns {Promise<InvitationDetails>}\\n */ /**\\n * @callback Install\\n *\\n * Create an installation by safely evaluating the code and\\n * registering it with Zoe. Returns an installation.\\n *\\n * @param {SourceBundle} bundle\\n * @returns {Installation}\\n */ /**\\n * @callback StartInstance\\n * Zoe is long-lived. We can use Zoe to create smart contract\\n * instances by specifying a particular contract installation to use,\\n * as well as the `terms` of the contract. The `terms.issuers` is a\\n * record mapping string names (keywords) to issuers, such as `{\\n * Asset: simoleanIssuer}`. (Note that the keywords must begin with a\\n * capital letter and must be ASCII identifiers.) Parties to the\\n * contract will use the keywords to index their proposal and their\\n * payments.\\n *\\n * The custom terms are the arguments to the contract, such as the\\n * number of bids an auction will wait for before closing. Custom\\n * terms are up to the discretion of the smart contract. We get back\\n * the creator facet, public facet, and creator invitation as defined\\n * by the contract.\\n *\\n * @param {ERef<Installation>} installation\\n * @param {IssuerKeywordRecord=} issuerKeywordRecord\\n * @param {Object=} terms\\n * @returns {Promise<StartInstanceResult>}\\n */ /**\\n * @callback Offer\\n *\\n * To redeem an invitation, the user normally provides a proposal (their\\n * rules for the offer) as well as payments to be escrowed by Zoe.  If\\n * either the proposal or payments would be empty, indicate this by\\n * omitting that argument or passing undefined, rather than passing an\\n * empty record.\\n *\\n * The proposal has three parts: `want` and `give` are used by Zoe to\\n * enforce offer safety, and `exit` is used to specify the particular\\n * payout-liveness policy that Zoe can guarantee. `want` and `give`\\n * are objects with keywords as keys and amounts as values.\\n * `paymentKeywordRecord` is a record with keywords as keys, and the\\n * values are the actual payments to be escrowed. A payment is\\n * expected for every rule under `give`.\\n *\\n * @param {ERef<Invitation>} invitation\\n * @param {Proposal=} proposal\\n * @param {PaymentPKeywordRecord=} paymentKeywordRecord\\n * @returns {Promise<UserSeat>} seat\\n */ /**\\n * @typedef {Object} UserSeat\\n * @property {() => Promise<Allocation>} getCurrentAllocation\\n * @property {() => Promise<ProposalRecord>} getProposal\\n * @property {() => Promise<PaymentPKeywordRecord>} getPayouts\\n * @property {(keyword: Keyword) => Promise<Payment>} getPayout\\n * @property {() => Promise<OfferResult>} getOfferResult\\n * @property {() => void=} tryExit\\n * @property {() => Promise<boolean>} hasExited\\n * @property {() => Promise<Notifier<Allocation>>} getNotifier\\n */ /**\\n * @typedef {any} OfferResult\\n */ /**\\n * @typedef {Object} AdminFacet\\n * @property {() => Promise<Completion>} getVatShutdownPromise\\n */ /**\\n * @typedef {Object} StartInstanceResult\\n * @property {any} creatorFacet\\n * @property {any} publicFacet\\n * @property {Instance} instance\\n * @property {Payment | undefined} creatorInvitation\\n * @property {AdminFacet} adminFacet\\n */ /**\\n * @typedef {Partial<ProposalRecord>} Proposal\\n *\\n * @typedef {{give: AmountKeywordRecord,\\n *            want: AmountKeywordRecord,\\n *            exit: ExitRule\\n *           }} ProposalRecord\\n */ /**\\n * @typedef {Record<Keyword,Amount>} AmountKeywordRecord\\n *\\n * The keys are keywords, and the values are amounts. For example:\\n * { Asset: AmountMath.make(5n, assetBrand), Price:\\n * AmountMath.make(9n, priceBrand) }\\n */ /**\\n * @typedef {Object} Waker\\n * @property {() => void} wake\\n */ /**\\n * @typedef {bigint} Deadline\\n */ /**\\n * @typedef {Object} Timer\\n * @property {(deadline: Deadline, wakerP: ERef<Waker>) => void} setWakeup\\n */ /**\\n * @typedef {Object} OnDemandExitRule\\n * @property {null} onDemand\\n */ /**\\n * @typedef {Object} WaivedExitRule\\n * @property {null} waived\\n */ /**\\n * @typedef {Object} AfterDeadlineExitRule\\n * @property {{timer:Timer, deadline:Deadline}} afterDeadline\\n */ /**\\n * @typedef {OnDemandExitRule | WaivedExitRule | AfterDeadlineExitRule} ExitRule\\n *\\n * The possible keys are 'waived', 'onDemand', and 'afterDeadline'.\\n * `timer` and `deadline` only are used for the `afterDeadline` key.\\n * The possible records are:\\n * `{ waived: null }`\\n * `{ onDemand: null }`\\n * `{ afterDeadline: { timer :Timer<Deadline>, deadline :Deadline } }\\n */ /**\\n * @typedef {Handle<'Instance'>} Instance\\n */ /**\\n * @typedef {Object} VatAdminSvc\\n * @property {(bundle: SourceBundle) => RootAndAdminNode} createVat\\n * @property {(BundleName: string) => RootAndAdminNode} createVatByName\\n */ /**\\n * @typedef {Record<string, any>} SourceBundle Opaque type for a JSONable source bundle\\n */ /**\\n * @typedef {Record<Keyword,ERef<Payment>>} PaymentPKeywordRecord\\n * @typedef {Record<Keyword,Payment>} PaymentKeywordRecord\\n */ /**\\n * @typedef {Object} StandardInvitationDetails\\n * @property {Installation} installation\\n * @property {Instance} instance\\n * @property {InvitationHandle} handle\\n * @property {string} description\\n */ /**\\n * @typedef {StandardInvitationDetails & Record<string, any>} InvitationDetails\\n */ /**\\n * @typedef {Object} Installation\\n * @property {() => SourceBundle} getBundle\\n */\",\n  \"packages/zoe/tools/types.js\": \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n'use strict'; /**\\n * @typedef {Object} PriceQuote\\n * @property {Amount} quoteAmount Amount whose value is a PriceQuoteValue\\n * @property {ERef<Payment> | null} quotePayment The `quoteAmount` wrapped as a payment\\n */ /**\\n * @typedef {[PriceDescription]} PriceQuoteValue A single-valued set of\\n * PriceDescriptions.  This is the `value` in PriceQuote.quoteAmount (`{ brand,\\n * value: PriceQuoteValue }`).\\n */ /**\\n * @typedef {Object} PriceDescription A description of a single quote\\n * @property {Amount} amountIn The amount supplied to a trade\\n * @property {Amount} amountOut The quoted result of trading `amountIn`\\n * @property {TimerService} timer The service that gave the `timestamp`\\n * @property {Timestamp} timestamp A timestamp according to `timer` for the\\n * quote\\n * @property {any=} conditions Additional conditions for the quote\\n */ /**\\n * @callback PriceQuoteCreate\\n * @param {PriceQuery} priceQuery\\n * @returns {ERef<PriceQuote> | undefined}\\n */ /**\\n * @callback PriceQuoteTrigger\\n * @param {PriceQuoteCreate} createQuote\\n */ /**\\n * @typedef {Object} PriceAuthorityAdmin\\n * @property {(createQuote: PriceQuoteCreate) => Promise<void>} fireTriggers\\n */ /**\\n * @typedef {Object} PriceAuthorityKit\\n * @property {PriceAuthority} priceAuthority\\n * @property {PriceAuthorityAdmin} adminFacet\\n */ /**\\n * @typedef {Object} MutableQuote\\n * @property {(reason?: any) => void} cancel\\n * @property {(amountIn: Amount, amountOut: Amount) => void} updateLevel\\n * @property {() => ERef<PriceQuote>} getPromise\\n */ /**\\n * @typedef {Object} PriceAuthority An object that mints PriceQuotes and handles\\n * triggers and notifiers for changes in the price\\n *\\n * @property {(brandIn: Brand, brandOut: Brand) => ERef<Issuer>} getQuoteIssuer\\n * Get the ERTP issuer of PriceQuotes for a given brandIn/brandOut pair\\n *\\n * @property {(brandIn: Brand, brandOut: Brand) => ERef<TimerService>}\\n * getTimerService get the timer used in PriceQuotes for a given\\n * brandIn/brandOut pair\\n *\\n * @property {(amountIn: Amount, brandOut: Brand) => ERef<Notifier<PriceQuote>>}\\n * makeQuoteNotifier Be notified of the latest PriceQuotes for a given\\n * `amountIn`.  The rate at which these are issued may be very different between\\n * `priceAuthorities`.\\n *\\n * @property {(deadline: Timestamp, amountIn: Amount, brandOut: Brand) =>\\n * Promise<PriceQuote>} quoteAtTime Resolves after `deadline` passes on the\\n * priceAuthority's timerService with the price quote of `amountIn` at that time\\n *\\n * @property {(amountIn: Amount, brandOut: Brand) => Promise<PriceQuote>}\\n * quoteGiven get a quote corresponding to the specified amountIn\\n *\\n * @property {(brandIn: Brand, amountOut: Amount) => Promise<PriceQuote>}\\n * quoteWanted get a quote corresponding to the specified amountOut\\n *\\n * @property {(amountIn: Amount, amountOutLimit: Amount) => Promise<PriceQuote>}\\n * quoteWhenGT Resolve when a price quote of `amountIn` exceeds `amountOutLimit`\\n *\\n * @property {(amountIn: Amount, amountOutLimit: Amount) => Promise<PriceQuote>}\\n * quoteWhenGTE Resolve when a price quote of `amountIn` reaches or exceeds\\n * `amountOutLimit`\\n *\\n * @property {(amountIn: Amount, amountOutLimit: Amount) => Promise<PriceQuote>}\\n * quoteWhenLTE Resolve when a price quote of `amountIn` reaches or drops below\\n * `amountOutLimit`\\n *\\n * @property {(amountIn: Amount, amountOutLimit: Amount) => Promise<PriceQuote>}\\n * quoteWhenLT Resolve when the price quote of `amountIn` drops below\\n * `amountOutLimit`\\n *\\n * @property {(amountIn: Amount, amountOutLimit: Amount) => ERef<MutableQuote>}\\n * mutableQuoteWhenGT Resolve when a price quote of `amountIn` exceeds `amountOutLimit`\\n *\\n * @property {(amountIn: Amount, amountOutLimit: Amount) => ERef<MutableQuote>}\\n * mutableQuoteWhenGTE Resolve when a price quote of `amountIn` reaches or exceeds\\n * `amountOutLimit`\\n *\\n * @property {(amountIn: Amount, amountOutLimit: Amount) => ERef<MutableQuote>}\\n * mutableQuoteWhenLTE Resolve when a price quote of `amountIn` reaches or drops below\\n * `amountOutLimit`\\n *\\n * @property {(amountIn: Amount, amountOutLimit: Amount) => ERef<MutableQuote>}\\n * mutableQuoteWhenLT Resolve when the price quote of `amountIn` drops below\\n * `amountOutLimit`\\n */ /**\\n * @typedef {(amount: Amount) => Amount} PriceCalculator\\n */ /**\\n * @callback PriceQuery\\n * @param {PriceCalculator} calcAmountIn\\n * @param {PriceCalculator} calcAmountOut\\n * @returns {{ amountIn: Amount, amountOut: Amount, timestamp?: Timestamp }=}\\n */\"\n};\n  const nsBundle = {};\n\n  function createEvalString(filename) {\n      const code = sourceBundle[filename];\n      if (!code) {\n        return undefined;\n      }\n      return `\\\n(function getExport(require, exports) { \\\n  'use strict'; \\\n  const module = { exports }; \\\n  \\\n  ${code}\n  return module.exports;\n})\n//# sourceURL=${filePrefix}/${filename}\n`;\n    }\n\n  function computeExports(filename, exportPowers, exports) {\n      const { require: systemRequire, _log } = exportPowers;\n      // This captures the endowed require.\n      const match = filename.match(/^(.*)\\/[^/]+$/);\n      const thisdir = match ? match[1] : '.';\n      const contextRequire = mod => {\n        // Do path algebra to find the actual source.\n        const els = mod.split('/');\n        let prefix;\n        if (els[0][0] === '@') {\n          // Scoped name.\n          prefix = els.splice(0, 2).join('/');\n        } else if (els[0][0] === '.') {\n          // Relative.\n          els.unshift(...thisdir.split('/'));\n        } else {\n          // Bare or absolute.\n          prefix = els.splice(0, 1);\n        }\n\n        const suffix = [];\n        for (const el of els) {\n          if (el === '.' || el === '') {\n            // Do nothing.\n          } else if (el === '..') {\n            // Traverse upwards.\n            suffix.pop();\n          } else {\n            suffix.push(el);\n          }\n        }\n\n        // log(mod, prefix, suffix);\n        if (prefix !== undefined) {\n          suffix.unshift(prefix);\n        }\n        let modPath = suffix.join('/');\n        if (modPath.startsWith('./')) {\n          modPath = modPath.slice(2);\n        }\n        // log('requiring', modPath);\n        if (!(modPath in nsBundle)) {\n          // log('evaluating', modPath);\n          // Break cycles, but be tolerant of modules\n          // that completely override their exports object.\n          nsBundle[modPath] = {};\n          nsBundle[modPath] = computeExports(\n            modPath,\n            exportPowers,\n            nsBundle[modPath],\n          );\n        }\n\n        // log('returning', nsBundle[modPath]);\n        return nsBundle[modPath];\n      };\n\n      const code = createEvalString(filename);\n      if (!code) {\n        // log('missing code for', filename, sourceBundle);\n        if (systemRequire) {\n          return systemRequire(filename);\n        }\n        throw Error(\n          `require(${JSON.stringify(\n            filename,\n          )}) failed; no toplevel require endowment`,\n        );\n      }\n\n      // log('evaluating', code);\n      return nestedEvaluate(code)(contextRequire, exports);\n    }\n\n  // Evaluate the entrypoint recursively, seeding the exports.\n  const systemRequire = typeof require === 'undefined' ? undefined : require;\n  return computeExports(entrypoint, { require: systemRequire }, {});\n}\n//# sourceURL=/bundled-source/...-preamble.js\n","sourceMap":"//# sourceURL=/bundled-source/...-preamble.js\n","moduleFormat":"nestedEvaluate"};